# 03_课堂重点记录

**学生**：王明明  
**学号**：2023111222  
**专业**：软件工程  
**学习特色**：专注于智能合约测试  

---

## 学习目标与个人定位

作为专注于智能合约测试的学习者，我致力于掌握全面的测试方法论和自动化测试技术。通过深入学习各种测试框架和工具，建立完整的智能合约质量保证体系。

---

## 第一周：测试基础与单元测试

### 课堂重点

#### 1. Hardhat测试框架基础

```javascript
// test/BasicToken.test.js
const { expect } = require("chai");
const { ethers } = require("hardhat");
const { loadFixture } = require("@nomicfoundation/hardhat-network-helpers");

/**
 * @title BasicToken测试套件
 * @dev 基础代币合约的完整测试用例
 */
describe("BasicToken Contract Tests", function () {
    // ✅ 测试夹具 - 部署合约的可重用函数
    async function deployBasicTokenFixture() {
        const [owner, addr1, addr2, addr3] = await ethers.getSigners();
        
        const BasicToken = await ethers.getContractFactory("BasicToken");
        const token = await BasicToken.deploy(
            "Test Token",
            "TEST",
            ethers.utils.parseEther("1000000") // 1M tokens
        );
        
        await token.deployed();
        
        return { token, owner, addr1, addr2, addr3 };
    }
    
    // ✅ 部署测试
    describe("Deployment", function () {
        it("Should set the right owner", async function () {
            const { token, owner } = await loadFixture(deployBasicTokenFixture);
            expect(await token.owner()).to.equal(owner.address);
        });
        
        it("Should assign the total supply to the owner", async function () {
            const { token, owner } = await loadFixture(deployBasicTokenFixture);
            const ownerBalance = await token.balanceOf(owner.address);
            expect(await token.totalSupply()).to.equal(ownerBalance);
        });
        
        it("Should set the correct token metadata", async function () {
            const { token } = await loadFixture(deployBasicTokenFixture);
            
            expect(await token.name()).to.equal("Test Token");
            expect(await token.symbol()).to.equal("TEST");
            expect(await token.decimals()).to.equal(18);
        });
    });
    
    // ✅ 转账功能测试
    describe("Transfers", function () {
        it("Should transfer tokens between accounts", async function () {
            const { token, owner, addr1 } = await loadFixture(deployBasicTokenFixture);
            const transferAmount = ethers.utils.parseEther("100");
            
            // 执行转账
            await expect(token.transfer(addr1.address, transferAmount))
                .to.changeTokenBalances(
                    token,
                    [owner, addr1],
                    [-transferAmount, transferAmount]
                );
        });
        
        it("Should emit Transfer event", async function () {
            const { token, owner, addr1 } = await loadFixture(deployBasicTokenFixture);
            const transferAmount = ethers.utils.parseEther("100");
            
            await expect(token.transfer(addr1.address, transferAmount))
                .to.emit(token, "Transfer")
                .withArgs(owner.address, addr1.address, transferAmount);
        });
        
        it("Should fail if sender doesn't have enough tokens", async function () {
            const { token, addr1, addr2 } = await loadFixture(deployBasicTokenFixture);
            const initialBalance = await token.balanceOf(addr1.address);
            
            await expect(
                token.connect(addr1).transfer(addr2.address, initialBalance.add(1))
            ).to.be.revertedWith("ERC20: transfer amount exceeds balance");
        });
        
        it("Should handle zero amount transfers", async function () {
            const { token, owner, addr1 } = await loadFixture(deployBasicTokenFixture);
            
            await expect(token.transfer(addr1.address, 0))
                .to.emit(token, "Transfer")
                .withArgs(owner.address, addr1.address, 0);
        });
    });
    
    // ✅ 授权功能测试
    describe("Allowances", function () {
        it("Should approve tokens for delegated transfer", async function () {
            const { token, owner, addr1 } = await loadFixture(deployBasicTokenFixture);
            const approveAmount = ethers.utils.parseEther("100");
            
            await expect(token.approve(addr1.address, approveAmount))
                .to.emit(token, "Approval")
                .withArgs(owner.address, addr1.address, approveAmount);
            
            expect(await token.allowance(owner.address, addr1.address))
                .to.equal(approveAmount);
        });
        
        it("Should allow delegated transfers", async function () {
            const { token, owner, addr1, addr2 } = await loadFixture(deployBasicTokenFixture);
            const approveAmount = ethers.utils.parseEther("100");
            const transferAmount = ethers.utils.parseEther("50");
            
            // 授权
            await token.approve(addr1.address, approveAmount);
            
            // 代理转账
            await expect(
                token.connect(addr1).transferFrom(owner.address, addr2.address, transferAmount)
            ).to.changeTokenBalances(
                token,
                [owner, addr2],
                [-transferAmount, transferAmount]
            );
            
            // 检查剩余授权
            expect(await token.allowance(owner.address, addr1.address))
                .to.equal(approveAmount.sub(transferAmount));
        });
        
        it("Should fail delegated transfer if allowance is insufficient", async function () {
            const { token, owner, addr1, addr2 } = await loadFixture(deployBasicTokenFixture);
            const approveAmount = ethers.utils.parseEther("50");
            const transferAmount = ethers.utils.parseEther("100");
            
            await token.approve(addr1.address, approveAmount);
            
            await expect(
                token.connect(addr1).transferFrom(owner.address, addr2.address, transferAmount)
            ).to.be.revertedWith("ERC20: insufficient allowance");
        });
    });
    
    // ✅ 边界条件测试
    describe("Edge Cases", function () {
        it("Should handle maximum uint256 approval", async function () {
            const { token, owner, addr1 } = await loadFixture(deployBasicTokenFixture);
            const maxApproval = ethers.constants.MaxUint256;
            
            await token.approve(addr1.address, maxApproval);
            expect(await token.allowance(owner.address, addr1.address))
                .to.equal(maxApproval);
        });
        
        it("Should prevent transfer to zero address", async function () {
            const { token } = await loadFixture(deployBasicTokenFixture);
            const transferAmount = ethers.utils.parseEther("100");
            
            await expect(
                token.transfer(ethers.constants.AddressZero, transferAmount)
            ).to.be.revertedWith("ERC20: transfer to the zero address");
        });
        
        it("Should handle self-transfers", async function () {
            const { token, owner } = await loadFixture(deployBasicTokenFixture);
            const transferAmount = ethers.utils.parseEther("100");
            const initialBalance = await token.balanceOf(owner.address);
            
            await token.transfer(owner.address, transferAmount);
            
            expect(await token.balanceOf(owner.address))
                .to.equal(initialBalance);
        });
    });
    
    // ✅ Gas优化测试
    describe("Gas Optimization", function () {
        it("Should measure gas consumption for transfers", async function () {
            const { token, owner, addr1 } = await loadFixture(deployBasicTokenFixture);
            const transferAmount = ethers.utils.parseEther("100");
            
            const tx = await token.transfer(addr1.address, transferAmount);
            const receipt = await tx.wait();
            
            console.log(`Transfer gas used: ${receipt.gasUsed.toString()}`);
            expect(receipt.gasUsed).to.be.below(60000); // 预期gas消耗上限
        });
        
        it("Should measure gas for batch operations", async function () {
            const { token, owner, addr1, addr2, addr3 } = await loadFixture(deployBasicTokenFixture);
            const transferAmount = ethers.utils.parseEther("100");
            
            // 批量转账测试
            const addresses = [addr1.address, addr2.address, addr3.address];
            let totalGas = ethers.BigNumber.from(0);
            
            for (const address of addresses) {
                const tx = await token.transfer(address, transferAmount);
                const receipt = await tx.wait();
                totalGas = totalGas.add(receipt.gasUsed);
            }
            
            console.log(`Batch transfer total gas: ${totalGas.toString()}`);
            console.log(`Average gas per transfer: ${totalGas.div(addresses.length).toString()}`);
        });
    });
});
```

#### 2. 高级测试技术

```javascript
// test/AdvancedTesting.test.js
const { expect } = require("chai");
const { ethers } = require("hardhat");
const { time, loadFixture } = require("@nomicfoundation/hardhat-network-helpers");

/**
 * @title 高级测试技术演示
 * @dev 包含时间操作、快照、模糊测试等高级技术
 */
describe("Advanced Testing Techniques", function () {
    
    // ✅ 时间相关测试
    describe("Time-based Testing", function () {
        async function deployTimeLockFixture() {
            const [owner, beneficiary] = await ethers.getSigners();
            
            const TimeLock = await ethers.getContractFactory("TimeLock");
            const timeLock = await TimeLock.deploy(
                beneficiary.address,
                time.duration.days(30) // 30天锁定期
            );
            
            return { timeLock, owner, beneficiary };
        }
        
        it("Should not allow withdrawal before lock period", async function () {
            const { timeLock, beneficiary } = await loadFixture(deployTimeLockFixture);
            
            // 发送ETH到合约
            await owner.sendTransaction({
                to: timeLock.address,
                value: ethers.utils.parseEther("1")
            });
            
            // 尝试提前提取
            await expect(
                timeLock.connect(beneficiary).withdraw()
            ).to.be.revertedWith("TimeLock: still locked");
        });
        
        it("Should allow withdrawal after lock period", async function () {
            const { timeLock, beneficiary } = await loadFixture(deployTimeLockFixture);
            
            // 发送ETH到合约
            await owner.sendTransaction({
                to: timeLock.address,
                value: ethers.utils.parseEther("1")
            });
            
            // 快进时间
            await time.increase(time.duration.days(31));
            
            // 现在应该可以提取
            await expect(
                timeLock.connect(beneficiary).withdraw()
            ).to.changeEtherBalance(beneficiary, ethers.utils.parseEther("1"));
        });
        
        it("Should handle multiple time-based operations", async function () {
            const { timeLock, beneficiary } = await loadFixture(deployTimeLockFixture);
            
            // 记录初始时间
            const initialTime = await time.latest();
            
            // 执行多个时间相关操作
            await time.increaseTo(initialTime + time.duration.days(10));
            expect(await timeLock.getRemainingTime()).to.be.above(time.duration.days(19));
            
            await time.increaseTo(initialTime + time.duration.days(20));
            expect(await timeLock.getRemainingTime()).to.be.above(time.duration.days(9));
            
            await time.increaseTo(initialTime + time.duration.days(30));
            expect(await timeLock.getRemainingTime()).to.equal(0);
        });
    });
    
    // ✅ 快照和回滚测试
    describe("Snapshot Testing", function () {
        let snapshotId;
        
        beforeEach(async function () {
            snapshotId = await network.provider.send("evm_snapshot");
        });
        
        afterEach(async function () {
            await network.provider.send("evm_revert", [snapshotId]);
        });
        
        it("Should maintain state consistency across tests", async function () {
            const { token, owner, addr1 } = await loadFixture(deployBasicTokenFixture);
            
            const initialBalance = await token.balanceOf(owner.address);
            
            // 执行一些操作
            await token.transfer(addr1.address, ethers.utils.parseEther("100"));
            
            expect(await token.balanceOf(owner.address))
                .to.equal(initialBalance.sub(ethers.utils.parseEther("100")));
        });
        
        it("Should reset state after previous test", async function () {
            const { token, owner } = await loadFixture(deployBasicTokenFixture);
            
            // 由于快照回滚，状态应该重置
            const balance = await token.balanceOf(owner.address);
            expect(balance).to.equal(ethers.utils.parseEther("1000000"));
        });
    });
    
    // ✅ 模糊测试（Property-based Testing）
    describe("Fuzz Testing", function () {
        it("Should handle random transfer amounts", async function () {
            const { token, owner, addr1 } = await loadFixture(deployBasicTokenFixture);
            const totalSupply = await token.totalSupply();
            
            // 生成随机测试数据
            for (let i = 0; i < 10; i++) {
                const randomAmount = ethers.BigNumber.from(
                    ethers.utils.randomBytes(32)
                ).mod(totalSupply.div(100)); // 限制在总供应量的1%以内
                
                const initialBalance = await token.balanceOf(owner.address);
                
                if (initialBalance.gte(randomAmount)) {
                    await expect(
                        token.transfer(addr1.address, randomAmount)
                    ).to.not.be.reverted;
                    
                    // 验证余额变化
                    expect(await token.balanceOf(owner.address))
                        .to.equal(initialBalance.sub(randomAmount));
                }
            }
        });
        
        it("Should maintain invariants under random operations", async function () {
            const { token, owner, addr1, addr2 } = await loadFixture(deployBasicTokenFixture);
            const accounts = [owner, addr1, addr2];
            
            // 执行随机操作序列
            for (let i = 0; i < 20; i++) {
                const operation = Math.floor(Math.random() * 3); // 0: transfer, 1: approve, 2: transferFrom
                const fromIndex = Math.floor(Math.random() * accounts.length);
                const toIndex = Math.floor(Math.random() * accounts.length);
                
                if (fromIndex === toIndex) continue;
                
                const from = accounts[fromIndex];
                const to = accounts[toIndex];
                const amount = ethers.utils.parseEther((Math.random() * 100).toString());
                
                try {
                    switch (operation) {
                        case 0: // transfer
                            if ((await token.balanceOf(from.address)).gte(amount)) {
                                await token.connect(from).transfer(to.address, amount);
                            }
                            break;
                        case 1: // approve
                            await token.connect(from).approve(to.address, amount);
                            break;
                        case 2: // transferFrom
                            const allowance = await token.allowance(from.address, to.address);
                            const balance = await token.balanceOf(from.address);
                            const transferAmount = amount.lt(allowance) && amount.lt(balance) ? amount : 0;
                            if (transferAmount.gt(0)) {
                                await token.connect(to).transferFrom(from.address, accounts[Math.floor(Math.random() * accounts.length)].address, transferAmount);
                            }
                            break;
                    }
                } catch (error) {
                    // 预期的错误，继续测试
                }
                
                // 验证不变量：总供应量保持不变
                expect(await token.totalSupply()).to.equal(ethers.utils.parseEther("1000000"));
            }
        });
    });
    
    // ✅ 事件测试
    describe("Event Testing", function () {
        it("Should emit events with correct parameters", async function () {
            const { token, owner, addr1 } = await loadFixture(deployBasicTokenFixture);
            const transferAmount = ethers.utils.parseEther("100");
            
            const tx = await token.transfer(addr1.address, transferAmount);
            const receipt = await tx.wait();
            
            // 检查事件数量
            expect(receipt.events).to.have.lengthOf(1);
            
            // 检查事件详情
            const event = receipt.events[0];
            expect(event.event).to.equal("Transfer");
            expect(event.args.from).to.equal(owner.address);
            expect(event.args.to).to.equal(addr1.address);
            expect(event.args.value).to.equal(transferAmount);
        });
        
        it("Should emit multiple events in complex operations", async function () {
            const { token, owner, addr1, addr2 } = await loadFixture(deployBasicTokenFixture);
            const approveAmount = ethers.utils.parseEther("200");
            const transferAmount = ethers.utils.parseEther("100");
            
            // 授权
            await expect(token.approve(addr1.address, approveAmount))
                .to.emit(token, "Approval")
                .withArgs(owner.address, addr1.address, approveAmount);
            
            // 代理转账
            await expect(
                token.connect(addr1).transferFrom(owner.address, addr2.address, transferAmount)
            ).to.emit(token, "Transfer")
             .withArgs(owner.address, addr2.address, transferAmount)
             .and.to.emit(token, "Approval")
             .withArgs(owner.address, addr1.address, approveAmount.sub(transferAmount));
        });
    });
    
    // ✅ 错误处理测试
    describe("Error Handling", function () {
        it("Should provide meaningful error messages", async function () {
            const { token, addr1, addr2 } = await loadFixture(deployBasicTokenFixture);
            
            // 测试各种错误情况
            await expect(
                token.connect(addr1).transfer(addr2.address, ethers.utils.parseEther("1"))
            ).to.be.revertedWith("ERC20: transfer amount exceeds balance");
            
            await expect(
                token.transfer(ethers.constants.AddressZero, ethers.utils.parseEther("1"))
            ).to.be.revertedWith("ERC20: transfer to the zero address");
            
            await expect(
                token.connect(addr1).transferFrom(addr2.address, addr1.address, ethers.utils.parseEther("1"))
            ).to.be.revertedWith("ERC20: insufficient allowance");
        });
        
        it("Should handle custom errors properly", async function () {
            // 假设合约使用了自定义错误
            const CustomErrorContract = await ethers.getContractFactory("CustomErrorContract");
            const contract = await CustomErrorContract.deploy();
            
            await expect(
                contract.functionWithCustomError()
            ).to.be.revertedWithCustomError(contract, "CustomError")
             .withArgs("Expected error message");
        });
    });
});
```

### 核心技能掌握
1. **测试框架**：Hardhat、Mocha、Chai测试环境配置
2. **单元测试**：功能测试、边界测试、错误处理测试
3. **高级技术**：时间操作、快照回滚、模糊测试

### 项目记录
- 建立了完整的测试框架和环境
- 实现了全面的单元测试覆盖
- 开发了高级测试技术和工具

---

## 第二周：集成测试与安全测试

### 课堂重点

#### 1. 集成测试框架

```javascript
// test/Integration.test.js
const { expect } = require("chai");
const { ethers } = require("hardhat");
const { loadFixture } = require("@nomicfoundation/hardhat-network-helpers");

/**
 * @title DeFi协议集成测试
 * @dev 测试多个合约之间的交互
 */
describe("DeFi Protocol Integration Tests", function () {
    
    // ✅ 部署完整DeFi生态系统
    async function deployDeFiEcosystemFixture() {
        const [owner, user1, user2, liquidator] = await ethers.getSigners();
        
        // 部署代币
        const Token = await ethers.getContractFactory("ERC20Mock");
        const tokenA = await Token.deploy("Token A", "TKNA", ethers.utils.parseEther("1000000"));
        const tokenB = await Token.deploy("Token B", "TKNB", ethers.utils.parseEther("1000000"));
        
        // 部署AMM
        const AMM = await ethers.getContractFactory("SimpleAMM");
        const amm = await AMM.deploy(tokenA.address, tokenB.address);
        
        // 部署借贷协议
        const LendingProtocol = await ethers.getContractFactory("LendingProtocol");
        const lending = await LendingProtocol.deploy();
        
        // 部署价格预言机模拟
        const PriceOracle = await ethers.getContractFactory("MockPriceOracle");
        const oracle = await PriceOracle.deploy();
        
        // 初始化价格
        await oracle.setPrice(tokenA.address, ethers.utils.parseEther("100")); // $100
        await oracle.setPrice(tokenB.address, ethers.utils.parseEther("50"));  // $50
        
        // 配置借贷协议
        await lending.addAsset(
            tokenA.address,
            ethers.utils.parseEther("0.8"), // 80% 抵押因子
            ethers.utils.parseEther("0.85") // 85% 清算阈值
        );
        
        await lending.addAsset(
            tokenB.address,
            ethers.utils.parseEther("0.7"), // 70% 抵押因子
            ethers.utils.parseEther("0.75") // 75% 清算阈值
        );
        
        // 分发代币给用户
        await tokenA.transfer(user1.address, ethers.utils.parseEther("10000"));
        await tokenB.transfer(user1.address, ethers.utils.parseEther("10000"));
        await tokenA.transfer(user2.address, ethers.utils.parseEther("10000"));
        await tokenB.transfer(user2.address, ethers.utils.parseEther("10000"));
        
        return {
            tokenA, tokenB, amm, lending, oracle,
            owner, user1, user2, liquidator
        };
    }
    
    // ✅ AMM流动性测试
    describe("AMM Liquidity Operations", function () {
        it("Should add liquidity and enable trading", async function () {
            const { tokenA, tokenB, amm, user1 } = await loadFixture(deployDeFiEcosystemFixture);
            
            const amountA = ethers.utils.parseEther("1000");
            const amountB = ethers.utils.parseEther("2000");
            
            // 授权AMM使用代币
            await tokenA.connect(user1).approve(amm.address, amountA);
            await tokenB.connect(user1).approve(amm.address, amountB);
            
            // 添加流动性
            await expect(
                amm.connect(user1).addLiquidity(amountA, amountB)
            ).to.emit(amm, "Mint");
            
            // 验证储备
            expect(await amm.reserveA()).to.equal(amountA);
            expect(await amm.reserveB()).to.equal(amountB);
            
            // 验证LP代币余额
            const lpBalance = await amm.balanceOf(user1.address);
            expect(lpBalance).to.be.above(0);
        });
        
        it("Should execute swaps with correct pricing", async function () {
            const { tokenA, tokenB, amm, user1, user2 } = await loadFixture(deployDeFiEcosystemFixture);
            
            // 用户1添加流动性
            const liquidityA = ethers.utils.parseEther("1000");
            const liquidityB = ethers.utils.parseEther("2000");
            
            await tokenA.connect(user1).approve(amm.address, liquidityA);
            await tokenB.connect(user1).approve(amm.address, liquidityB);
            await amm.connect(user1).addLiquidity(liquidityA, liquidityB);
            
            // 用户2执行交换
            const swapAmountA = ethers.utils.parseEther("100");
            await tokenA.connect(user2).approve(amm.address, swapAmountA);
            
            const expectedAmountB = await amm.getAmountOut(
                swapAmountA,
                await amm.reserveA(),
                await amm.reserveB()
            );
            
            await expect(
                amm.connect(user2).swapAForB(swapAmountA)
            ).to.changeTokenBalances(
                tokenB,
                [user2],
                [expectedAmountB]
            );
        });
    });
    
    // ✅ 借贷协议集成测试
    describe("Lending Protocol Integration", function () {
        it("Should handle complete borrow-repay cycle", async function () {
            const { tokenA, tokenB, lending, oracle, user1 } = await loadFixture(deployDeFiEcosystemFixture);
            
            const supplyAmount = ethers.utils.parseEther("1000");
            const borrowAmount = ethers.utils.parseEther("500");
            
            // 供应抵押品
            await tokenA.connect(user1).approve(lending.address, supplyAmount);
            await lending.connect(user1).supply(tokenA.address, supplyAmount);
            
            // 借贷
            await lending.connect(user1).borrow(tokenB.address, borrowAmount);
            
            // 验证余额变化
            expect(await tokenB.balanceOf(user1.address))
                .to.equal(ethers.utils.parseEther("10000").add(borrowAmount));
            
            // 还款
            await tokenB.connect(user1).approve(lending.address, borrowAmount);
            await lending.connect(user1).repay(tokenB.address, borrowAmount);
            
            // 验证借贷余额清零
            const accountInfo = await lending.getUserAccountInfo(user1.address);
            expect(accountInfo.totalBorrowValue).to.equal(0);
        });
        
        it("Should trigger liquidation when health factor drops", async function () {
            const { tokenA, tokenB, lending, oracle, user1, liquidator } = await loadFixture(deployDeFiEcosystemFixture);
            
            const supplyAmount = ethers.utils.parseEther("1000");
            const borrowAmount = ethers.utils.parseEther("600"); // 接近清算线
            
            // 建立借贷头寸
            await tokenA.connect(user1).approve(lending.address, supplyAmount);
            await lending.connect(user1).supply(tokenA.address, supplyAmount);
            await lending.connect(user1).borrow(tokenB.address, borrowAmount);
            
            // 价格下跌触发清算条件
            await oracle.setPrice(tokenA.address, ethers.utils.parseEther("70")); // 价格下跌30%
            
            // 准备清算
            await tokenB.transfer(liquidator.address, borrowAmount);
            await tokenB.connect(liquidator).approve(lending.address, borrowAmount);
            
            // 执行清算
            await expect(
                lending.connect(liquidator).liquidate(
                    user1.address,
                    tokenB.address,
                    tokenA.address,
                    borrowAmount.div(2) // 清算50%
                )
            ).to.emit(lending, "Liquidation");
        });
    });
    
    // ✅ 跨协议交互测试
    describe("Cross-Protocol Interactions", function () {
        it("Should enable AMM-Lending arbitrage", async function () {
            const { tokenA, tokenB, amm, lending, oracle, user1 } = await loadFixture(deployDeFiEcosystemFixture);
            
            // 在AMM中添加流动性（不同比例）
            const liquidityA = ethers.utils.parseEther("1000");
            const liquidityB = ethers.utils.parseEther("1500"); // 1:1.5 比例
            
            await tokenA.connect(user1).approve(amm.address, liquidityA);
            await tokenB.connect(user1).approve(amm.address, liquidityB);
            await amm.connect(user1).addLiquidity(liquidityA, liquidityB);
            
            // 预言机价格为1:2，存在套利机会
            const ammPrice = liquidityB.mul(ethers.utils.parseEther("1")).div(liquidityA);
            const oraclePrice = ethers.utils.parseEther("50").mul(ethers.utils.parseEther("1")).div(ethers.utils.parseEther("100"));
            
            console.log(`AMM Price: ${ethers.utils.formatEther(ammPrice)}`);
            console.log(`Oracle Price: ${ethers.utils.formatEther(oraclePrice)}`);
            
            // 执行套利策略
            const arbitrageAmount = ethers.utils.parseEther("100");
            
            // 1. 从借贷协议借入tokenA
            await tokenB.connect(user1).approve(lending.address, ethers.utils.parseEther("200"));
            await lending.connect(user1).supply(tokenB.address, ethers.utils.parseEther("200"));
            await lending.connect(user1).borrow(tokenA.address, arbitrageAmount);
            
            // 2. 在AMM中交换tokenA为tokenB
            await tokenA.connect(user1).approve(amm.address, arbitrageAmount);
            const receivedB = await amm.connect(user1).callStatic.swapAForB(arbitrageAmount);
            await amm.connect(user1).swapAForB(arbitrageAmount);
            
            // 3. 计算套利利润
            const expectedCost = arbitrageAmount.mul(ethers.utils.parseEther("50")).div(ethers.utils.parseEther("100"));
            const profit = receivedB.sub(expectedCost);
            
            console.log(`Arbitrage profit: ${ethers.utils.formatEther(profit)}`);
            expect(profit).to.be.above(0);
        });
    });
    
    // ✅ 系统压力测试
    describe("System Stress Tests", function () {
        it("Should handle high-frequency trading", async function () {
            const { tokenA, tokenB, amm, user1, user2 } = await loadFixture(deployDeFiEcosystemFixture);
            
            // 添加大量流动性
            const liquidityA = ethers.utils.parseEther("10000");
            const liquidityB = ethers.utils.parseEther("20000");
            
            await tokenA.connect(user1).approve(amm.address, liquidityA);
            await tokenB.connect(user1).approve(amm.address, liquidityB);
            await amm.connect(user1).addLiquidity(liquidityA, liquidityB);
            
            // 执行大量小额交易
            const tradeAmount = ethers.utils.parseEther("10");
            await tokenA.connect(user2).approve(amm.address, tradeAmount.mul(50));
            await tokenB.connect(user2).approve(amm.address, tradeAmount.mul(50));
            
            let totalGasUsed = ethers.BigNumber.from(0);
            
            for (let i = 0; i < 10; i++) {
                // 交替交换方向
                if (i % 2 === 0) {
                    const tx = await amm.connect(user2).swapAForB(tradeAmount);
                    const receipt = await tx.wait();
                    totalGasUsed = totalGasUsed.add(receipt.gasUsed);
                } else {
                    const tx = await amm.connect(user2).swapBForA(tradeAmount);
                    const receipt = await tx.wait();
                    totalGasUsed = totalGasUsed.add(receipt.gasUsed);
                }
            }
            
            console.log(`Total gas for 10 trades: ${totalGasUsed.toString()}`);
            console.log(`Average gas per trade: ${totalGasUsed.div(10).toString()}`);
            
            // 验证系统仍然正常运行
            expect(await amm.reserveA()).to.be.above(0);
            expect(await amm.reserveB()).to.be.above(0);
        });
        
        it("Should maintain system invariants under stress", async function () {
            const { tokenA, tokenB, amm, lending, user1, user2 } = await loadFixture(deployDeFiEcosystemFixture);
            
            // 记录初始状态
            const initialTotalSupplyA = await tokenA.totalSupply();
            const initialTotalSupplyB = await tokenB.totalSupply();
            
            // 执行复杂操作序列
            const operations = [
                async () => {
                    await tokenA.connect(user1).approve(amm.address, ethers.utils.parseEther("100"));
                    await tokenB.connect(user1).approve(amm.address, ethers.utils.parseEther("200"));
                    await amm.connect(user1).addLiquidity(ethers.utils.parseEther("100"), ethers.utils.parseEther("200"));
                },
                async () => {
                    await tokenA.connect(user2).approve(amm.address, ethers.utils.parseEther("50"));
                    await amm.connect(user2).swapAForB(ethers.utils.parseEther("50"));
                },
                async () => {
                    await tokenA.connect(user1).approve(lending.address, ethers.utils.parseEther("500"));
                    await lending.connect(user1).supply(tokenA.address, ethers.utils.parseEther("500"));
                },
                async () => {
                    await lending.connect(user1).borrow(tokenB.address, ethers.utils.parseEther("200"));
                }
            ];
            
            // 随机执行操作
            for (let i = 0; i < 20; i++) {
                const opIndex = Math.floor(Math.random() * operations.length);
                try {
                    await operations[opIndex]();
                } catch (error) {
                    // 预期的错误，继续测试
                }
                
                // 验证不变量
                expect(await tokenA.totalSupply()).to.equal(initialTotalSupplyA);
                expect(await tokenB.totalSupply()).to.equal(initialTotalSupplyB);
            }
        });
    });
});
```

#### 2. 安全测试套件

```javascript
// test/Security.test.js
const { expect } = require("chai");
const { ethers } = require("hardhat");
const { loadFixture } = require("@nomicfoundation/hardhat-network-helpers");

/**
 * @title 安全测试套件
 * @dev 测试常见的智能合约安全漏洞
 */
describe("Security Tests", function () {
    
    // ✅ 重入攻击测试
    describe("Reentrancy Attack Tests", function () {
        async function deployVulnerableContractFixture() {
            const [owner, attacker] = await ethers.getSigners();
            
            const VulnerableBank = await ethers.getContractFactory("VulnerableBank");
            const bank = await VulnerableBank.deploy();
            
            const ReentrancyAttacker = await ethers.getContractFactory("ReentrancyAttacker");
            const attackerContract = await ReentrancyAttacker.deploy(bank.address);
            
            return { bank, attackerContract, owner, attacker };
        }
        
        it("Should prevent reentrancy attacks", async function () {
            const { bank, attackerContract, owner, attacker } = await loadFixture(deployVulnerableContractFixture);
            
            // 向银行存入资金
            await bank.connect(owner).deposit({ value: ethers.utils.parseEther("10") });
            
            // 攻击者存入少量资金
            await bank.connect(attacker).deposit({ value: ethers.utils.parseEther("1") });
            
            // 尝试重入攻击
            await expect(
                attackerContract.connect(attacker).attack({ value: ethers.utils.parseEther("1") })
            ).to.be.revertedWith("ReentrancyGuard: reentrant call");
        });
        
        it("Should detect reentrancy in complex scenarios", async function () {
            const { bank, attackerContract, owner, attacker } = await loadFixture(deployVulnerableContractFixture);
            
            // 设置复杂的攻击场景
            await bank.connect(owner).deposit({ value: ethers.utils.parseEther("100") });
            await bank.connect(attacker).deposit({ value: ethers.utils.parseEther("10") });
            
            // 尝试多层重入攻击
            await expect(
                attackerContract.connect(attacker).complexAttack({ value: ethers.utils.parseEther("5") })
            ).to.be.revertedWith("ReentrancyGuard: reentrant call");
        });
    });
    
    // ✅ 整数溢出测试
    describe("Integer Overflow Tests", function () {
        async function deployOverflowTestFixture() {
            const [owner, user] = await ethers.getSigners();
            
            const OverflowTest = await ethers.getContractFactory("OverflowTest");
            const contract = await OverflowTest.deploy();
            
            return { contract, owner, user };
        }
        
        it("Should prevent integer overflow", async function () {
            const { contract, user } = await loadFixture(deployOverflowTestFixture);
            
            const maxUint256 = ethers.constants.MaxUint256;
            
            // 尝试溢出
            await expect(
                contract.connect(user).add(maxUint256, 1)
            ).to.be.revertedWith("SafeMath: addition overflow");
        });
        
        it("Should prevent integer underflow", async function () {
            const { contract, user } = await loadFixture(deployOverflowTestFixture);
            
            // 尝试下溢
            await expect(
                contract.connect(user).subtract(0, 1)
            ).to.be.revertedWith("SafeMath: subtraction overflow");
        });
        
        it("Should handle edge cases correctly", async function () {
            const { contract, user } = await loadFixture(deployOverflowTestFixture);
            
            // 测试边界值
            const result = await contract.connect(user).add(ethers.constants.MaxUint256.sub(1), 1);
            expect(result).to.equal(ethers.constants.MaxUint256);
        });
    });
    
    // ✅ 访问控制测试
    describe("Access Control Tests", function () {
        async function deployAccessControlFixture() {
            const [owner, admin, user, unauthorized] = await ethers.getSigners();
            
            const AccessControlTest = await ethers.getContractFactory("AccessControlTest");
            const contract = await AccessControlTest.deploy();
            
            // 设置角色
            const ADMIN_ROLE = await contract.ADMIN_ROLE();
            await contract.grantRole(ADMIN_ROLE, admin.address);
            
            return { contract, owner, admin, user, unauthorized, ADMIN_ROLE };
        }
        
        it("Should enforce role-based access control", async function () {
            const { contract, admin, unauthorized } = await loadFixture(deployAccessControlFixture);
            
            // 管理员可以执行特权操作
            await expect(
                contract.connect(admin).adminFunction()
            ).to.not.be.reverted;
            
            // 未授权用户不能执行特权操作
            await expect(
                contract.connect(unauthorized).adminFunction()
            ).to.be.revertedWith("AccessControl: account");
        });
        
        it("Should handle role revocation correctly", async function () {
            const { contract, owner, admin, ADMIN_ROLE } = await loadFixture(deployAccessControlFixture);
            
            // 撤销角色
            await contract.connect(owner).revokeRole(ADMIN_ROLE, admin.address);
            
            // 被撤销角色的用户不能再执行特权操作
            await expect(
                contract.connect(admin).adminFunction()
            ).to.be.revertedWith("AccessControl: account");
        });
        
        it("Should prevent privilege escalation", async function () {
            const { contract, user, unauthorized } = await loadFixture(deployAccessControlFixture);
            
            // 普通用户不能授予自己管理员权限
            const ADMIN_ROLE = await contract.ADMIN_ROLE();
            
            await expect(
                contract.connect(user).grantRole(ADMIN_ROLE, user.address)
            ).to.be.revertedWith("AccessControl: account");
            
            await expect(
                contract.connect(unauthorized).grantRole(ADMIN_ROLE, unauthorized.address)
            ).to.be.revertedWith("AccessControl: account");
        });
    });
    
    // ✅ 前端运行攻击测试
    describe("Front-running Attack Tests", function () {
        async function deployFrontRunningTestFixture() {
            const [owner, victim, attacker] = await ethers.getSigners();
            
            const FrontRunningTest = await ethers.getContractFactory("FrontRunningTest");
            const contract = await FrontRunningTest.deploy();
            
            return { contract, owner, victim, attacker };
        }
        
        it("Should prevent front-running with commit-reveal", async function () {
            const { contract, victim, attacker } = await loadFixture(deployFrontRunningTestFixture);
            
            const secretValue = 42;
            const nonce = 123;
            const commitment = ethers.utils.keccak256(
                ethers.utils.defaultAbiCoder.encode(
                    ["uint256", "uint256", "address"],
                    [secretValue, nonce, victim.address]
                )
            );
            
            // 提交阶段
            await contract.connect(victim).commit(commitment);
            
            // 攻击者尝试复制提交
            await expect(
                contract.connect(attacker).commit(commitment)
            ).to.be.revertedWith("Commitment already exists");
            
            // 揭示阶段
            await contract.connect(victim).reveal(secretValue, nonce);
            
            expect(await contract.winner()).to.equal(victim.address);
        });
    });
    
    // ✅ 闪电贷攻击测试
    describe("Flash Loan Attack Tests", function () {
        async function deployFlashLoanTestFixture() {
            const [owner, attacker] = await ethers.getSigners();
            
            const FlashLoanProvider = await ethers.getContractFactory("FlashLoanProvider");
            const provider = await FlashLoanProvider.deploy();
            
            const VulnerableProtocol = await ethers.getContractFactory("VulnerableProtocol");
            const protocol = await VulnerableProtocol.deploy();
            
            const FlashLoanAttacker = await ethers.getContractFactory("FlashLoanAttacker");
            const attackerContract = await FlashLoanAttacker.deploy(provider.address, protocol.address);
            
            return { provider, protocol, attackerContract, owner, attacker };
        }
        
        it("Should detect and prevent flash loan attacks", async function () {
            const { provider, protocol, attackerContract, owner, attacker } = await loadFixture(deployFlashLoanTestFixture);
            
            // 向协议添加流动性
            await protocol.connect(owner).addLiquidity({ value: ethers.utils.parseEther("100") });
            
            // 尝试闪电贷攻击
            await expect(
                attackerContract.connect(attacker).executeAttack(ethers.utils.parseEther("50"))
            ).to.be.revertedWith("Flash loan attack detected");
        });
    });
    
    // ✅ 价格操纵测试
    describe("Price Manipulation Tests", function () {
        async function deployPriceManipulationTestFixture() {
            const [owner, manipulator] = await ethers.getSigners();
            
            const Token = await ethers.getContractFactory("ERC20Mock");
            const tokenA = await Token.deploy("Token A", "TKNA", ethers.utils.parseEther("1000000"));
            const tokenB = await Token.deploy("Token B", "TKNB", ethers.utils.parseEther("1000000"));
            
            const VulnerableAMM = await ethers.getContractFactory("VulnerableAMM");
            const amm = await VulnerableAMM.deploy(tokenA.address, tokenB.address);
            
            const PriceOracle = await ethers.getContractFactory("AMMPriceOracle");
            const oracle = await PriceOracle.deploy(amm.address);
            
            return { tokenA, tokenB, amm, oracle, owner, manipulator };
        }
        
        it("Should resist price manipulation attacks", async function () {
            const { tokenA, tokenB, amm, oracle, owner, manipulator } = await loadFixture(deployPriceManipulationTestFixture);
            
            // 建立初始流动性
            const liquidityA = ethers.utils.parseEther("10000");
            const liquidityB = ethers.utils.parseEther("10000");
            
            await tokenA.connect(owner).approve(amm.address, liquidityA);
            await tokenB.connect(owner).approve(amm.address, liquidityB);
            await amm.connect(owner).addLiquidity(liquidityA, liquidityB);
            
            // 记录初始价格
            const initialPrice = await oracle.getPrice();
            
            // 分发代币给操纵者
            await tokenA.transfer(manipulator.address, ethers.utils.parseEther("5000"));
            
            // 尝试价格操纵
            await tokenA.connect(manipulator).approve(amm.address, ethers.utils.parseEther("5000"));
            await amm.connect(manipulator).swapAForB(ethers.utils.parseEther("5000"));
            
            // 检查价格变化是否在合理范围内
            const manipulatedPrice = await oracle.getPrice();
            const priceChange = manipulatedPrice.sub(initialPrice).abs();
            const maxAllowedChange = initialPrice.div(10); // 10%
            
            // 如果使用TWAP或其他抗操纵机制，价格变化应该有限
            expect(priceChange).to.be.below(maxAllowedChange);
        });
    });
    
    // ✅ 拒绝服务攻击测试
    describe("Denial of Service Tests", function () {
        async function deployDoSTestFixture() {
            const [owner, attacker] = await ethers.getSigners();
            
            const DoSVulnerable = await ethers.getContractFactory("DoSVulnerable");
            const contract = await DoSVulnerable.deploy();
            
            return { contract, owner, attacker };
        }
        
        it("Should prevent gas limit DoS attacks", async function () {
            const { contract, owner, attacker } = await loadFixture(deployDoSTestFixture);
            
            // 添加大量参与者
            const participants = [];
            for (let i = 0; i < 100; i++) {
                const wallet = ethers.Wallet.createRandom().connect(ethers.provider);
                await owner.sendTransaction({
                    to: wallet.address,
                    value: ethers.utils.parseEther("0.1")
                });
                participants.push(wallet);
            }
            
            // 所有参与者加入
            for (const participant of participants) {
                await contract.connect(participant).join({ value: ethers.utils.parseEther("0.01") });
            }
            
            // 尝试分发奖励（可能因gas限制失败）
            await expect(
                contract.connect(owner).distributeRewards()
            ).to.not.be.reverted; // 应该有gas限制保护
        });
        
        it("Should handle unexpected reverts gracefully", async function () {
            const { contract, owner, attacker } = await loadFixture(deployDoSTestFixture);
            
            const MaliciousReceiver = await ethers.getContractFactory("MaliciousReceiver");
            const maliciousContract = await MaliciousReceiver.deploy();
            
            // 恶意合约加入
            await contract.connect(attacker).joinWithContract(maliciousContract.address, { value: ethers.utils.parseEther("0.01") });
            
            // 尝试分发奖励，恶意合约会拒绝接收
            await expect(
                contract.connect(owner).distributeRewards()
            ).to.not.be.reverted; // 应该有错误处理机制
        });
    });
});
```

### 核心技能掌握
1. **集成测试**：多合约交互、系统级测试、压力测试
2. **安全测试**：重入攻击、整数溢出、访问控制、价格操纵
3. **攻击模拟**：闪电贷攻击、前端运行、拒绝服务攻击

### 项目记录
- 建立了完整的集成测试框架
- 实现了全面的安全测试套件
- 开发了攻击模拟和防护验证

---

## 第三周：自动化测试与CI/CD

### 课堂重点

#### 1. 自动化测试流水线

```yaml
# .github/workflows/test.yml
name: Smart Contract Tests

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    
    strategy:
      matrix:
        node-version: [16.x, 18.x]
        
    steps:
    - uses: actions/checkout@v3
    
    - name: Use Node.js ${{ matrix.node-version }}
      uses: actions/setup-node@v3
      with:
        node-version: ${{ matrix.node-version }}
        cache: 'npm'
        
    - name: Install dependencies
      run: npm ci
      
    - name: Compile contracts
      run: npx hardhat compile
      
    - name: Run unit tests
      run: npx hardhat test
      
    - name: Run coverage
      run: npx hardhat coverage
      
    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v3
      with:
        file: ./coverage/lcov.info
        
    - name: Run gas reporter
      run: npx hardhat test --reporter gas-reporter
      
    - name: Run security analysis
      run: |
        npm install -g @crytic/slither-analyzer
        slither .
        
    - name: Run formal verification
      run: |
        npm install -g @certora/cli
        certoraRun contracts/MyContract.sol --verify MyContract.spec
        
  integration-test:
    runs-on: ubuntu-latest
    needs: test
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Use Node.js 18.x
      uses: actions/setup-node@v3
      with:
        node-version: 18.x
        cache: 'npm'
        
    - name: Install dependencies
      run: npm ci
      
    - name: Start local blockchain
      run: |
        npx hardhat node &
        sleep 10
        
    - name: Deploy contracts
      run: npx hardhat run scripts/deploy.js --network localhost
      
    - name: Run integration tests
      run: npx hardhat test test/integration/ --network localhost
      
    - name: Performance benchmarks
      run: npx hardhat test test/performance/ --network localhost
      
  security-audit:
    runs-on: ubuntu-latest
    needs: test
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Install security tools
      run: |
        pip install slither-analyzer
        npm install -g mythril
        
    - name: Run Slither analysis
      run: slither . --json slither-report.json
      
    - name: Run Mythril analysis
      run: myth analyze contracts/ --output-dir mythril-report
      
    - name: Upload security reports
      uses: actions/upload-artifact@v3
      with:
        name: security-reports
        path: |
          slither-report.json
          mythril-report/
```

#### 2. 测试覆盖率分析

```javascript
// hardhat.config.js - 覆盖率配置
require("@nomicfoundation/hardhat-toolbox");
require("solidity-coverage");
require("hardhat-gas-reporter");

/**
 * @title Hardhat配置 - 测试覆盖率
 * @dev 配置测试覆盖率和gas报告
 */
module.exports = {
  solidity: {
    version: "0.8.19",
    settings: {
      optimizer: {
        enabled: true,
        runs: 200
      }
    }
  },
  
  // ✅ 覆盖率配置
  solcover: {
    measureStatements: true,
    measureFunctions: true,
    measureBranches: true,
    measureLines: true,
    skipFiles: [
      'contracts/mocks/',
      'contracts/test/',
      'contracts/interfaces/'
    ],
    configureYulOptimizer: true,
    solcOptimizerDetails: {
      enabled: true,
      runs: 200,
    }
  },
  
  // ✅ Gas报告配置
  gasReporter: {
    enabled: process.env.REPORT_GAS !== undefined,
    currency: 'USD',
    gasPrice: 20,
    coinmarketcap: process.env.COINMARKETCAP_API_KEY,
    outputFile: 'gas-report.txt',
    noColors: true,
    excludeContracts: ['mocks/', 'test/']
  },
  
  networks: {
    hardhat: {
      allowUnlimitedContractSize: true
    },
    localhost: {
      url: "http://127.0.0.1:8545"
    }
  }
};
```

```javascript
// test/Coverage.test.js
const { expect } = require("chai");
const { ethers } = require("hardhat");

/**
 * @title 覆盖率测试套件
 * @dev 确保所有代码路径都被测试覆盖
 */
describe("Coverage Tests", function () {
    
    // ✅ 分支覆盖测试
    describe("Branch Coverage", function () {
        async function deployTestContractFixture() {
            const [owner, user1, user2] = await ethers.getSigners();
            
            const TestContract = await ethers.getContractFactory("BranchTestContract");
            const contract = await TestContract.deploy();
            
            return { contract, owner, user1, user2 };
        }
        
        it("Should cover all conditional branches", async function () {
            const { contract, user1 } = await loadFixture(deployTestContractFixture);
            
            // 测试所有if-else分支
            await contract.connect(user1).conditionalFunction(true);
            await contract.connect(user1).conditionalFunction(false);
            
            // 测试所有switch-case分支
            for (let i = 0; i < 5; i++) {
                await contract.connect(user1).switchFunction(i);
            }
            
            // 测试循环的不同迭代次数
            await contract.connect(user1).loopFunction(0); // 零次迭代
            await contract.connect(user1).loopFunction(1); // 一次迭代
            await contract.connect(user1).loopFunction(10); // 多次迭代
        });
        
        it("Should cover error handling branches", async function () {
            const { contract, user1 } = await loadFixture(deployTestContractFixture);
            
            // 测试正常执行路径
            await expect(
                contract.connect(user1).riskyFunction(100)
            ).to.not.be.reverted;
            
            // 测试错误处理路径
            await expect(
                contract.connect(user1).riskyFunction(0)
            ).to.be.revertedWith("Invalid input");
            
            await expect(
                contract.connect(user1).riskyFunction(1001)
            ).to.be.revertedWith("Value too large");
        });
    });
    
    // ✅ 函数覆盖测试
    describe("Function Coverage", function () {
        it("Should call all public functions", async function () {
            const { contract, owner, user1 } = await loadFixture(deployTestContractFixture);
            
            // 获取合约的所有函数
            const contractInterface = contract.interface;
            const functions = Object.keys(contractInterface.functions);
            
            // 测试所有可调用的函数
            for (const funcName of functions) {
                if (funcName.includes('(')) {
                    const func = contractInterface.functions[funcName];
                    
                    try {
                        // 根据函数签名调用相应函数
                        if (funcName.startsWith('owner')) {
                            await contract.connect(owner)[func.name]();
                        } else if (func.inputs.length === 0) {
                            await contract.connect(user1)[func.name]();
                        } else {
                            // 为有参数的函数提供默认值
                            const args = func.inputs.map(input => {
                                switch (input.type) {
                                    case 'uint256': return 100;
                                    case 'address': return user1.address;
                                    case 'bool': return true;
                                    case 'string': return 'test';
                                    default: return 0;
                                }
                            });
                            await contract.connect(user1)[func.name](...args);
                        }
                    } catch (error) {
                        // 预期的错误，记录但继续测试
                        console.log(`Function ${funcName} reverted: ${error.message}`);
                    }
                }
            }
        });
    });
    
    // ✅ 语句覆盖测试
    describe("Statement Coverage", function () {
        it("Should execute all statements", async function () {
            const { contract, owner, user1, user2 } = await loadFixture(deployTestContractFixture);
            
            // 执行复杂的操作序列以覆盖所有语句
            await contract.connect(owner).initialize();
            await contract.connect(user1).register("User1");
            await contract.connect(user2).register("User2");
            
            await contract.connect(user1).deposit({ value: ethers.utils.parseEther("1") });
            await contract.connect(user2).deposit({ value: ethers.utils.parseEther("2") });
            
            await contract.connect(user1).transfer(user2.address, ethers.utils.parseEther("0.5"));
            
            await contract.connect(owner).updateSettings(true, 100);
            await contract.connect(owner).pause();
            await contract.connect(owner).unpause();
            
            await contract.connect(user1).withdraw(ethers.utils.parseEther("0.3"));
            
            // 触发紧急情况
            await contract.connect(owner).emergencyStop();
            await contract.connect(owner).emergencyWithdraw();
        });
    });
});
```

#### 3. 性能测试框架

```javascript
// test/Performance.test.js
const { expect } = require("chai");
const { ethers } = require("hardhat");
const { time, loadFixture } = require("@nomicfoundation/hardhat-network-helpers");

/**
 * @title 性能测试套件
 * @dev 测试合约的性能和gas消耗
 */
describe("Performance Tests", function () {
    
    // ✅ Gas消耗基准测试
    describe("Gas Consumption Benchmarks", function () {
        async function deployPerformanceTestFixture() {
            const [owner, ...users] = await ethers.getSigners();
            
            const PerformanceTest = await ethers.getContractFactory("PerformanceTestContract");
            const contract = await PerformanceTest.deploy();
            
            return { contract, owner, users };
        }
        
        it("Should measure gas consumption for basic operations", async function () {
            const { contract, users } = await loadFixture(deployPerformanceTestFixture);
            
            const operations = [
                { name: "Simple Transfer", func: () => contract.connect(users[0]).simpleTransfer(users[1].address, 100) },
                { name: "Complex Calculation", func: () => contract.connect(users[0]).complexCalculation(1000) },
                { name: "Storage Write", func: () => contract.connect(users[0]).writeStorage("key", "value") },
                { name: "Storage Read", func: () => contract.connect(users[0]).readStorage("key") },
                { name: "Event Emission", func: () => contract.connect(users[0]).emitEvent("test", 123) }
            ];
            
            const gasResults = [];
            
            for (const operation of operations) {
                const tx = await operation.func();
                const receipt = await tx.wait();
                
                gasResults.push({
                    operation: operation.name,
                    gasUsed: receipt.gasUsed.toString(),
                    gasPrice: tx.gasPrice?.toString() || "0",
                    cost: receipt.gasUsed.mul(tx.gasPrice || 0).toString()
                });
                
                console.log(`${operation.name}: ${receipt.gasUsed.toString()} gas`);
            }
            
            // 验证gas消耗在预期范围内
            expect(gasResults[0].gasUsed).to.be.below("50000"); // Simple Transfer
            expect(gasResults[1].gasUsed).to.be.below("100000"); // Complex Calculation
        });
        
        it("Should measure gas scaling with data size", async function () {
            const { contract, users } = await loadFixture(deployPerformanceTestFixture);
            
            const dataSizes = [10, 50, 100, 500, 1000];
            const gasResults = [];
            
            for (const size of dataSizes) {
                const data = Array(size).fill(0).map((_, i) => i);
                
                const tx = await contract.connect(users[0]).processArray(data);
                const receipt = await tx.wait();
                
                gasResults.push({
                    dataSize: size,
                    gasUsed: receipt.gasUsed.toNumber()
                });
                
                console.log(`Array size ${size}: ${receipt.gasUsed.toString()} gas`);
            }
            
            // 验证gas消耗的线性增长
            for (let i = 1; i < gasResults.length; i++) {
                const prevResult = gasResults[i - 1];
                const currentResult = gasResults[i];
                
                const sizeRatio = currentResult.dataSize / prevResult.dataSize;
                const gasRatio = currentResult.gasUsed / prevResult.gasUsed;
                
                // Gas增长应该大致与数据大小成正比
                expect(gasRatio).to.be.closeTo(sizeRatio, sizeRatio * 0.2);
            }
        });
    });
    
    // ✅ 吞吐量测试
    describe("Throughput Tests", function () {
        it("Should handle high transaction volume", async function () {
            const { contract, users } = await loadFixture(deployPerformanceTestFixture);
            
            const transactionCount = 100;
            const startTime = Date.now();
            
            // 并发发送大量交易
            const promises = [];
            for (let i = 0; i < transactionCount; i++) {
                const userIndex = i % users.length;
                promises.push(
                    contract.connect(users[userIndex]).quickOperation(i)
                );
            }
            
            await Promise.all(promises);
            
            const endTime = Date.now();
            const duration = endTime - startTime;
            const tps = (transactionCount / duration) * 1000;
            
            console.log(`Processed ${transactionCount} transactions in ${duration}ms`);
            console.log(`Throughput: ${tps.toFixed(2)} TPS`);
            
            // 验证吞吐量满足要求
            expect(tps).to.be.above(10); // 至少10 TPS
        });
    });
    
    // ✅ 内存使用测试
    describe("Memory Usage Tests", function () {
        it("Should optimize storage usage", async function () {
            const { contract, users } = await loadFixture(deployPerformanceTestFixture);
            
            // 测试不同的存储模式
            const storageTests = [
                { name: "Packed Struct", func: () => contract.connect(users[0]).storePackedData(1, 2, true) },
                { name: "Separate Variables", func: () => contract.connect(users[0]).storeSeparateData(1, 2, true) },
                { name: "Array Storage", func: () => contract.connect(users[0]).storeArrayData([1, 2, 3, 4, 5]) },
                { name: "Mapping Storage", func: () => contract.connect(users[0]).storeMappingData("key1", 100) }
            ];
            
            for (const test of storageTests) {
                const tx = await test.func();
                const receipt = await tx.wait();
                
                console.log(`${test.name}: ${receipt.gasUsed.toString()} gas`);
            }
        });
    });
    
    // ✅ 负载测试
    describe("Load Tests", function () {
        it("Should maintain performance under load", async function () {
            const { contract, users } = await loadFixture(deployPerformanceTestFixture);
            
            const loadLevels = [10, 50, 100];
            const performanceResults = [];
            
            for (const loadLevel of loadLevels) {
                const startTime = Date.now();
                
                // 模拟负载
                const promises = [];
                for (let i = 0; i < loadLevel; i++) {
                    const userIndex = i % users.length;
                    promises.push(
                        contract.connect(users[userIndex]).loadTestOperation(i)
                    );
                }
                
                const results = await Promise.all(promises);
                const receipts = await Promise.all(results.map(tx => tx.wait()));
                
                const endTime = Date.now();
                const duration = endTime - startTime;
                const avgGas = receipts.reduce((sum, receipt) => sum + receipt.gasUsed.toNumber(), 0) / receipts.length;
                
                performanceResults.push({
                    loadLevel,
                    duration,
                    avgGas,
                    tps: (loadLevel / duration) * 1000
                });
                
                console.log(`Load ${loadLevel}: ${duration}ms, Avg Gas: ${avgGas.toFixed(0)}, TPS: ${((loadLevel / duration) * 1000).toFixed(2)}`);
            }
            
            // 验证性能不会显著下降
            for (let i = 1; i < performanceResults.length; i++) {
                const prevResult = performanceResults[i - 1];
                const currentResult = performanceResults[i];
                
                // TPS下降不应超过50%
                expect(currentResult.tps).to.be.above(prevResult.tps * 0.5);
            }
        });
    });
});
```

### 核心技能掌握
1. **自动化流水线**：CI/CD配置、自动化测试、安全扫描
2. **覆盖率分析**：语句覆盖、分支覆盖、函数覆盖
3. **性能测试**：Gas基准测试、吞吐量测试、负载测试

### 项目记录
- 建立了完整的CI/CD流水线
- 实现了全面的测试覆盖率分析
- 开发了性能测试和基准测试框架

---

## 学习心得与总结

### 核心技术掌握

1. **测试框架精通**
   - 熟练使用Hardhat、Mocha、Chai测试环境
   - 掌握测试夹具、快照、时间操作等高级技术
   - 建立了完整的测试开发工作流

2. **全面测试覆盖**
   - 单元测试：功能测试、边界测试、错误处理
   - 集成测试：多合约交互、系统级验证
   - 安全测试：漏洞检测、攻击模拟、防护验证

3. **自动化与CI/CD**
   - 构建了完整的自动化测试流水线
   - 实现了测试覆盖率分析和报告
   - 集成了安全扫描和性能基准测试

### 技术创新点

1. **智能测试生成**：开发了基于合约ABI的自动化测试用例生成
2. **模糊测试框架**：实现了属性驱动的随机测试技术
3. **性能基准体系**：建立了全面的Gas消耗和性能评估标准

### 实践项目成果

1. **测试框架库**：开发了可复用的智能合约测试工具库
2. **CI/CD模板**：创建了标准化的区块链项目CI/CD模板
3. **安全测试套件**：构建了全面的智能合约安全测试工具集

### 未来发展方向

1. **形式化验证**：深入学习Certora、TLA+等形式化验证工具
2. **测试自动化**：研究AI驱动的智能测试用例生成技术
3. **性能优化**：探索更高效的测试执行和并行化技术

### 技术栈总结

**测试框架**：Hardhat、Mocha、Chai、Jest  
**覆盖率工具**：Solidity-coverage、Istanbul  
**安全工具**：Slither、Mythril、Echidna  
**CI/CD平台**：GitHub Actions、GitLab CI  
**性能工具**：Hardhat Gas Reporter、Benchmark.js  
**形式化验证**：Certora、Dafny、TLA+  

---

**文档更新时间**：2024年1月15日  
**版本**：v1.0  
**下次更新计划**：添加更多高级测试技术和工具使用案例