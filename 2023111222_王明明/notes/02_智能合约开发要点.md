# Êô∫ËÉΩÂêàÁ∫¶ÂºÄÂèëË¶ÅÁÇπ

> **Â≠¶‰π†ËÄÖ**: ÁéãÊòéÊòé  
> **Â≠¶‰π†ÁâπËâ≤**: Ê≥®ÈáçÂõ¢ÈòüÂçè‰ΩúÂíå‰ª£Á†ÅËßÑËåÉ  
> **‰ª£Á†ÅÈ£éÊ†º**: ËßÑËåÉÂåñÂºÄÂèëÔºåÂõ¢ÈòüÂçè‰ΩúÂ∑•ÂÖ∑  
> **Á¨îËÆ∞ÈáçÁÇπ**: ‰ª£Á†ÅËßÑËåÉ„ÄÅÂõ¢ÈòüÂçè‰Ωú„ÄÅÈ°πÁõÆÁÆ°ÁêÜ  
> **È°πÁõÆ‰ª£Á†Å**: CollaborationTools.sol  
> **ÂàõÂª∫Êó∂Èó¥**: 2024Âπ¥

---

## ü§ù Âõ¢ÈòüÂçè‰ΩúÂºÄÂèëÊ°ÜÊû∂

### Â§öÁ≠æÈí±ÂåÖÁ≥ªÁªü

Âõ¢ÈòüÂçè‰ΩúÁöÑÊ†∏ÂøÉÊòØÂª∫Á´ãÂèØ‰ø°ÁöÑÂ§öÁ≠æÊú∫Âà∂ÔºåÁ°Æ‰øùÈáçË¶ÅÂÜ≥Á≠ñÈúÄË¶ÅÂ§öÊñπÁ°ÆËÆ§„ÄÇ

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

// Â§öÁ≠æÈí±ÂåÖÂêàÁ∫¶
contract MultiSigWallet {
    struct Transaction {
        address to;
        uint256 value;
        bytes data;
        bool executed;
        uint256 confirmations;
        uint256 timestamp;
        string description;
    }
    
    struct Proposal {
        uint256 id;
        address proposer;
        string title;
        string description;
        uint256 votesFor;
        uint256 votesAgainst;
        uint256 deadline;
        bool executed;
        mapping(address => bool) hasVoted;
        mapping(address => bool) voteChoice; // true for yes, false for no
    }
    
    address[] public owners;
    mapping(address => bool) public isOwner;
    mapping(uint256 => mapping(address => bool)) public confirmations;
    
    Transaction[] public transactions;
    mapping(uint256 => Proposal) public proposals;
    
    uint256 public required; // ÈúÄË¶ÅÁöÑÁ°ÆËÆ§Êï∞Èáè
    uint256 public proposalCount;
    
    // ÊùÉÈôêÁ≠âÁ∫ß
    enum Permission { VIEWER, CONTRIBUTOR, ADMIN, OWNER }
    mapping(address => Permission) public permissions;
    
    event OwnerAdded(address indexed owner);
    event OwnerRemoved(address indexed owner);
    event RequirementChanged(uint256 required);
    event TransactionSubmitted(uint256 indexed transactionId, address indexed submitter);
    event TransactionConfirmed(uint256 indexed transactionId, address indexed owner);
    event TransactionExecuted(uint256 indexed transactionId);
    event ProposalCreated(uint256 indexed proposalId, address indexed proposer, string title);
    event ProposalVoted(uint256 indexed proposalId, address indexed voter, bool choice);
    event ProposalExecuted(uint256 indexed proposalId);
    
    modifier onlyOwner() {
        require(isOwner[msg.sender], "Not an owner");
        _;
    }
    
    modifier onlyAdmin() {
        require(permissions[msg.sender] >= Permission.ADMIN, "Admin access required");
        _;
    }
    
    modifier transactionExists(uint256 transactionId) {
        require(transactionId < transactions.length, "Transaction does not exist");
        _;
    }
    
    modifier notExecuted(uint256 transactionId) {
        require(!transactions[transactionId].executed, "Transaction already executed");
        _;
    }
    
    modifier notConfirmed(uint256 transactionId) {
        require(!confirmations[transactionId][msg.sender], "Transaction already confirmed");
        _;
    }
    
    constructor(address[] memory _owners, uint256 _required) {
        require(_owners.length > 0, "Owners required");
        require(_required > 0 && _required <= _owners.length, "Invalid required number");
        
        for (uint256 i = 0; i < _owners.length; i++) {
            address owner = _owners[i];
            require(owner != address(0), "Invalid owner");
            require(!isOwner[owner], "Owner not unique");
            
            isOwner[owner] = true;
            owners.push(owner);
            permissions[owner] = Permission.OWNER;
        }
        
        required = _required;
    }
    
    // Êèê‰∫§‰∫§ÊòìÊèêÊ°à
    function submitTransaction(
        address to,
        uint256 value,
        bytes memory data,
        string memory description
    ) external onlyOwner returns (uint256) {
        uint256 transactionId = transactions.length;
        
        transactions.push(Transaction({
            to: to,
            value: value,
            data: data,
            executed: false,
            confirmations: 0,
            timestamp: block.timestamp,
            description: description
        }));
        
        emit TransactionSubmitted(transactionId, msg.sender);
        
        // Ëá™Âä®Á°ÆËÆ§Êèê‰∫§ËÄÖÁöÑÊäïÁ•®
        confirmTransaction(transactionId);
        
        return transactionId;
    }
    
    // Á°ÆËÆ§‰∫§Êòì
    function confirmTransaction(uint256 transactionId)
        public
        onlyOwner
        transactionExists(transactionId)
        notConfirmed(transactionId)
        notExecuted(transactionId)
    {
        confirmations[transactionId][msg.sender] = true;
        transactions[transactionId].confirmations++;
        
        emit TransactionConfirmed(transactionId, msg.sender);
        
        // Â¶ÇÊûúÁ°ÆËÆ§Êï∞ÈáèË∂≥Â§üÔºåËá™Âä®ÊâßË°å
        if (transactions[transactionId].confirmations >= required) {
            executeTransaction(transactionId);
        }
    }
    
    // ÊâßË°å‰∫§Êòì
    function executeTransaction(uint256 transactionId)
        public
        onlyOwner
        transactionExists(transactionId)
        notExecuted(transactionId)
    {
        Transaction storage txn = transactions[transactionId];
        require(txn.confirmations >= required, "Not enough confirmations");
        
        txn.executed = true;
        
        (bool success, ) = txn.to.call{value: txn.value}(txn.data);
        require(success, "Transaction execution failed");
        
        emit TransactionExecuted(transactionId);
    }
    
    // ÂàõÂª∫ÊèêÊ°à
    function createProposal(
        string memory title,
        string memory description,
        uint256 votingPeriod
    ) external onlyOwner returns (uint256) {
        uint256 proposalId = proposalCount++;
        
        Proposal storage proposal = proposals[proposalId];
        proposal.id = proposalId;
        proposal.proposer = msg.sender;
        proposal.title = title;
        proposal.description = description;
        proposal.deadline = block.timestamp + votingPeriod;
        proposal.executed = false;
        
        emit ProposalCreated(proposalId, msg.sender, title);
        return proposalId;
    }
    
    // ÊäïÁ•®
    function vote(uint256 proposalId, bool choice) external onlyOwner {
        Proposal storage proposal = proposals[proposalId];
        require(block.timestamp <= proposal.deadline, "Voting period ended");
        require(!proposal.hasVoted[msg.sender], "Already voted");
        require(!proposal.executed, "Proposal already executed");
        
        proposal.hasVoted[msg.sender] = true;
        proposal.voteChoice[msg.sender] = choice;
        
        if (choice) {
            proposal.votesFor++;
        } else {
            proposal.votesAgainst++;
        }
        
        emit ProposalVoted(proposalId, msg.sender, choice);
    }
    
    // ÊâßË°åÊèêÊ°à
    function executeProposal(uint256 proposalId) external onlyOwner {
        Proposal storage proposal = proposals[proposalId];
        require(block.timestamp > proposal.deadline, "Voting period not ended");
        require(!proposal.executed, "Proposal already executed");
        require(proposal.votesFor > proposal.votesAgainst, "Proposal rejected");
        require(proposal.votesFor >= required, "Not enough votes");
        
        proposal.executed = true;
        emit ProposalExecuted(proposalId);
    }
    
    // Ê∑ªÂä†ÊâÄÊúâËÄÖ
    function addOwner(address owner) external onlyAdmin {
        require(owner != address(0), "Invalid owner");
        require(!isOwner[owner], "Owner already exists");
        
        isOwner[owner] = true;
        owners.push(owner);
        permissions[owner] = Permission.OWNER;
        
        emit OwnerAdded(owner);
    }
    
    // ÁßªÈô§ÊâÄÊúâËÄÖ
    function removeOwner(address owner) external onlyAdmin {
        require(isOwner[owner], "Not an owner");
        require(owners.length > required, "Cannot remove owner, would break required threshold");
        
        isOwner[owner] = false;
        permissions[owner] = Permission.VIEWER;
        
        // ‰ªéÊï∞ÁªÑ‰∏≠ÁßªÈô§
        for (uint256 i = 0; i < owners.length; i++) {
            if (owners[i] == owner) {
                owners[i] = owners[owners.length - 1];
                owners.pop();
                break;
            }
        }
        
        emit OwnerRemoved(owner);
    }
    
    // ËÆæÁΩÆÊùÉÈôê
    function setPermission(address user, Permission permission) external onlyAdmin {
        require(user != address(0), "Invalid user");
        permissions[user] = permission;
    }
    
    // Ëé∑Âèñ‰∫§Êòì‰ø°ÊÅØ
    function getTransaction(uint256 transactionId)
        external
        view
        returns (
            address to,
            uint256 value,
            bytes memory data,
            bool executed,
            uint256 confirmationCount,
            uint256 timestamp,
            string memory description
        )
    {
        Transaction storage txn = transactions[transactionId];
        return (
            txn.to,
            txn.value,
            txn.data,
            txn.executed,
            txn.confirmations,
            txn.timestamp,
            txn.description
        );
    }
    
    // Ëé∑ÂèñÊèêÊ°à‰ø°ÊÅØ
    function getProposal(uint256 proposalId)
        external
        view
        returns (
            address proposer,
            string memory title,
            string memory description,
            uint256 votesFor,
            uint256 votesAgainst,
            uint256 deadline,
            bool executed
        )
    {
        Proposal storage proposal = proposals[proposalId];
        return (
            proposal.proposer,
            proposal.title,
            proposal.description,
            proposal.votesFor,
            proposal.votesAgainst,
            proposal.deadline,
            proposal.executed
        );
    }
    
    // Ëé∑ÂèñÊâÄÊúâËÄÖÂàóË°®
    function getOwners() external view returns (address[] memory) {
        return owners;
    }
    
    // Ëé∑Âèñ‰∫§ÊòìÊï∞Èáè
    function getTransactionCount() external view returns (uint256) {
        return transactions.length;
    }
    
    // Ê£ÄÊü•‰∫§ÊòìÊòØÂê¶Â∑≤Á°ÆËÆ§
    function isConfirmed(uint256 transactionId, address owner) external view returns (bool) {
        return confirmations[transactionId][owner];
    }
    
    receive() external payable {}
}
```

### ‰ª£Á†ÅÂÆ°Êü•Á≥ªÁªü

```solidity
// ‰ª£Á†ÅÂÆ°Êü•ÂíåË¥®ÈáèÁÆ°ÁêÜÂêàÁ∫¶
contract CodeReviewSystem {
    struct CodeSubmission {
        uint256 id;
        address author;
        string title;
        string description;
        string codeHash; // IPFS hash or similar
        uint256 timestamp;
        ReviewStatus status;
        uint256 reviewCount;
        uint256 approvalCount;
        bool merged;
    }
    
    struct Review {
        uint256 submissionId;
        address reviewer;
        ReviewResult result;
        string comments;
        uint256 timestamp;
        uint256 score; // 1-10
    }
    
    enum ReviewStatus { PENDING, IN_REVIEW, APPROVED, REJECTED, MERGED }
    enum ReviewResult { APPROVE, REQUEST_CHANGES, REJECT }
    
    mapping(uint256 => CodeSubmission) public submissions;
    mapping(uint256 => Review[]) public reviews;
    mapping(address => bool) public authorizedReviewers;
    mapping(address => uint256) public reviewerScores;
    mapping(address => uint256) public contributorScores;
    
    uint256 public submissionCount;
    uint256 public constant MIN_REVIEWERS = 2;
    uint256 public constant MIN_APPROVAL_SCORE = 7;
    
    address public admin;
    
    event SubmissionCreated(uint256 indexed submissionId, address indexed author, string title);
    event ReviewSubmitted(uint256 indexed submissionId, address indexed reviewer, ReviewResult result);
    event SubmissionApproved(uint256 indexed submissionId);
    event SubmissionMerged(uint256 indexed submissionId);
    event ReviewerAuthorized(address indexed reviewer);
    
    modifier onlyAdmin() {
        require(msg.sender == admin, "Only admin");
        _;
    }
    
    modifier onlyAuthorizedReviewer() {
        require(authorizedReviewers[msg.sender], "Not authorized reviewer");
        _;
    }
    
    modifier submissionExists(uint256 submissionId) {
        require(submissionId < submissionCount, "Submission does not exist");
        _;
    }
    
    constructor() {
        admin = msg.sender;
        authorizedReviewers[msg.sender] = true;
    }
    
    // Êèê‰∫§‰ª£Á†ÅÂÆ°Êü•ËØ∑Ê±Ç
    function submitCode(
        string memory title,
        string memory description,
        string memory codeHash
    ) external returns (uint256) {
        uint256 submissionId = submissionCount++;
        
        submissions[submissionId] = CodeSubmission({
            id: submissionId,
            author: msg.sender,
            title: title,
            description: description,
            codeHash: codeHash,
            timestamp: block.timestamp,
            status: ReviewStatus.PENDING,
            reviewCount: 0,
            approvalCount: 0,
            merged: false
        });
        
        emit SubmissionCreated(submissionId, msg.sender, title);
        return submissionId;
    }
    
    // Êèê‰∫§ÂÆ°Êü•ÊÑèËßÅ
    function submitReview(
        uint256 submissionId,
        ReviewResult result,
        string memory comments,
        uint256 score
    ) external onlyAuthorizedReviewer submissionExists(submissionId) {
        CodeSubmission storage submission = submissions[submissionId];
        require(submission.author != msg.sender, "Cannot review own submission");
        require(submission.status != ReviewStatus.MERGED, "Submission already merged");
        require(score >= 1 && score <= 10, "Score must be between 1 and 10");
        
        // Ê£ÄÊü•ÊòØÂê¶Â∑≤ÁªèÂÆ°Êü•Ëøá
        Review[] storage submissionReviews = reviews[submissionId];
        for (uint256 i = 0; i < submissionReviews.length; i++) {
            require(submissionReviews[i].reviewer != msg.sender, "Already reviewed");
        }
        
        // Ê∑ªÂä†ÂÆ°Êü•ËÆ∞ÂΩï
        submissionReviews.push(Review({
            submissionId: submissionId,
            reviewer: msg.sender,
            result: result,
            comments: comments,
            timestamp: block.timestamp,
            score: score
        }));
        
        submission.reviewCount++;
        
        // Êõ¥Êñ∞ÂÆ°Êü•ËÄÖÁßØÂàÜ
        reviewerScores[msg.sender]++;
        
        if (result == ReviewResult.APPROVE && score >= MIN_APPROVAL_SCORE) {
            submission.approvalCount++;
        }
        
        // Êõ¥Êñ∞Êèê‰∫§Áä∂ÊÄÅ
        _updateSubmissionStatus(submissionId);
        
        emit ReviewSubmitted(submissionId, msg.sender, result);
    }
    
    // Êõ¥Êñ∞Êèê‰∫§Áä∂ÊÄÅ
    function _updateSubmissionStatus(uint256 submissionId) internal {
        CodeSubmission storage submission = submissions[submissionId];
        
        if (submission.reviewCount >= MIN_REVIEWERS) {
            if (submission.approvalCount >= MIN_REVIEWERS) {
                submission.status = ReviewStatus.APPROVED;
                contributorScores[submission.author] += 10; // Â•ñÂä±‰ΩúËÄÖ
                emit SubmissionApproved(submissionId);
            } else {
                // Ê£ÄÊü•ÊòØÂê¶ÊúâÊãíÁªù
                Review[] storage submissionReviews = reviews[submissionId];
                uint256 rejectCount = 0;
                
                for (uint256 i = 0; i < submissionReviews.length; i++) {
                    if (submissionReviews[i].result == ReviewResult.REJECT) {
                        rejectCount++;
                    }
                }
                
                if (rejectCount >= MIN_REVIEWERS) {
                    submission.status = ReviewStatus.REJECTED;
                } else {
                    submission.status = ReviewStatus.IN_REVIEW;
                }
            }
        } else {
            submission.status = ReviewStatus.IN_REVIEW;
        }
    }
    
    // ÂêàÂπ∂‰ª£Á†ÅÔºàÂè™ÊúâÁÆ°ÁêÜÂëòÂèØ‰ª•Êìç‰ΩúÔºâ
    function mergeSubmission(uint256 submissionId) 
        external 
        onlyAdmin 
        submissionExists(submissionId) 
    {
        CodeSubmission storage submission = submissions[submissionId];
        require(submission.status == ReviewStatus.APPROVED, "Submission not approved");
        require(!submission.merged, "Already merged");
        
        submission.merged = true;
        submission.status = ReviewStatus.MERGED;
        
        // È¢ùÂ§ñÂ•ñÂä±‰ΩúËÄÖ
        contributorScores[submission.author] += 20;
        
        emit SubmissionMerged(submissionId);
    }
    
    // ÊéàÊùÉÂÆ°Êü•ËÄÖ
    function authorizeReviewer(address reviewer) external onlyAdmin {
        require(reviewer != address(0), "Invalid reviewer");
        authorizedReviewers[reviewer] = true;
        emit ReviewerAuthorized(reviewer);
    }
    
    // ÂèñÊ∂àÂÆ°Êü•ËÄÖÊéàÊùÉ
    function revokeReviewer(address reviewer) external onlyAdmin {
        authorizedReviewers[reviewer] = false;
    }
    
    // Ëé∑ÂèñÊèê‰∫§‰ø°ÊÅØ
    function getSubmission(uint256 submissionId)
        external
        view
        submissionExists(submissionId)
        returns (
            address author,
            string memory title,
            string memory description,
            string memory codeHash,
            uint256 timestamp,
            ReviewStatus status,
            uint256 reviewCount,
            uint256 approvalCount,
            bool merged
        )
    {
        CodeSubmission storage submission = submissions[submissionId];
        return (
            submission.author,
            submission.title,
            submission.description,
            submission.codeHash,
            submission.timestamp,
            submission.status,
            submission.reviewCount,
            submission.approvalCount,
            submission.merged
        );
    }
    
    // Ëé∑ÂèñÂÆ°Êü•ËÆ∞ÂΩï
    function getReviews(uint256 submissionId) 
        external 
        view 
        submissionExists(submissionId) 
        returns (Review[] memory) 
    {
        return reviews[submissionId];
    }
    
    // Ëé∑ÂèñÁî®Êà∑ÁªüËÆ°
    function getUserStats(address user) 
        external 
        view 
        returns (
            uint256 contributorScore,
            uint256 reviewerScore,
            bool isAuthorizedReviewer
        ) 
    {
        return (
            contributorScores[user],
            reviewerScores[user],
            authorizedReviewers[user]
        );
    }
}
```

### È°πÁõÆÁÆ°ÁêÜÁ≥ªÁªü

```solidity
// È°πÁõÆÁÆ°ÁêÜÂíå‰ªªÂä°ÂàÜÈÖçÂêàÁ∫¶
contract ProjectManagement {
    struct Project {
        uint256 id;
        string name;
        string description;
        address owner;
        uint256 budget;
        uint256 deadline;
        ProjectStatus status;
        uint256 taskCount;
        uint256 completedTasks;
        uint256 createdAt;
    }
    
    struct Task {
        uint256 id;
        uint256 projectId;
        string title;
        string description;
        address assignee;
        uint256 reward;
        uint256 deadline;
        TaskStatus status;
        TaskPriority priority;
        uint256 estimatedHours;
        uint256 actualHours;
        uint256 createdAt;
        uint256 completedAt;
    }
    
    struct Milestone {
        uint256 id;
        uint256 projectId;
        string title;
        string description;
        uint256 deadline;
        uint256 reward;
        bool completed;
        uint256[] requiredTasks;
    }
    
    enum ProjectStatus { PLANNING, ACTIVE, PAUSED, COMPLETED, CANCELLED }
    enum TaskStatus { TODO, IN_PROGRESS, REVIEW, COMPLETED, CANCELLED }
    enum TaskPriority { LOW, MEDIUM, HIGH, CRITICAL }
    
    mapping(uint256 => Project) public projects;
    mapping(uint256 => Task) public tasks;
    mapping(uint256 => Milestone) public milestones;
    mapping(uint256 => uint256[]) public projectTasks; // projectId => taskIds
    mapping(uint256 => uint256[]) public projectMilestones; // projectId => milestoneIds
    mapping(address => uint256[]) public userTasks; // user => taskIds
    mapping(address => uint256) public userRewards;
    
    uint256 public projectCount;
    uint256 public taskCount;
    uint256 public milestoneCount;
    
    address public admin;
    
    event ProjectCreated(uint256 indexed projectId, string name, address indexed owner);
    event TaskCreated(uint256 indexed taskId, uint256 indexed projectId, string title);
    event TaskAssigned(uint256 indexed taskId, address indexed assignee);
    event TaskCompleted(uint256 indexed taskId, address indexed assignee);
    event MilestoneCreated(uint256 indexed milestoneId, uint256 indexed projectId, string title);
    event MilestoneCompleted(uint256 indexed milestoneId, uint256 indexed projectId);
    event RewardClaimed(address indexed user, uint256 amount);
    
    modifier onlyAdmin() {
        require(msg.sender == admin, "Only admin");
        _;
    }
    
    modifier onlyProjectOwner(uint256 projectId) {
        require(projects[projectId].owner == msg.sender, "Only project owner");
        _;
    }
    
    modifier projectExists(uint256 projectId) {
        require(projectId < projectCount, "Project does not exist");
        _;
    }
    
    modifier taskExists(uint256 taskId) {
        require(taskId < taskCount, "Task does not exist");
        _;
    }
    
    constructor() {
        admin = msg.sender;
    }
    
    // ÂàõÂª∫È°πÁõÆ
    function createProject(
        string memory name,
        string memory description,
        uint256 budget,
        uint256 deadline
    ) external returns (uint256) {
        require(deadline > block.timestamp, "Deadline must be in the future");
        
        uint256 projectId = projectCount++;
        
        projects[projectId] = Project({
            id: projectId,
            name: name,
            description: description,
            owner: msg.sender,
            budget: budget,
            deadline: deadline,
            status: ProjectStatus.PLANNING,
            taskCount: 0,
            completedTasks: 0,
            createdAt: block.timestamp
        });
        
        emit ProjectCreated(projectId, name, msg.sender);
        return projectId;
    }
    
    // ÂàõÂª∫‰ªªÂä°
    function createTask(
        uint256 projectId,
        string memory title,
        string memory description,
        uint256 reward,
        uint256 deadline,
        TaskPriority priority,
        uint256 estimatedHours
    ) external projectExists(projectId) onlyProjectOwner(projectId) returns (uint256) {
        require(deadline > block.timestamp, "Deadline must be in the future");
        require(deadline <= projects[projectId].deadline, "Task deadline exceeds project deadline");
        
        uint256 taskId = taskCount++;
        
        tasks[taskId] = Task({
            id: taskId,
            projectId: projectId,
            title: title,
            description: description,
            assignee: address(0),
            reward: reward,
            deadline: deadline,
            status: TaskStatus.TODO,
            priority: priority,
            estimatedHours: estimatedHours,
            actualHours: 0,
            createdAt: block.timestamp,
            completedAt: 0
        });
        
        projectTasks[projectId].push(taskId);
        projects[projectId].taskCount++;
        
        emit TaskCreated(taskId, projectId, title);
        return taskId;
    }
    
    // ÂàÜÈÖç‰ªªÂä°
    function assignTask(uint256 taskId, address assignee) 
        external 
        taskExists(taskId) 
    {
        Task storage task = tasks[taskId];
        require(
            msg.sender == projects[task.projectId].owner || msg.sender == admin,
            "Only project owner or admin can assign tasks"
        );
        require(task.assignee == address(0), "Task already assigned");
        require(assignee != address(0), "Invalid assignee");
        
        task.assignee = assignee;
        task.status = TaskStatus.IN_PROGRESS;
        userTasks[assignee].push(taskId);
        
        emit TaskAssigned(taskId, assignee);
    }
    
    // ÂÆåÊàê‰ªªÂä°
    function completeTask(uint256 taskId, uint256 actualHours) 
        external 
        taskExists(taskId) 
    {
        Task storage task = tasks[taskId];
        require(task.assignee == msg.sender, "Only assignee can complete task");
        require(task.status == TaskStatus.IN_PROGRESS, "Task not in progress");
        
        task.status = TaskStatus.COMPLETED;
        task.actualHours = actualHours;
        task.completedAt = block.timestamp;
        
        // Êõ¥Êñ∞È°πÁõÆËøõÂ∫¶
        projects[task.projectId].completedTasks++;
        
        // Ê∑ªÂä†Â•ñÂä±
        userRewards[msg.sender] += task.reward;
        
        // Ê£ÄÊü•È°πÁõÆÊòØÂê¶ÂÆåÊàê
        _checkProjectCompletion(task.projectId);
        
        emit TaskCompleted(taskId, msg.sender);
    }
    
    // ÂàõÂª∫ÈáåÁ®ãÁ¢ë
    function createMilestone(
        uint256 projectId,
        string memory title,
        string memory description,
        uint256 deadline,
        uint256 reward,
        uint256[] memory requiredTasks
    ) external projectExists(projectId) onlyProjectOwner(projectId) returns (uint256) {
        require(deadline > block.timestamp, "Deadline must be in the future");
        require(deadline <= projects[projectId].deadline, "Milestone deadline exceeds project deadline");
        
        uint256 milestoneId = milestoneCount++;
        
        milestones[milestoneId] = Milestone({
            id: milestoneId,
            projectId: projectId,
            title: title,
            description: description,
            deadline: deadline,
            reward: reward,
            completed: false,
            requiredTasks: requiredTasks
        });
        
        projectMilestones[projectId].push(milestoneId);
        
        emit MilestoneCreated(milestoneId, projectId, title);
        return milestoneId;
    }
    
    // Ê£ÄÊü•ÈáåÁ®ãÁ¢ëÂÆåÊàê
    function checkMilestoneCompletion(uint256 milestoneId) external {
        Milestone storage milestone = milestones[milestoneId];
        require(!milestone.completed, "Milestone already completed");
        
        // Ê£ÄÊü•ÊâÄÊúâÂøÖÈúÄ‰ªªÂä°ÊòØÂê¶ÂÆåÊàê
        for (uint256 i = 0; i < milestone.requiredTasks.length; i++) {
            uint256 taskId = milestone.requiredTasks[i];
            require(tasks[taskId].status == TaskStatus.COMPLETED, "Required task not completed");
        }
        
        milestone.completed = true;
        
        // ÂàÜÈÖçÈáåÁ®ãÁ¢ëÂ•ñÂä±ÁªôÈ°πÁõÆÊâÄÊúâËÄÖ
        address projectOwner = projects[milestone.projectId].owner;
        userRewards[projectOwner] += milestone.reward;
        
        emit MilestoneCompleted(milestoneId, milestone.projectId);
    }
    
    // Ê£ÄÊü•È°πÁõÆÂÆåÊàê
    function _checkProjectCompletion(uint256 projectId) internal {
        Project storage project = projects[projectId];
        
        if (project.completedTasks == project.taskCount && project.taskCount > 0) {
            project.status = ProjectStatus.COMPLETED;
        }
    }
    
    // ÊèêÂèñÂ•ñÂä±
    function claimRewards() external {
        uint256 amount = userRewards[msg.sender];
        require(amount > 0, "No rewards to claim");
        require(address(this).balance >= amount, "Insufficient contract balance");
        
        userRewards[msg.sender] = 0;
        payable(msg.sender).transfer(amount);
        
        emit RewardClaimed(msg.sender, amount);
    }
    
    // Êõ¥Êñ∞‰ªªÂä°Áä∂ÊÄÅ
    function updateTaskStatus(uint256 taskId, TaskStatus status) 
        external 
        taskExists(taskId) 
    {
        Task storage task = tasks[taskId];
        require(
            msg.sender == task.assignee || 
            msg.sender == projects[task.projectId].owner || 
            msg.sender == admin,
            "Not authorized to update task status"
        );
        
        task.status = status;
    }
    
    // Êõ¥Êñ∞È°πÁõÆÁä∂ÊÄÅ
    function updateProjectStatus(uint256 projectId, ProjectStatus status) 
        external 
        projectExists(projectId) 
        onlyProjectOwner(projectId) 
    {
        projects[projectId].status = status;
    }
    
    // Ëé∑ÂèñÈ°πÁõÆ‰ªªÂä°ÂàóË°®
    function getProjectTasks(uint256 projectId) 
        external 
        view 
        projectExists(projectId) 
        returns (uint256[] memory) 
    {
        return projectTasks[projectId];
    }
    
    // Ëé∑ÂèñÁî®Êà∑‰ªªÂä°ÂàóË°®
    function getUserTasks(address user) external view returns (uint256[] memory) {
        return userTasks[user];
    }
    
    // Ëé∑ÂèñÈ°πÁõÆÈáåÁ®ãÁ¢ëÂàóË°®
    function getProjectMilestones(uint256 projectId) 
        external 
        view 
        projectExists(projectId) 
        returns (uint256[] memory) 
    {
        return projectMilestones[projectId];
    }
    
    // Ëé∑ÂèñÈ°πÁõÆËøõÂ∫¶
    function getProjectProgress(uint256 projectId) 
        external 
        view 
        projectExists(projectId) 
        returns (uint256 totalTasks, uint256 completedTasks, uint256 progressPercentage) 
    {
        Project storage project = projects[projectId];
        totalTasks = project.taskCount;
        completedTasks = project.completedTasks;
        
        if (totalTasks > 0) {
            progressPercentage = (completedTasks * 100) / totalTasks;
        } else {
            progressPercentage = 0;
        }
    }
    
    // ÂÖÖÂÄºÂêàÁ∫¶
    receive() external payable {}
    
    // ÊèêÂèñÂêàÁ∫¶‰ΩôÈ¢ùÔºà‰ªÖÁÆ°ÁêÜÂëòÔºâ
    function withdraw(uint256 amount) external onlyAdmin {
        require(address(this).balance >= amount, "Insufficient balance");
        payable(admin).transfer(amount);
    }
}
```

---

## üìã ‰ª£Á†ÅËßÑËåÉ‰∏éË¥®Èáè‰øùËØÅ

### ‰ª£Á†ÅÈ£éÊ†ºÊåáÂçó

```solidity
// ‰ª£Á†ÅÈ£éÊ†ºÂíåËßÑËåÉÊ£ÄÊü•ÂêàÁ∫¶
contract CodeStyleGuide {
    // ÂëΩÂêçËßÑËåÉ
    struct NamingConvention {
        string contractName;     // PascalCase: MyContract
        string functionName;     // camelCase: myFunction
        string variableName;     // camelCase: myVariable
        string constantName;     // UPPER_SNAKE_CASE: MY_CONSTANT
        string eventName;        // PascalCase: MyEvent
        string modifierName;     // camelCase: myModifier
    }
    
    // ÂáΩÊï∞ÂèØËßÅÊÄßÈ°∫Â∫èÔºöexternal, public, internal, private
    // Áä∂ÊÄÅÂèòÈáèÈ°∫Â∫èÔºöpublic, internal, private
    
    // ‚úÖ ËâØÂ•ΩÁöÑÂêàÁ∫¶ÁªìÊûÑÁ§∫‰æã
    contract WellStructuredContract {
        // 1. Á±ªÂûãÂ£∞Êòé
        enum Status { Active, Inactive }
        struct User { address addr; uint256 balance; }
        
        // 2. Áä∂ÊÄÅÂèòÈáèÔºàÊåâÂèØËßÅÊÄßÊéíÂ∫èÔºâ
        address public owner;
        mapping(address => User) public users;
        uint256 internal totalSupply;
        bool private initialized;
        
        // 3. ‰∫ã‰ª∂
        event UserRegistered(address indexed user);
        event BalanceUpdated(address indexed user, uint256 newBalance);
        
        // 4. ‰øÆÈ•∞Á¨¶
        modifier onlyOwner() {
            require(msg.sender == owner, "Only owner");
            _;
        }
        
        modifier validAddress(address addr) {
            require(addr != address(0), "Invalid address");
            _;
        }
        
        // 5. ÊûÑÈÄ†ÂáΩÊï∞
        constructor() {
            owner = msg.sender;
            initialized = true;
        }
        
        // 6. Êé•Êî∂ÂáΩÊï∞
        receive() external payable {
            // Â§ÑÁêÜÊé•Êî∂Âà∞ÁöÑ‰ª•Â§™Â∏Å
        }
        
        // 7. ÂõûÈÄÄÂáΩÊï∞
        fallback() external payable {
            // Â§ÑÁêÜÊú™Áü•ÂáΩÊï∞Ë∞ÉÁî®
        }
        
        // 8. Â§ñÈÉ®ÂáΩÊï∞
        function registerUser() external validAddress(msg.sender) {
            users[msg.sender] = User(msg.sender, 0);
            emit UserRegistered(msg.sender);
        }
        
        // 9. ÂÖ¨ÂÖ±ÂáΩÊï∞
        function updateBalance(address user, uint256 newBalance) 
            public 
            onlyOwner 
            validAddress(user) 
        {
            users[user].balance = newBalance;
            emit BalanceUpdated(user, newBalance);
        }
        
        // 10. ÂÜÖÈÉ®ÂáΩÊï∞
        function _calculateFee(uint256 amount) internal pure returns (uint256) {
            return amount * 3 / 100; // 3% fee
        }
        
        // 11. ÁßÅÊúâÂáΩÊï∞
        function _validateUser(address user) private view returns (bool) {
            return users[user].addr != address(0);
        }
    }
}
```

### ÂÆâÂÖ®Ê£ÄÊü•Ê∏ÖÂçï

```solidity
// ÂÆâÂÖ®ÊúÄ‰Ω≥ÂÆûË∑µÂêàÁ∫¶
contract SecurityBestPractices {
    // ‚úÖ ÈáçÂÖ•ÊîªÂáªÈò≤Êä§
    bool private locked;
    
    modifier nonReentrant() {
        require(!locked, "ReentrancyGuard: reentrant call");
        locked = true;
        _;
        locked = false;
    }
    
    // ‚úÖ Êï¥Êï∞Ê∫¢Âá∫Èò≤Êä§ÔºàSolidity 0.8.0+ Ëá™Âä®Ê£ÄÊü•Ôºâ
    function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");
        return c;
    }
    
    // ‚úÖ ËÆøÈóÆÊéßÂà∂
    address public owner;
    mapping(address => bool) public authorized;
    
    modifier onlyOwner() {
        require(msg.sender == owner, "Ownable: caller is not the owner");
        _;
    }
    
    modifier onlyAuthorized() {
        require(authorized[msg.sender] || msg.sender == owner, "Not authorized");
        _;
    }
    
    // ‚úÖ ËæìÂÖ•È™åËØÅ
    function validateInput(address addr, uint256 amount) internal pure {
        require(addr != address(0), "Invalid address");
        require(amount > 0, "Amount must be positive");
        require(amount <= type(uint256).max / 2, "Amount too large");
    }
    
    // ‚úÖ Áä∂ÊÄÅÊ£ÄÊü•
    enum ContractState { Active, Paused, Terminated }
    ContractState public state = ContractState.Active;
    
    modifier whenActive() {
        require(state == ContractState.Active, "Contract not active");
        _;
    }
    
    modifier whenPaused() {
        require(state == ContractState.Paused, "Contract not paused");
        _;
    }
    
    // ‚úÖ ÂÆâÂÖ®ÁöÑÂ§ñÈÉ®Ë∞ÉÁî®
    function safeExternalCall(address target, bytes memory data) 
        internal 
        returns (bool success, bytes memory result) 
    {
        require(target != address(0), "Invalid target");
        require(target.code.length > 0, "Target is not a contract");
        
        // ‰ΩøÁî®‰ΩéÁ∫ßË∞ÉÁî®Âπ∂Ê£ÄÊü•ËøîÂõûÂÄº
        (success, result) = target.call(data);
        
        // ÂèØÈÄâÔºöÊ£ÄÊü•ËøîÂõûÊï∞ÊçÆ
        if (!success) {
            if (result.length > 0) {
                // ÈáçÊñ∞ÊäõÂá∫ÈîôËØØÊ∂àÊÅØ
                assembly {
                    let returndata_size := mload(result)
                    revert(add(32, result), returndata_size)
                }
            } else {
                revert("External call failed");
            }
        }
    }
    
    // ‚úÖ Êó∂Èó¥ÈîÅÂÆö
    mapping(bytes32 => uint256) public timelocks;
    uint256 public constant TIMELOCK_DURATION = 2 days;
    
    function scheduleTransaction(
        address target,
        uint256 value,
        bytes memory data,
        uint256 eta
    ) external onlyOwner returns (bytes32) {
        require(eta >= block.timestamp + TIMELOCK_DURATION, "ETA too early");
        
        bytes32 txHash = keccak256(abi.encode(target, value, data, eta));
        timelocks[txHash] = eta;
        
        return txHash;
    }
    
    function executeTransaction(
        address target,
        uint256 value,
        bytes memory data,
        uint256 eta
    ) external onlyOwner {
        bytes32 txHash = keccak256(abi.encode(target, value, data, eta));
        require(timelocks[txHash] != 0, "Transaction not scheduled");
        require(block.timestamp >= timelocks[txHash], "Transaction locked");
        require(block.timestamp <= timelocks[txHash] + 30 days, "Transaction expired");
        
        delete timelocks[txHash];
        
        (bool success, ) = target.call{value: value}(data);
        require(success, "Transaction execution failed");
    }
    
    // ‚úÖ Á¥ßÊÄ•ÂÅúÊ≠¢Êú∫Âà∂
    bool public emergencyStop = false;
    
    modifier stopInEmergency() {
        require(!emergencyStop, "Emergency stop activated");
        _;
    }
    
    modifier onlyInEmergency() {
        require(emergencyStop, "Not in emergency");
        _;
    }
    
    function toggleEmergencyStop() external onlyOwner {
        emergencyStop = !emergencyStop;
    }
    
    // ‚úÖ ËµÑÈáëÊèêÂèñÊ®°ÂºèÔºàPull over PushÔºâ
    mapping(address => uint256) public pendingWithdrawals;
    
    function withdraw() external nonReentrant {
        uint256 amount = pendingWithdrawals[msg.sender];
        require(amount > 0, "No funds to withdraw");
        
        pendingWithdrawals[msg.sender] = 0;
        
        (bool success, ) = msg.sender.call{value: amount}("");
        require(success, "Withdrawal failed");
    }
    
    // ‚úÖ ‰∫ã‰ª∂Êó•ÂøóËÆ∞ÂΩï
    event SecurityEvent(string eventType, address indexed user, uint256 timestamp);
    event AdminAction(string action, address indexed admin, uint256 timestamp);
    
    function logSecurityEvent(string memory eventType) internal {
        emit SecurityEvent(eventType, msg.sender, block.timestamp);
    }
    
    function logAdminAction(string memory action) internal {
        emit AdminAction(action, msg.sender, block.timestamp);
    }
}
```

---

## üîß ÂºÄÂèëÂ∑•ÂÖ∑‰∏éÊµÅÁ®ã

### Ëá™Âä®ÂåñÊµãËØïÊ°ÜÊû∂

```solidity
// ÊµãËØïËæÖÂä©ÂêàÁ∫¶
contract TestHelper {
    // ÊµãËØï‰∫ã‰ª∂
    event TestResult(string testName, bool passed, string message);
    event TestSuiteStarted(string suiteName);
    event TestSuiteCompleted(string suiteName, uint256 passed, uint256 failed);
    
    struct TestCase {
        string name;
        bool executed;
        bool passed;
        string errorMessage;
    }
    
    mapping(string => TestCase[]) public testSuites;
    mapping(string => uint256) public suiteResults; // passed count
    mapping(string => uint256) public suiteFailures; // failed count
    
    // Êñ≠Ë®ÄÂáΩÊï∞
    function assertTrue(bool condition, string memory message) internal pure {
        require(condition, message);
    }
    
    function assertFalse(bool condition, string memory message) internal pure {
        require(!condition, message);
    }
    
    function assertEqual(uint256 a, uint256 b, string memory message) internal pure {
        require(a == b, string(abi.encodePacked(message, ": expected ", toString(b), ", got ", toString(a))));
    }
    
    function assertNotEqual(uint256 a, uint256 b, string memory message) internal pure {
        require(a != b, message);
    }
    
    function assertGreaterThan(uint256 a, uint256 b, string memory message) internal pure {
        require(a > b, string(abi.encodePacked(message, ": ", toString(a), " not greater than ", toString(b))));
    }
    
    function assertLessThan(uint256 a, uint256 b, string memory message) internal pure {
        require(a < b, string(abi.encodePacked(message, ": ", toString(a), " not less than ", toString(b))));
    }
    
    function assertAddressEqual(address a, address b, string memory message) internal pure {
        require(a == b, message);
    }
    
    function assertAddressNotZero(address a, string memory message) internal pure {
        require(a != address(0), message);
    }
    
    // ËøêË°åÊµãËØïÁî®‰æã
    function runTest(string memory suiteName, string memory testName, function() internal testFunc) internal {
        emit TestSuiteStarted(suiteName);
        
        bool passed = true;
        string memory errorMessage = "";
        
        try this.executeTest(testFunc) {
            passed = true;
        } catch Error(string memory reason) {
            passed = false;
            errorMessage = reason;
        } catch (bytes memory) {
            passed = false;
            errorMessage = "Test failed with unknown error";
        }
        
        testSuites[suiteName].push(TestCase({
            name: testName,
            executed: true,
            passed: passed,
            errorMessage: errorMessage
        }));
        
        if (passed) {
            suiteResults[suiteName]++;
        } else {
            suiteFailures[suiteName]++;
        }
        
        emit TestResult(testName, passed, errorMessage);
    }
    
    // ÊâßË°åÊµãËØïÂáΩÊï∞ÔºàÂ§ñÈÉ®Ë∞ÉÁî®‰ª•ÊçïËé∑ÂºÇÂ∏∏Ôºâ
    function executeTest(function() internal testFunc) external {
        testFunc();
    }
    
    // ÂÆåÊàêÊµãËØïÂ•ó‰ª∂
    function completeTestSuite(string memory suiteName) internal {
        emit TestSuiteCompleted(suiteName, suiteResults[suiteName], suiteFailures[suiteName]);
    }
    
    // Â∑•ÂÖ∑ÂáΩÊï∞
    function toString(uint256 value) internal pure returns (string memory) {
        if (value == 0) {
            return "0";
        }
        uint256 temp = value;
        uint256 digits;
        while (temp != 0) {
            digits++;
            temp /= 10;
        }
        bytes memory buffer = new bytes(digits);
        while (value != 0) {
            digits -= 1;
            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));
            value /= 10;
        }
        return string(buffer);
    }
}

// Á§∫‰æãÊµãËØïÂêàÁ∫¶
contract ExampleTest is TestHelper {
    // Ë¢´ÊµãËØïÁöÑÂêàÁ∫¶ÂÆû‰æã
    MultiSigWallet wallet;
    address[] owners;
    
    function setUp() public {
        // ËÆæÁΩÆÊµãËØïÁéØÂ¢É
        owners = new address[](3);
        owners[0] = address(0x1);
        owners[1] = address(0x2);
        owners[2] = address(0x3);
        
        wallet = new MultiSigWallet(owners, 2);
    }
    
    function testWalletCreation() internal {
        // ÊµãËØïÈí±ÂåÖÂàõÂª∫
        assertEqual(wallet.required(), 2, "Required confirmations should be 2");
        
        address[] memory walletOwners = wallet.getOwners();
        assertEqual(walletOwners.length, 3, "Should have 3 owners");
        
        assertTrue(wallet.isOwner(owners[0]), "Address should be owner");
        assertTrue(wallet.isOwner(owners[1]), "Address should be owner");
        assertTrue(wallet.isOwner(owners[2]), "Address should be owner");
    }
    
    function testTransactionSubmission() internal {
        // ÊµãËØï‰∫§ÊòìÊèê‰∫§
        uint256 txId = wallet.submitTransaction(
            address(0x4),
            1 ether,
            "",
            "Test transaction"
        );
        
        assertEqual(txId, 0, "First transaction should have ID 0");
        assertEqual(wallet.getTransactionCount(), 1, "Should have 1 transaction");
    }
    
    function runAllTests() external {
        setUp();
        
        runTest("MultiSigWallet", "testWalletCreation", testWalletCreation);
        runTest("MultiSigWallet", "testTransactionSubmission", testTransactionSubmission);
        
        completeTestSuite("MultiSigWallet");
    }
}
```

---

## üìö Â≠¶‰π†ÂøÉÂæó‰∏éÊÄªÁªì

### Âõ¢ÈòüÂçè‰ΩúË¶ÅÁÇπ

1. **Â§öÁ≠æÊú∫Âà∂ÁöÑÈáçË¶ÅÊÄß**
   - ÂàÜÊï£È£éÈô©ÔºöÈÅøÂÖçÂçïÁÇπÊïÖÈöú
   - ÊèêÈ´òÂÆâÂÖ®ÊÄßÔºöÈáçË¶ÅÊìç‰ΩúÈúÄË¶ÅÂ§öÊñπÁ°ÆËÆ§
   - Â¢ûÂº∫‰ø°‰ªªÔºöÈÄèÊòéÁöÑÂÜ≥Á≠ñËøáÁ®ã
   - Ë¥£‰ªªÂÖ±ÊãÖÔºöÈõÜ‰ΩìÂÜ≥Á≠ñÔºåÈõÜ‰ΩìË¥üË¥£

2. **‰ª£Á†ÅÂÆ°Êü•ÁöÑ‰ª∑ÂÄº**
   - Ë¥®Èáè‰øùËØÅÔºöÂèëÁé∞ÊΩúÂú®ÈóÆÈ¢òÂíåÊºèÊ¥û
   - Áü•ËØÜÂÖ±‰∫´ÔºöÂõ¢ÈòüÊàêÂëò‰∫íÁõ∏Â≠¶‰π†
   - Ê†áÂáÜÁªü‰∏ÄÔºö‰øùÊåÅ‰ª£Á†ÅÈ£éÊ†º‰∏ÄËá¥
   - ÁªèÈ™å‰º†ÊâøÔºöÊñ∞Êâã‰ªéÂÆ°Êü•‰∏≠Â≠¶‰π†

3. **È°πÁõÆÁÆ°ÁêÜÁöÑÂÆûË∑µ**
   - ÊòéÁ°ÆÂàÜÂ∑•ÔºöÊØè‰∏™‰ªªÂä°ÈÉΩÊúâÊòéÁ°ÆÁöÑË¥üË¥£‰∫∫
   - ËøõÂ∫¶Ë∑üË∏™ÔºöÂÆûÊó∂‰∫ÜËß£È°πÁõÆËøõÂ±ï
   - ÈáåÁ®ãÁ¢ëÁÆ°ÁêÜÔºöÂàÜÈò∂ÊÆµÂÆåÊàêÁõÆÊ†á
   - ÊøÄÂä±Êú∫Âà∂ÔºöÂêàÁêÜÁöÑÂ•ñÂä±ÂàÜÈÖç

### ‰ª£Á†ÅËßÑËåÉÁöÑÊÑè‰πâ

1. **ÂèØËØªÊÄßÊèêÂçá**
   - Áªü‰∏ÄÁöÑÂëΩÂêçËßÑËåÉ
   - Ê∏ÖÊô∞ÁöÑ‰ª£Á†ÅÁªìÊûÑ
   - ÂÆåÂñÑÁöÑÊ≥®ÈáäÊñáÊ°£
   - ÂêàÁêÜÁöÑÂáΩÊï∞ÂàÜËß£

2. **Áª¥Êä§ÊÄßÂ¢ûÂº∫**
   - Êòì‰∫éÁêÜËß£Âíå‰øÆÊîπ
   - Èôç‰ΩéÁª¥Êä§ÊàêÊú¨
   - ÂáèÂ∞ëÂºïÂÖ•ÈîôËØØÁöÑÂèØËÉΩÊÄß
   - ‰æø‰∫éÂõ¢ÈòüÂçè‰Ωú

3. **ÂÆâÂÖ®ÊÄß‰øùÈöú**
   - Áªü‰∏ÄÁöÑÂÆâÂÖ®Ê£ÄÊü•
   - Ê†áÂáÜÂåñÁöÑÈîôËØØÂ§ÑÁêÜ
   - ÂÆåÂñÑÁöÑËÆøÈóÆÊéßÂà∂
   - Á≥ªÁªüÁöÑÊµãËØïË¶ÜÁõñ

### ÂÆûË∑µÂª∫ËÆÆ

1. **Âª∫Á´ãÂõ¢ÈòüËßÑËåÉ**
   - Âà∂ÂÆöËØ¶ÁªÜÁöÑÁºñÁ†ÅÊ†áÂáÜ
   - Âª∫Á´ã‰ª£Á†ÅÂÆ°Êü•ÊµÅÁ®ã
   - ‰ΩøÁî®Áªü‰∏ÄÁöÑÂºÄÂèëÂ∑•ÂÖ∑
   - ÂÆöÊúüËøõË°åÊäÄÊúØÂàÜ‰∫´

2. **ÂÆåÂñÑÂºÄÂèëÊµÅÁ®ã**
   - ÁâàÊú¨ÊéßÂà∂ÁÆ°ÁêÜ
   - Ëá™Âä®ÂåñÊµãËØï
   - ÊåÅÁª≠ÈõÜÊàêÈÉ®ÁΩ≤
   - ÊñáÊ°£ÂêåÊ≠•Êõ¥Êñ∞

3. **Ê≥®ÈáçË¥®ÈáèÁÆ°ÁêÜ**
   - ÁºñÂÜôÂÖ®Èù¢ÁöÑÊµãËØïÁî®‰æã
   - ËøõË°åÂÆâÂÖ®ÂÆ°ËÆ°
   - ÊÄßËÉΩ‰ºòÂåñÂàÜÊûê
   - Áî®Êà∑‰ΩìÈ™åÊµãËØï

### Êú™Êù•ÂèëÂ±ïÊñπÂêë

1. **Â∑•ÂÖ∑ÈìæÂÆåÂñÑ**
   - Êõ¥Êô∫ËÉΩÁöÑ‰ª£Á†ÅÂàÜÊûêÂ∑•ÂÖ∑
   - Ëá™Âä®ÂåñÁöÑÂÆâÂÖ®Ê£ÄÊµã
   - ÂèØËßÜÂåñÁöÑÈ°πÁõÆÁÆ°ÁêÜ
   - ÈõÜÊàêÂåñÁöÑÂºÄÂèëÁéØÂ¢É

2. **Âçè‰ΩúÊ®°ÂºèÂàõÊñ∞**
   - Âéª‰∏≠ÂøÉÂåñÁöÑÂõ¢ÈòüÂçè‰Ωú
   - Âü∫‰∫éÂå∫ÂùóÈìæÁöÑÊøÄÂä±Êú∫Âà∂
   - Ë∑®ÈìæÈ°πÁõÆÂçè‰Ωú
   - Á§æÂå∫È©±Âä®ÁöÑÂºÄÂèëÊ®°Âºè

ÈÄöËøáÂª∫Á´ãÂÆåÂñÑÁöÑÂõ¢ÈòüÂçè‰ΩúÊú∫Âà∂Âíå‰ª£Á†ÅËßÑËåÉÔºåÊàë‰ª¨ÂèØ‰ª•ÊòæËëóÊèêÈ´òÂºÄÂèëÊïàÁéáÂíå‰ª£Á†ÅË¥®ÈáèÔºå‰∏∫È°πÁõÆÁöÑÊàêÂäüÂ•†ÂÆöÂùöÂÆûÂü∫Á°Ä„ÄÇËøô‰∏ç‰ªÖÊòØÊäÄÊúØÈóÆÈ¢òÔºåÊõ¥ÊòØÁÆ°ÁêÜÂíåÊñáÂåñÈóÆÈ¢òÔºåÈúÄË¶ÅÂõ¢ÈòüÊâÄÊúâÊàêÂëòÁöÑÂÖ±ÂêåÂä™ÂäõÂíåÂùöÊåÅ„ÄÇ