# æ™ºèƒ½åˆçº¦å¼€å‘è¦ç‚¹

**å­¦ç”Ÿ**: ç‹é¹ (2023110726)  
**å­¦ä¹ ç‰¹è‰²**: æ³¨é‡è·¨é“¾æŠ€æœ¯å’Œäº’æ“ä½œæ€§  
**é‡ç‚¹æ–¹å‘**: è·¨é“¾åè®®ä¸æ¡¥æ¥æŠ€æœ¯  
**æ›´æ–°æ—¶é—´**: 2024å¹´12æœˆ19æ—¥

---

## ğŸ“‹ ç›®å½•

1. [è·¨é“¾æŠ€æœ¯åŸºç¡€](#è·¨é“¾æŠ€æœ¯åŸºç¡€)
2. [è·¨é“¾æ¡¥æ¥åè®®](#è·¨é“¾æ¡¥æ¥åè®®)
3. [äº’æ“ä½œæ€§è®¾è®¡](#äº’æ“ä½œæ€§è®¾è®¡)
4. [è·¨é“¾å®‰å…¨æœºåˆ¶](#è·¨é“¾å®‰å…¨æœºåˆ¶)
5. [å¤šé“¾éƒ¨ç½²ç­–ç•¥](#å¤šé“¾éƒ¨ç½²ç­–ç•¥)
6. [è·¨é“¾åº”ç”¨å¼€å‘](#è·¨é“¾åº”ç”¨å¼€å‘)

---

## ğŸŒ‰ è·¨é“¾æŠ€æœ¯åŸºç¡€

### è·¨é“¾éœ€æ±‚åˆ†æ

```
è·¨é“¾åœºæ™¯åˆ†ç±»:
â”œâ”€â”€ èµ„äº§è·¨é“¾
â”‚   â”œâ”€â”€ ä»£å¸è½¬ç§»
â”‚   â”œâ”€â”€ NFTè¿ç§»
â”‚   â””â”€â”€ æµåŠ¨æ€§å…±äº«
â”œâ”€â”€ æ•°æ®è·¨é“¾
â”‚   â”œâ”€â”€ é¢„è¨€æœºæ•°æ®
â”‚   â”œâ”€â”€ çŠ¶æ€åŒæ­¥
â”‚   â””â”€â”€ èº«ä»½éªŒè¯
â””â”€â”€ åŠŸèƒ½è·¨é“¾
    â”œâ”€â”€ åˆçº¦è°ƒç”¨
    â”œâ”€â”€ æ²»ç†æŠ•ç¥¨
    â””â”€â”€ å¤šé“¾åä½œ
```

### è·¨é“¾æŠ€æœ¯åˆ†ç±»

```solidity
// è·¨é“¾æŠ€æœ¯æšä¸¾
enum CrossChainType {
    ATOMIC_SWAP,      // åŸå­äº¤æ¢
    HASH_LOCK,        // å“ˆå¸Œæ—¶é—´é”
    RELAY_CHAIN,      // ä¸­ç»§é“¾
    SIDE_CHAIN,       // ä¾§é“¾
    STATE_CHANNEL,    // çŠ¶æ€é€šé“
    BRIDGE_CONTRACT   // æ¡¥æ¥åˆçº¦
}

// è·¨é“¾æ¶ˆæ¯ç»“æ„
struct CrossChainMessage {
    uint256 sourceChainId;     // æºé“¾ID
    uint256 targetChainId;     // ç›®æ ‡é“¾ID
    address sourceContract;    // æºåˆçº¦åœ°å€
    address targetContract;    // ç›®æ ‡åˆçº¦åœ°å€
    bytes payload;             // æ¶ˆæ¯è½½è·
    uint256 nonce;             // æ¶ˆæ¯åºå·
    uint256 timestamp;         // æ—¶é—´æˆ³
    bytes32 messageHash;       // æ¶ˆæ¯å“ˆå¸Œ
}

// è·¨é“¾éªŒè¯å™¨æ¥å£
interface ICrossChainValidator {
    function validateMessage(
        CrossChainMessage calldata message,
        bytes[] calldata signatures
    ) external view returns (bool);
    
    function getRequiredSignatures() external view returns (uint256);
    function isValidator(address validator) external view returns (bool);
}
```

### è·¨é“¾é€šä¿¡åè®®

```solidity
// è·¨é“¾é€šä¿¡åŸºç¡€åˆçº¦
abstract contract CrossChainCommunicator {
    // äº‹ä»¶å®šä¹‰
    event MessageSent(
        uint256 indexed targetChainId,
        address indexed targetContract,
        bytes32 indexed messageId,
        bytes payload
    );
    
    event MessageReceived(
        uint256 indexed sourceChainId,
        address indexed sourceContract,
        bytes32 indexed messageId,
        bytes payload
    );
    
    // çŠ¶æ€å˜é‡
    mapping(bytes32 => bool) public processedMessages;
    mapping(uint256 => bool) public supportedChains;
    uint256 public currentChainId;
    uint256 public messageNonce;
    
    // ä¿®é¥°ç¬¦
    modifier onlySupportedChain(uint256 chainId) {
        require(supportedChains[chainId], "Unsupported chain");
        _;
    }
    
    modifier onlyUnprocessed(bytes32 messageId) {
        require(!processedMessages[messageId], "Message already processed");
        _;
    }
    
    // å‘é€è·¨é“¾æ¶ˆæ¯
    function sendMessage(
        uint256 targetChainId,
        address targetContract,
        bytes calldata payload
    ) external onlySupportedChain(targetChainId) returns (bytes32 messageId) {
        messageNonce++;
        
        messageId = keccak256(abi.encodePacked(
            currentChainId,
            targetChainId,
            msg.sender,
            targetContract,
            payload,
            messageNonce,
            block.timestamp
        ));
        
        emit MessageSent(targetChainId, targetContract, messageId, payload);
        
        // è°ƒç”¨å…·ä½“çš„å‘é€å®ç°
        _sendMessageImpl(targetChainId, targetContract, messageId, payload);
    }
    
    // æ¥æ”¶è·¨é“¾æ¶ˆæ¯
    function receiveMessage(
        uint256 sourceChainId,
        address sourceContract,
        bytes32 messageId,
        bytes calldata payload,
        bytes[] calldata proofs
    ) external onlyUnprocessed(messageId) {
        // éªŒè¯æ¶ˆæ¯
        require(
            _verifyMessage(sourceChainId, sourceContract, messageId, payload, proofs),
            "Invalid message"
        );
        
        // æ ‡è®°ä¸ºå·²å¤„ç†
        processedMessages[messageId] = true;
        
        // å¤„ç†æ¶ˆæ¯
        _processMessage(sourceChainId, sourceContract, payload);
        
        emit MessageReceived(sourceChainId, sourceContract, messageId, payload);
    }
    
    // æŠ½è±¡æ–¹æ³•ï¼Œç”±å…·ä½“å®ç°å®šä¹‰
    function _sendMessageImpl(
        uint256 targetChainId,
        address targetContract,
        bytes32 messageId,
        bytes calldata payload
    ) internal virtual;
    
    function _verifyMessage(
        uint256 sourceChainId,
        address sourceContract,
        bytes32 messageId,
        bytes calldata payload,
        bytes[] calldata proofs
    ) internal virtual returns (bool);
    
    function _processMessage(
        uint256 sourceChainId,
        address sourceContract,
        bytes calldata payload
    ) internal virtual;
}
```

---

## ğŸŒ è·¨é“¾æ¡¥æ¥åè®®

### é”å®š-é“¸é€ æ¡¥æ¥æ¨¡å¼

```solidity
// æºé“¾é”å®šåˆçº¦
contract SourceChainLock {
    struct LockInfo {
        address user;
        address token;
        uint256 amount;
        uint256 targetChainId;
        address targetAddress;
        uint256 lockTime;
        bool released;
    }
    
    mapping(bytes32 => LockInfo) public locks;
    mapping(address => bool) public supportedTokens;
    
    event TokensLocked(
        bytes32 indexed lockId,
        address indexed user,
        address indexed token,
        uint256 amount,
        uint256 targetChainId
    );
    
    event TokensReleased(
        bytes32 indexed lockId,
        address indexed user,
        uint256 amount
    );
    
    function lockTokens(
        address token,
        uint256 amount,
        uint256 targetChainId,
        address targetAddress
    ) external returns (bytes32 lockId) {
        require(supportedTokens[token], "Token not supported");
        require(amount > 0, "Amount must be positive");
        
        // è½¬ç§»ä»£å¸åˆ°åˆçº¦
        IERC20(token).transferFrom(msg.sender, address(this), amount);
        
        // ç”Ÿæˆé”å®šID
        lockId = keccak256(abi.encodePacked(
            msg.sender,
            token,
            amount,
            targetChainId,
            targetAddress,
            block.timestamp,
            block.number
        ));
        
        // è®°å½•é”å®šä¿¡æ¯
        locks[lockId] = LockInfo({
            user: msg.sender,
            token: token,
            amount: amount,
            targetChainId: targetChainId,
            targetAddress: targetAddress,
            lockTime: block.timestamp,
            released: false
        });
        
        emit TokensLocked(lockId, msg.sender, token, amount, targetChainId);
    }
    
    function releaseTokens(
        bytes32 lockId,
        bytes[] calldata signatures
    ) external {
        LockInfo storage lockInfo = locks[lockId];
        require(lockInfo.user != address(0), "Lock not found");
        require(!lockInfo.released, "Already released");
        
        // éªŒè¯ç­¾åï¼ˆç®€åŒ–å®ç°ï¼‰
        require(_verifySignatures(lockId, signatures), "Invalid signatures");
        
        // é‡Šæ”¾ä»£å¸
        lockInfo.released = true;
        IERC20(lockInfo.token).transfer(lockInfo.user, lockInfo.amount);
        
        emit TokensReleased(lockId, lockInfo.user, lockInfo.amount);
    }
    
    function _verifySignatures(
        bytes32 lockId,
        bytes[] calldata signatures
    ) internal pure returns (bool) {
        // ç®€åŒ–å®ç°ï¼šå®é™…åº”è¯¥éªŒè¯å¤šç­¾
        return signatures.length >= 2;
    }
}

// ç›®æ ‡é“¾é“¸é€ åˆçº¦
contract TargetChainMint {
    struct MintInfo {
        bytes32 sourceLockId;
        address user;
        address token;
        uint256 amount;
        uint256 sourceChainId;
        bool minted;
    }
    
    mapping(bytes32 => MintInfo) public mints;
    mapping(address => address) public tokenMappings; // æºé“¾ä»£å¸ -> ç›®æ ‡é“¾ä»£å¸
    
    event TokensMinted(
        bytes32 indexed mintId,
        bytes32 indexed sourceLockId,
        address indexed user,
        uint256 amount
    );
    
    function mintTokens(
        bytes32 sourceLockId,
        address user,
        address sourceToken,
        uint256 amount,
        uint256 sourceChainId,
        bytes[] calldata proofs
    ) external returns (bytes32 mintId) {
        // éªŒè¯é”å®šè¯æ˜
        require(_verifyLockProof(sourceLockId, user, sourceToken, amount, proofs), "Invalid proof");
        
        // è·å–ç›®æ ‡é“¾ä»£å¸åœ°å€
        address targetToken = tokenMappings[sourceToken];
        require(targetToken != address(0), "Token mapping not found");
        
        // ç”Ÿæˆé“¸é€ ID
        mintId = keccak256(abi.encodePacked(
            sourceLockId,
            user,
            sourceToken,
            amount,
            sourceChainId
        ));
        
        // æ£€æŸ¥æ˜¯å¦å·²é“¸é€ 
        require(mints[mintId].user == address(0), "Already minted");
        
        // è®°å½•é“¸é€ ä¿¡æ¯
        mints[mintId] = MintInfo({
            sourceLockId: sourceLockId,
            user: user,
            token: targetToken,
            amount: amount,
            sourceChainId: sourceChainId,
            minted: true
        });
        
        // é“¸é€ ä»£å¸
        IMintableToken(targetToken).mint(user, amount);
        
        emit TokensMinted(mintId, sourceLockId, user, amount);
    }
    
    function _verifyLockProof(
        bytes32 sourceLockId,
        address user,
        address sourceToken,
        uint256 amount,
        bytes[] calldata proofs
    ) internal pure returns (bool) {
        // ç®€åŒ–å®ç°ï¼šå®é™…åº”è¯¥éªŒè¯Merkleè¯æ˜æˆ–å…¶ä»–å¯†ç å­¦è¯æ˜
        return proofs.length > 0;
    }
}

// å¯é“¸é€ ä»£å¸æ¥å£
interface IMintableToken {
    function mint(address to, uint256 amount) external;
    function burn(address from, uint256 amount) external;
}
```

### åŸå­äº¤æ¢åè®®

```solidity
// å“ˆå¸Œæ—¶é—´é”åˆçº¦
contract HashTimeLock {
    struct HTLCInfo {
        address sender;
        address receiver;
        address token;
        uint256 amount;
        bytes32 hashLock;
        uint256 timelock;
        bool withdrawn;
        bool refunded;
    }
    
    mapping(bytes32 => HTLCInfo) public htlcs;
    
    event HTLCCreated(
        bytes32 indexed htlcId,
        address indexed sender,
        address indexed receiver,
        uint256 amount,
        bytes32 hashLock,
        uint256 timelock
    );
    
    event HTLCWithdrawn(
        bytes32 indexed htlcId,
        bytes32 preimage
    );
    
    event HTLCRefunded(
        bytes32 indexed htlcId
    );
    
    function createHTLC(
        address receiver,
        address token,
        uint256 amount,
        bytes32 hashLock,
        uint256 timelock
    ) external returns (bytes32 htlcId) {
        require(timelock > block.timestamp, "Timelock must be in future");
        require(amount > 0, "Amount must be positive");
        
        // ç”ŸæˆHTLC ID
        htlcId = keccak256(abi.encodePacked(
            msg.sender,
            receiver,
            token,
            amount,
            hashLock,
            timelock,
            block.timestamp
        ));
        
        // æ£€æŸ¥HTLCæ˜¯å¦å·²å­˜åœ¨
        require(htlcs[htlcId].sender == address(0), "HTLC already exists");
        
        // è½¬ç§»ä»£å¸åˆ°åˆçº¦
        IERC20(token).transferFrom(msg.sender, address(this), amount);
        
        // åˆ›å»ºHTLC
        htlcs[htlcId] = HTLCInfo({
            sender: msg.sender,
            receiver: receiver,
            token: token,
            amount: amount,
            hashLock: hashLock,
            timelock: timelock,
            withdrawn: false,
            refunded: false
        });
        
        emit HTLCCreated(htlcId, msg.sender, receiver, amount, hashLock, timelock);
    }
    
    function withdraw(
        bytes32 htlcId,
        bytes32 preimage
    ) external {
        HTLCInfo storage htlc = htlcs[htlcId];
        require(htlc.sender != address(0), "HTLC not found");
        require(!htlc.withdrawn, "Already withdrawn");
        require(!htlc.refunded, "Already refunded");
        require(block.timestamp <= htlc.timelock, "HTLC expired");
        require(msg.sender == htlc.receiver, "Only receiver can withdraw");
        require(sha256(abi.encodePacked(preimage)) == htlc.hashLock, "Invalid preimage");
        
        // æ ‡è®°ä¸ºå·²æå–
        htlc.withdrawn = true;
        
        // è½¬ç§»ä»£å¸ç»™æ¥æ”¶è€…
        IERC20(htlc.token).transfer(htlc.receiver, htlc.amount);
        
        emit HTLCWithdrawn(htlcId, preimage);
    }
    
    function refund(bytes32 htlcId) external {
        HTLCInfo storage htlc = htlcs[htlcId];
        require(htlc.sender != address(0), "HTLC not found");
        require(!htlc.withdrawn, "Already withdrawn");
        require(!htlc.refunded, "Already refunded");
        require(block.timestamp > htlc.timelock, "HTLC not expired");
        require(msg.sender == htlc.sender, "Only sender can refund");
        
        // æ ‡è®°ä¸ºå·²é€€æ¬¾
        htlc.refunded = true;
        
        // é€€æ¬¾ç»™å‘é€è€…
        IERC20(htlc.token).transfer(htlc.sender, htlc.amount);
        
        emit HTLCRefunded(htlcId);
    }
    
    function getHTLCInfo(bytes32 htlcId) 
        external view returns (HTLCInfo memory) {
        return htlcs[htlcId];
    }
}
```

---

## ğŸ”— äº’æ“ä½œæ€§è®¾è®¡

### ç»Ÿä¸€æ¥å£æ ‡å‡†

```solidity
// è·¨é“¾æ ‡å‡†æ¥å£
interface ICrossChainStandard {
    // åŸºç¡€ä¿¡æ¯
    function getChainId() external view returns (uint256);
    function getSupportedChains() external view returns (uint256[] memory);
    
    // èµ„äº§æ“ä½œ
    function lockAsset(
        address asset,
        uint256 amount,
        uint256 targetChainId,
        address targetAddress
    ) external returns (bytes32 lockId);
    
    function unlockAsset(
        bytes32 lockId,
        bytes calldata proof
    ) external returns (bool);
    
    // æ¶ˆæ¯ä¼ é€’
    function sendMessage(
        uint256 targetChainId,
        bytes calldata message
    ) external returns (bytes32 messageId);
    
    function receiveMessage(
        bytes32 messageId,
        bytes calldata message,
        bytes calldata proof
    ) external returns (bool);
    
    // äº‹ä»¶
    event AssetLocked(
        bytes32 indexed lockId,
        address indexed asset,
        uint256 amount,
        uint256 targetChainId
    );
    
    event AssetUnlocked(
        bytes32 indexed lockId,
        address indexed asset,
        uint256 amount
    );
    
    event MessageSent(
        bytes32 indexed messageId,
        uint256 targetChainId,
        bytes message
    );
    
    event MessageReceived(
        bytes32 indexed messageId,
        uint256 sourceChainId,
        bytes message
    );
}

// è·¨é“¾é€‚é…å™¨
contract CrossChainAdapter is ICrossChainStandard {
    uint256 public immutable chainId;
    mapping(uint256 => bool) public supportedChains;
    mapping(address => bool) public authorizedBridges;
    
    struct AssetLock {
        address asset;
        uint256 amount;
        address locker;
        uint256 targetChainId;
        address targetAddress;
        uint256 lockTime;
        bool unlocked;
    }
    
    mapping(bytes32 => AssetLock) public assetLocks;
    mapping(bytes32 => bool) public processedMessages;
    
    modifier onlyAuthorizedBridge() {
        require(authorizedBridges[msg.sender], "Not authorized bridge");
        _;
    }
    
    constructor(uint256 _chainId) {
        chainId = _chainId;
    }
    
    function getChainId() external view override returns (uint256) {
        return chainId;
    }
    
    function getSupportedChains() external view override returns (uint256[] memory) {
        // ç®€åŒ–å®ç°ï¼šè¿”å›å›ºå®šæ•°ç»„
        uint256[] memory chains = new uint256[](3);
        chains[0] = 1; // Ethereum
        chains[1] = 56; // BSC
        chains[2] = 137; // Polygon
        return chains;
    }
    
    function lockAsset(
        address asset,
        uint256 amount,
        uint256 targetChainId,
        address targetAddress
    ) external override returns (bytes32 lockId) {
        require(supportedChains[targetChainId], "Unsupported target chain");
        require(amount > 0, "Amount must be positive");
        
        // ç”Ÿæˆé”å®šID
        lockId = keccak256(abi.encodePacked(
            asset,
            amount,
            msg.sender,
            targetChainId,
            targetAddress,
            block.timestamp
        ));
        
        // è½¬ç§»èµ„äº§åˆ°åˆçº¦
        IERC20(asset).transferFrom(msg.sender, address(this), amount);
        
        // è®°å½•é”å®šä¿¡æ¯
        assetLocks[lockId] = AssetLock({
            asset: asset,
            amount: amount,
            locker: msg.sender,
            targetChainId: targetChainId,
            targetAddress: targetAddress,
            lockTime: block.timestamp,
            unlocked: false
        });
        
        emit AssetLocked(lockId, asset, amount, targetChainId);
    }
    
    function unlockAsset(
        bytes32 lockId,
        bytes calldata proof
    ) external override onlyAuthorizedBridge returns (bool) {
        AssetLock storage lock = assetLocks[lockId];
        require(lock.locker != address(0), "Lock not found");
        require(!lock.unlocked, "Already unlocked");
        
        // éªŒè¯è¯æ˜ï¼ˆç®€åŒ–å®ç°ï¼‰
        require(_verifyUnlockProof(lockId, proof), "Invalid proof");
        
        // è§£é”èµ„äº§
        lock.unlocked = true;
        IERC20(lock.asset).transfer(lock.targetAddress, lock.amount);
        
        emit AssetUnlocked(lockId, lock.asset, lock.amount);
        return true;
    }
    
    function sendMessage(
        uint256 targetChainId,
        bytes calldata message
    ) external override returns (bytes32 messageId) {
        require(supportedChains[targetChainId], "Unsupported target chain");
        
        messageId = keccak256(abi.encodePacked(
            chainId,
            targetChainId,
            msg.sender,
            message,
            block.timestamp
        ));
        
        emit MessageSent(messageId, targetChainId, message);
    }
    
    function receiveMessage(
        bytes32 messageId,
        bytes calldata message,
        bytes calldata proof
    ) external override onlyAuthorizedBridge returns (bool) {
        require(!processedMessages[messageId], "Message already processed");
        
        // éªŒè¯æ¶ˆæ¯è¯æ˜ï¼ˆç®€åŒ–å®ç°ï¼‰
        require(_verifyMessageProof(messageId, message, proof), "Invalid proof");
        
        // æ ‡è®°æ¶ˆæ¯ä¸ºå·²å¤„ç†
        processedMessages[messageId] = true;
        
        // å¤„ç†æ¶ˆæ¯å†…å®¹
        _processReceivedMessage(message);
        
        emit MessageReceived(messageId, 0, message); // sourceChainIdç®€åŒ–ä¸º0
        return true;
    }
    
    function _verifyUnlockProof(
        bytes32 lockId,
        bytes calldata proof
    ) internal pure returns (bool) {
        // ç®€åŒ–å®ç°ï¼šå®é™…åº”è¯¥éªŒè¯å¯†ç å­¦è¯æ˜
        return proof.length > 0;
    }
    
    function _verifyMessageProof(
        bytes32 messageId,
        bytes calldata message,
        bytes calldata proof
    ) internal pure returns (bool) {
        // ç®€åŒ–å®ç°ï¼šå®é™…åº”è¯¥éªŒè¯å¯†ç å­¦è¯æ˜
        return proof.length > 0;
    }
    
    function _processReceivedMessage(bytes calldata message) internal {
        // å¤„ç†æ¥æ”¶åˆ°çš„è·¨é“¾æ¶ˆæ¯
        // å¯ä»¥æ ¹æ®æ¶ˆæ¯å†…å®¹æ‰§è¡Œä¸åŒçš„æ“ä½œ
    }
    
    // ç®¡ç†å‡½æ•°
    function addSupportedChain(uint256 _chainId) external {
        supportedChains[_chainId] = true;
    }
    
    function addAuthorizedBridge(address bridge) external {
        authorizedBridges[bridge] = true;
    }
}
```

### å¤šé“¾èµ„äº§ç®¡ç†

```solidity
// å¤šé“¾èµ„äº§ç®¡ç†å™¨
contract MultiChainAssetManager {
    struct AssetInfo {
        string name;
        string symbol;
        uint8 decimals;
        mapping(uint256 => address) chainAddresses; // chainId => token address
        mapping(uint256 => bool) supportedChains;
        bool active;
    }
    
    struct ChainInfo {
        string name;
        uint256 chainId;
        address bridgeContract;
        bool active;
    }
    
    mapping(bytes32 => AssetInfo) public assets; // assetId => AssetInfo
    mapping(uint256 => ChainInfo) public chains;
    mapping(address => mapping(uint256 => uint256)) public userBalances; // user => chainId => balance
    
    bytes32[] public assetIds;
    uint256[] public supportedChainIds;
    
    event AssetRegistered(
        bytes32 indexed assetId,
        string name,
        string symbol
    );
    
    event ChainAdded(
        uint256 indexed chainId,
        string name,
        address bridgeContract
    );
    
    event AssetBridged(
        bytes32 indexed assetId,
        address indexed user,
        uint256 fromChainId,
        uint256 toChainId,
        uint256 amount
    );
    
    function registerAsset(
        bytes32 assetId,
        string calldata name,
        string calldata symbol,
        uint8 decimals
    ) external {
        require(!assets[assetId].active, "Asset already registered");
        
        AssetInfo storage asset = assets[assetId];
        asset.name = name;
        asset.symbol = symbol;
        asset.decimals = decimals;
        asset.active = true;
        
        assetIds.push(assetId);
        
        emit AssetRegistered(assetId, name, symbol);
    }
    
    function addChain(
        uint256 chainId,
        string calldata name,
        address bridgeContract
    ) external {
        require(!chains[chainId].active, "Chain already added");
        
        chains[chainId] = ChainInfo({
            name: name,
            chainId: chainId,
            bridgeContract: bridgeContract,
            active: true
        });
        
        supportedChainIds.push(chainId);
        
        emit ChainAdded(chainId, name, bridgeContract);
    }
    
    function addAssetToChain(
        bytes32 assetId,
        uint256 chainId,
        address tokenAddress
    ) external {
        require(assets[assetId].active, "Asset not registered");
        require(chains[chainId].active, "Chain not supported");
        
        AssetInfo storage asset = assets[assetId];
        asset.chainAddresses[chainId] = tokenAddress;
        asset.supportedChains[chainId] = true;
    }
    
    function bridgeAsset(
        bytes32 assetId,
        uint256 fromChainId,
        uint256 toChainId,
        uint256 amount,
        address targetAddress
    ) external {
        require(assets[assetId].active, "Asset not registered");
        require(assets[assetId].supportedChains[fromChainId], "Source chain not supported");
        require(assets[assetId].supportedChains[toChainId], "Target chain not supported");
        require(amount > 0, "Amount must be positive");
        
        // æ£€æŸ¥ç”¨æˆ·ä½™é¢ï¼ˆç®€åŒ–å®ç°ï¼‰
        require(userBalances[msg.sender][fromChainId] >= amount, "Insufficient balance");
        
        // æ‰£é™¤æºé“¾ä½™é¢
        userBalances[msg.sender][fromChainId] -= amount;
        
        // å¢åŠ ç›®æ ‡é“¾ä½™é¢
        userBalances[targetAddress][toChainId] += amount;
        
        emit AssetBridged(assetId, msg.sender, fromChainId, toChainId, amount);
    }
    
    function getAssetAddress(
        bytes32 assetId,
        uint256 chainId
    ) external view returns (address) {
        return assets[assetId].chainAddresses[chainId];
    }
    
    function isAssetSupportedOnChain(
        bytes32 assetId,
        uint256 chainId
    ) external view returns (bool) {
        return assets[assetId].supportedChains[chainId];
    }
    
    function getUserBalance(
        address user,
        uint256 chainId
    ) external view returns (uint256) {
        return userBalances[user][chainId];
    }
    
    function getAllAssets() external view returns (bytes32[] memory) {
        return assetIds;
    }
    
    function getAllChains() external view returns (uint256[] memory) {
        return supportedChainIds;
    }
}
```

---

## ğŸ”’ è·¨é“¾å®‰å…¨æœºåˆ¶

### å¤šé‡ç­¾åéªŒè¯

```solidity
// è·¨é“¾å¤šé‡ç­¾åéªŒè¯å™¨
contract CrossChainMultiSig {
    struct Validator {
        address validatorAddress;
        bool active;
        uint256 weight;
        string name;
    }
    
    struct Proposal {
        bytes32 proposalId;
        bytes data;
        uint256 targetChainId;
        address targetContract;
        uint256 createdAt;
        uint256 executedAt;
        bool executed;
        mapping(address => bool) signatures;
        uint256 signatureCount;
        uint256 totalWeight;
    }
    
    mapping(address => Validator) public validators;
    mapping(bytes32 => Proposal) public proposals;
    
    address[] public validatorList;
    uint256 public requiredWeight;
    uint256 public totalValidatorWeight;
    uint256 public proposalTimeout;
    
    event ValidatorAdded(address indexed validator, uint256 weight);
    event ValidatorRemoved(address indexed validator);
    event ProposalCreated(bytes32 indexed proposalId, uint256 targetChainId);
    event ProposalSigned(bytes32 indexed proposalId, address indexed validator);
    event ProposalExecuted(bytes32 indexed proposalId);
    
    modifier onlyValidator() {
        require(validators[msg.sender].active, "Not a validator");
        _;
    }
    
    modifier onlyValidProposal(bytes32 proposalId) {
        require(proposals[proposalId].createdAt > 0, "Proposal not found");
        require(!proposals[proposalId].executed, "Proposal already executed");
        require(
            block.timestamp <= proposals[proposalId].createdAt + proposalTimeout,
            "Proposal expired"
        );
        _;
    }
    
    constructor(uint256 _requiredWeight, uint256 _proposalTimeout) {
        requiredWeight = _requiredWeight;
        proposalTimeout = _proposalTimeout;
    }
    
    function addValidator(
        address validator,
        uint256 weight,
        string calldata name
    ) external {
        require(!validators[validator].active, "Validator already exists");
        require(weight > 0, "Weight must be positive");
        
        validators[validator] = Validator({
            validatorAddress: validator,
            active: true,
            weight: weight,
            name: name
        });
        
        validatorList.push(validator);
        totalValidatorWeight += weight;
        
        emit ValidatorAdded(validator, weight);
    }
    
    function removeValidator(address validator) external {
        require(validators[validator].active, "Validator not found");
        
        uint256 weight = validators[validator].weight;
        validators[validator].active = false;
        totalValidatorWeight -= weight;
        
        // ä»åˆ—è¡¨ä¸­ç§»é™¤
        for (uint256 i = 0; i < validatorList.length; i++) {
            if (validatorList[i] == validator) {
                validatorList[i] = validatorList[validatorList.length - 1];
                validatorList.pop();
                break;
            }
        }
        
        emit ValidatorRemoved(validator);
    }
    
    function createProposal(
        bytes calldata data,
        uint256 targetChainId,
        address targetContract
    ) external onlyValidator returns (bytes32 proposalId) {
        proposalId = keccak256(abi.encodePacked(
            data,
            targetChainId,
            targetContract,
            block.timestamp,
            msg.sender
        ));
        
        require(proposals[proposalId].createdAt == 0, "Proposal already exists");
        
        Proposal storage proposal = proposals[proposalId];
        proposal.proposalId = proposalId;
        proposal.data = data;
        proposal.targetChainId = targetChainId;
        proposal.targetContract = targetContract;
        proposal.createdAt = block.timestamp;
        proposal.executed = false;
        proposal.signatureCount = 0;
        proposal.totalWeight = 0;
        
        emit ProposalCreated(proposalId, targetChainId);
    }
    
    function signProposal(
        bytes32 proposalId
    ) external onlyValidator onlyValidProposal(proposalId) {
        Proposal storage proposal = proposals[proposalId];
        require(!proposal.signatures[msg.sender], "Already signed");
        
        proposal.signatures[msg.sender] = true;
        proposal.signatureCount++;
        proposal.totalWeight += validators[msg.sender].weight;
        
        emit ProposalSigned(proposalId, msg.sender);
        
        // æ£€æŸ¥æ˜¯å¦è¾¾åˆ°æ‰§è¡Œæ¡ä»¶
        if (proposal.totalWeight >= requiredWeight) {
            _executeProposal(proposalId);
        }
    }
    
    function _executeProposal(bytes32 proposalId) internal {
        Proposal storage proposal = proposals[proposalId];
        proposal.executed = true;
        proposal.executedAt = block.timestamp;
        
        // æ‰§è¡Œè·¨é“¾æ“ä½œï¼ˆç®€åŒ–å®ç°ï¼‰
        _performCrossChainOperation(
            proposal.data,
            proposal.targetChainId,
            proposal.targetContract
        );
        
        emit ProposalExecuted(proposalId);
    }
    
    function _performCrossChainOperation(
        bytes memory data,
        uint256 targetChainId,
        address targetContract
    ) internal {
        // å®é™…çš„è·¨é“¾æ“ä½œå®ç°
        // è¿™é‡Œå¯ä»¥è°ƒç”¨æ¡¥æ¥åˆçº¦æˆ–å‘é€è·¨é“¾æ¶ˆæ¯
    }
    
    function getProposalInfo(bytes32 proposalId) 
        external view returns (
            bytes memory data,
            uint256 targetChainId,
            address targetContract,
            uint256 createdAt,
            bool executed,
            uint256 signatureCount,
            uint256 totalWeight
        ) {
        Proposal storage proposal = proposals[proposalId];
        return (
            proposal.data,
            proposal.targetChainId,
            proposal.targetContract,
            proposal.createdAt,
            proposal.executed,
            proposal.signatureCount,
            proposal.totalWeight
        );
    }
    
    function hasValidatorSigned(
        bytes32 proposalId,
        address validator
    ) external view returns (bool) {
        return proposals[proposalId].signatures[validator];
    }
    
    function getValidators() external view returns (address[] memory) {
        return validatorList;
    }
}
```

---

## ğŸš€ å¤šé“¾éƒ¨ç½²ç­–ç•¥

### éƒ¨ç½²é…ç½®ç®¡ç†

```solidity
// å¤šé“¾éƒ¨ç½²é…ç½®
contract MultiChainDeploymentConfig {
    struct ChainConfig {
        uint256 chainId;
        string name;
        string rpcUrl;
        address deployer;
        uint256 gasPrice;
        uint256 gasLimit;
        bool active;
    }
    
    struct ContractConfig {
        string name;
        bytes bytecode;
        bytes constructorArgs;
        mapping(uint256 => address) deployedAddresses;
        mapping(uint256 => bool) deployed;
        bool active;
    }
    
    mapping(uint256 => ChainConfig) public chainConfigs;
    mapping(bytes32 => ContractConfig) public contractConfigs;
    
    uint256[] public supportedChains;
    bytes32[] public contractNames;
    
    event ChainConfigAdded(uint256 indexed chainId, string name);
    event ContractConfigAdded(bytes32 indexed contractName);
    event ContractDeployed(
        bytes32 indexed contractName,
        uint256 indexed chainId,
        address contractAddress
    );
    
    function addChainConfig(
        uint256 chainId,
        string calldata name,
        string calldata rpcUrl,
        address deployer,
        uint256 gasPrice,
        uint256 gasLimit
    ) external {
        require(!chainConfigs[chainId].active, "Chain config already exists");
        
        chainConfigs[chainId] = ChainConfig({
            chainId: chainId,
            name: name,
            rpcUrl: rpcUrl,
            deployer: deployer,
            gasPrice: gasPrice,
            gasLimit: gasLimit,
            active: true
        });
        
        supportedChains.push(chainId);
        
        emit ChainConfigAdded(chainId, name);
    }
    
    function addContractConfig(
        bytes32 contractName,
        bytes calldata bytecode,
        bytes calldata constructorArgs
    ) external {
        require(!contractConfigs[contractName].active, "Contract config already exists");
        
        ContractConfig storage config = contractConfigs[contractName];
        config.name = string(abi.encodePacked(contractName));
        config.bytecode = bytecode;
        config.constructorArgs = constructorArgs;
        config.active = true;
        
        contractNames.push(contractName);
        
        emit ContractConfigAdded(contractName);
    }
    
    function deployContract(
        bytes32 contractName,
        uint256 chainId
    ) external returns (address contractAddress) {
        require(chainConfigs[chainId].active, "Chain not supported");
        require(contractConfigs[contractName].active, "Contract config not found");
        require(
            !contractConfigs[contractName].deployed[chainId],
            "Contract already deployed on this chain"
        );
        
        ContractConfig storage config = contractConfigs[contractName];
        
        // éƒ¨ç½²åˆçº¦ï¼ˆç®€åŒ–å®ç°ï¼‰
        contractAddress = _deployContract(
            config.bytecode,
            config.constructorArgs
        );
        
        // è®°å½•éƒ¨ç½²ä¿¡æ¯
        config.deployedAddresses[chainId] = contractAddress;
        config.deployed[chainId] = true;
        
        emit ContractDeployed(contractName, chainId, contractAddress);
    }
    
    function _deployContract(
        bytes memory bytecode,
        bytes memory constructorArgs
    ) internal returns (address contractAddress) {
        bytes memory deploymentData = abi.encodePacked(bytecode, constructorArgs);
        
        assembly {
            contractAddress := create2(
                0,
                add(deploymentData, 0x20),
                mload(deploymentData),
                salt
            )
        }
        
        require(contractAddress != address(0), "Contract deployment failed");
    }
    
    function getContractAddress(
        bytes32 contractName,
        uint256 chainId
    ) external view returns (address) {
        return contractConfigs[contractName].deployedAddresses[chainId];
    }
    
    function isContractDeployed(
        bytes32 contractName,
        uint256 chainId
    ) external view returns (bool) {
        return contractConfigs[contractName].deployed[chainId];
    }
    
    function getSupportedChains() external view returns (uint256[] memory) {
        return supportedChains;
    }
    
    function getContractNames() external view returns (bytes32[] memory) {
        return contractNames;
    }
}
```

---

## ğŸ’¡ å­¦ä¹ å¿ƒå¾—ä¸æ€»ç»“

### è·¨é“¾æŠ€æœ¯è¦ç‚¹

1. **å®‰å…¨æ€§ä¼˜å…ˆ**
   - å¤šé‡ç­¾åéªŒè¯
   - æ—¶é—´é”æœºåˆ¶
   - å¼‚å¸¸å¤„ç†

2. **äº’æ“ä½œæ€§è®¾è®¡**
   - ç»Ÿä¸€æ¥å£æ ‡å‡†
   - é€‚é…å™¨æ¨¡å¼
   - åè®®å…¼å®¹æ€§

3. **æ€§èƒ½ä¼˜åŒ–**
   - æ‰¹é‡å¤„ç†
   - Gasä¼˜åŒ–
   - å¼‚æ­¥æ‰§è¡Œ

4. **ç”¨æˆ·ä½“éªŒ**
   - ç®€åŒ–æ“ä½œæµç¨‹
   - çŠ¶æ€é€æ˜åŒ–
   - é”™è¯¯æç¤ºå‹å¥½

### å®è·µå»ºè®®

1. **ä»ç®€å•å¼€å§‹**ï¼šå…ˆå®ç°åŸºç¡€çš„èµ„äº§è·¨é“¾ï¼Œå†æ‰©å±•åˆ°å¤æ‚åŠŸèƒ½
2. **å®‰å…¨æµ‹è¯•**ï¼šå……åˆ†æµ‹è¯•å„ç§è¾¹ç•Œæƒ…å†µå’Œæ”»å‡»åœºæ™¯
3. **æ¸è¿›éƒ¨ç½²**ï¼šå…ˆåœ¨æµ‹è¯•ç½‘éªŒè¯ï¼Œå†é€æ­¥éƒ¨ç½²åˆ°ä¸»ç½‘
4. **ç›‘æ§å‘Šè­¦**ï¼šå»ºç«‹å®Œå–„çš„ç›‘æ§å’Œåº”æ€¥å“åº”æœºåˆ¶

### æœªæ¥å‘å±•æ–¹å‘

1. **é›¶çŸ¥è¯†è¯æ˜**ï¼šæé«˜è·¨é“¾éªŒè¯æ•ˆç‡å’Œéšç§ä¿æŠ¤
2. **Layer 2é›†æˆ**ï¼šä¸å„ç§Layer 2è§£å†³æ–¹æ¡ˆçš„äº’æ“ä½œ
3. **å»ä¸­å¿ƒåŒ–æ²»ç†**ï¼šç¤¾åŒºé©±åŠ¨çš„è·¨é“¾åè®®å‡çº§
4. **æ ‡å‡†åŒ–åè®®**ï¼šè¡Œä¸šç»Ÿä¸€çš„è·¨é“¾æ ‡å‡†åˆ¶å®š

---

**å­¦ä¹ æ€»ç»“**: è·¨é“¾æŠ€æœ¯æ˜¯åŒºå—é“¾ç”Ÿæ€å‘å±•çš„å…³é”®åŸºç¡€è®¾æ–½ï¼Œéœ€è¦åœ¨å®‰å…¨æ€§ã€æ€§èƒ½å’Œç”¨æˆ·ä½“éªŒä¹‹é—´æ‰¾åˆ°å¹³è¡¡ã€‚é€šè¿‡æ·±å…¥ç†è§£å„ç§è·¨é“¾æœºåˆ¶çš„åŸç†å’Œå®ç°ï¼Œå¯ä»¥ä¸ºæ„å»ºæ›´åŠ äº’è”çš„åŒºå—é“¾ä¸–ç•Œè´¡çŒ®åŠ›é‡ã€‚

**å®è·µæ–¹å‘**: é‡ç‚¹å…³æ³¨è·¨é“¾å®‰å…¨æœºåˆ¶çš„è®¾è®¡å’Œå®ç°ï¼Œæ¢ç´¢æ–°çš„è·¨é“¾åè®®å’Œä¼˜åŒ–æ–¹æ¡ˆï¼Œä¸ºå¤šé“¾ç”Ÿæ€çš„å‘å±•åšå‡ºè´¡çŒ®ã€‚