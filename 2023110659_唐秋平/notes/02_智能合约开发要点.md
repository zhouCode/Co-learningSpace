# æ™ºèƒ½åˆçº¦å¼€å‘è¦ç‚¹

**å­¦ç”Ÿ**: å”ç§‹å¹³ (2023110659)  
**å­¦ä¹ ç‰¹è‰²**: æ³¨é‡æ•°æ®åˆ†æå’Œé“¾ä¸Šæ•°æ®å¤„ç†  
**é‡ç‚¹æ–¹å‘**: é“¾ä¸Šæ•°æ®åˆ†æä¸å¯è§†åŒ–  
**æ›´æ–°æ—¶é—´**: 2024å¹´12æœˆ19æ—¥

---

## ğŸ“‹ ç›®å½•

1. [é“¾ä¸Šæ•°æ®åŸºç¡€](#é“¾ä¸Šæ•°æ®åŸºç¡€)
2. [æ•°æ®å­˜å‚¨è®¾è®¡](#æ•°æ®å­˜å‚¨è®¾è®¡)
3. [äº‹ä»¶ä¸æ—¥å¿—åˆ†æ](#äº‹ä»¶ä¸æ—¥å¿—åˆ†æ)
4. [æ•°æ®æŸ¥è¯¢ä¼˜åŒ–](#æ•°æ®æŸ¥è¯¢ä¼˜åŒ–)
5. [é“¾ä¸Šæ•°æ®å¯è§†åŒ–](#é“¾ä¸Šæ•°æ®å¯è§†åŒ–)
6. [å®æ—¶æ•°æ®å¤„ç†](#å®æ—¶æ•°æ®å¤„ç†)

---

## ğŸ“Š é“¾ä¸Šæ•°æ®åŸºç¡€

### åŒºå—é“¾æ•°æ®ç»“æ„

```
åŒºå—é“¾æ•°æ®å±‚æ¬¡:
â”œâ”€â”€ åŒºå— (Block)
â”‚   â”œâ”€â”€ åŒºå—å¤´ (Block Header)
â”‚   â”‚   â”œâ”€â”€ çˆ¶åŒºå—å“ˆå¸Œ
â”‚   â”‚   â”œâ”€â”€ æ—¶é—´æˆ³
â”‚   â”‚   â”œâ”€â”€ éš¾åº¦å€¼
â”‚   â”‚   â””â”€â”€ Merkleæ ¹
â”‚   â””â”€â”€ äº¤æ˜“åˆ—è¡¨ (Transactions)
â”‚       â”œâ”€â”€ äº¤æ˜“å“ˆå¸Œ
â”‚       â”œâ”€â”€ å‘é€æ–¹åœ°å€
â”‚       â”œâ”€â”€ æ¥æ”¶æ–¹åœ°å€
â”‚       â”œâ”€â”€ äº¤æ˜“é‡‘é¢
â”‚       â””â”€â”€ Gasä¿¡æ¯
â”œâ”€â”€ çŠ¶æ€ (State)
â”‚   â”œâ”€â”€ è´¦æˆ·çŠ¶æ€
â”‚   â”œâ”€â”€ åˆçº¦å­˜å‚¨
â”‚   â””â”€â”€ ä»£ç å“ˆå¸Œ
â””â”€â”€ äº‹ä»¶æ—¥å¿— (Event Logs)
    â”œâ”€â”€ åˆçº¦åœ°å€
    â”œâ”€â”€ ä¸»é¢˜ (Topics)
    â””â”€â”€ æ•°æ® (Data)
```

### æ•°æ®ç±»å‹ä¸å­˜å‚¨æˆæœ¬

```solidity
contract DataAnalysisFoundation {
    // åŸºç¡€æ•°æ®ç±»å‹çš„å­˜å‚¨æˆæœ¬åˆ†æ
    uint256 public largeNumber;      // 32å­—èŠ‚ï¼Œ20,000 Gas (æ–°å€¼)
    uint128 public mediumNumber1;    // 16å­—èŠ‚
    uint128 public mediumNumber2;    // 16å­—èŠ‚ - ä¸ä¸Šé¢æ‰“åŒ…ï¼Œå…±äº«ä¸€ä¸ªæ§½
    
    address public userAddress;      // 20å­—èŠ‚
    uint96 public smallValue;        // 12å­—èŠ‚ - ä¸addressæ‰“åŒ…
    
    // åŠ¨æ€æ•°æ®ç±»å‹
    string public dynamicString;     // é•¿åº¦ + å†…å®¹
    bytes public dynamicBytes;       // é•¿åº¦ + å†…å®¹
    uint256[] public dynamicArray;   // é•¿åº¦ + å…ƒç´ 
    
    // æ˜ å°„ç±»å‹ - æœ€é€‚åˆå¤§é‡æ•°æ®å­˜å‚¨
    mapping(address => uint256) public balances;
    mapping(bytes32 => DataPoint) public dataPoints;
    
    struct DataPoint {
        uint256 timestamp;
        uint256 value;
        address source;
        bytes32 category;
    }
}
```

---

## ğŸ—„ï¸ æ•°æ®å­˜å‚¨è®¾è®¡

### é«˜æ•ˆçš„æ•°æ®ç»“æ„è®¾è®¡

```solidity
contract DataStorageOptimization {
    // âœ… æ—¶é—´åºåˆ—æ•°æ®å­˜å‚¨
    struct TimeSeriesData {
        uint32 timestamp;    // 4å­—èŠ‚ - è¶³å¤Ÿåˆ°2106å¹´
        uint224 value;       // 28å­—èŠ‚ - å¤§æ•°å€¼èŒƒå›´
    }
    
    // æŒ‰æ—¶é—´åˆ†æ¡¶å­˜å‚¨ï¼Œä¾¿äºæŸ¥è¯¢
    mapping(uint256 => TimeSeriesData[]) public dailyData; // æŒ‰å¤©åˆ†æ¡¶
    mapping(uint256 => TimeSeriesData[]) public hourlyData; // æŒ‰å°æ—¶åˆ†æ¡¶
    
    // âœ… å¤šç»´æ•°æ®ç´¢å¼•
    struct MultiDimensionalData {
        bytes32 id;
        uint256 timestamp;
        uint256 value;
        address user;
        uint8 category;
        uint8 status;
    }
    
    // å¤šä¸ªç´¢å¼•ç»´åº¦
    mapping(bytes32 => MultiDimensionalData) public dataById;
    mapping(address => bytes32[]) public dataByUser;
    mapping(uint8 => bytes32[]) public dataByCategory;
    mapping(uint256 => bytes32[]) public dataByTimestamp;
    
    // âœ… èšåˆæ•°æ®ç¼“å­˜
    struct AggregatedStats {
        uint256 count;
        uint256 sum;
        uint256 average;
        uint256 min;
        uint256 max;
        uint256 lastUpdated;
    }
    
    mapping(bytes32 => AggregatedStats) public aggregatedData;
    
    function updateAggregatedData(
        bytes32 key,
        uint256 newValue
    ) external {
        AggregatedStats storage stats = aggregatedData[key];
        
        if (stats.count == 0) {
            // é¦–æ¬¡æ•°æ®
            stats.count = 1;
            stats.sum = newValue;
            stats.average = newValue;
            stats.min = newValue;
            stats.max = newValue;
        } else {
            // æ›´æ–°èšåˆæ•°æ®
            stats.count++;
            stats.sum += newValue;
            stats.average = stats.sum / stats.count;
            
            if (newValue < stats.min) stats.min = newValue;
            if (newValue > stats.max) stats.max = newValue;
        }
        
        stats.lastUpdated = block.timestamp;
    }
}
```

### æ•°æ®åˆ†ç‰‡ä¸åˆ†å±‚å­˜å‚¨

```solidity
contract DataSharding {
    // æ•°æ®åˆ†ç‰‡ç­–ç•¥
    uint256 constant SHARD_SIZE = 1000;
    
    struct DataShard {
        uint256 shardId;
        uint256 startIndex;
        uint256 endIndex;
        bytes32 merkleRoot;
        bool isSealed;
    }
    
    mapping(uint256 => DataShard) public shards;
    mapping(uint256 => mapping(uint256 => bytes32)) public shardData;
    
    uint256 public currentShardId;
    uint256 public currentShardSize;
    
    function addDataToShard(bytes32 data) external {
        if (currentShardSize >= SHARD_SIZE) {
            _sealCurrentShard();
            _createNewShard();
        }
        
        shardData[currentShardId][currentShardSize] = data;
        currentShardSize++;
    }
    
    function _sealCurrentShard() internal {
        DataShard storage shard = shards[currentShardId];
        shard.endIndex = currentShardSize - 1;
        shard.merkleRoot = _calculateMerkleRoot(currentShardId);
        shard.isSealed = true;
    }
    
    function _createNewShard() internal {
        currentShardId++;
        currentShardSize = 0;
        
        shards[currentShardId] = DataShard({
            shardId: currentShardId,
            startIndex: 0,
            endIndex: 0,
            merkleRoot: bytes32(0),
            isSealed: false
        });
    }
    
    function _calculateMerkleRoot(uint256 shardId) internal view returns (bytes32) {
        // ç®€åŒ–çš„Merkleæ ¹è®¡ç®—
        bytes32 root = bytes32(0);
        for (uint256 i = 0; i < currentShardSize; i++) {
            root = keccak256(abi.encodePacked(root, shardData[shardId][i]));
        }
        return root;
    }
}
```

---

## ğŸ“ äº‹ä»¶ä¸æ—¥å¿—åˆ†æ

### äº‹ä»¶è®¾è®¡æœ€ä½³å®è·µ

```solidity
contract EventDesignPatterns {
    // âœ… ç»“æ„åŒ–äº‹ä»¶è®¾è®¡
    event DataPointCreated(
        bytes32 indexed id,           // ç´¢å¼•å­—æ®µ - ä¾¿äºè¿‡æ»¤
        address indexed creator,      // ç´¢å¼•å­—æ®µ - æŒ‰åˆ›å»ºè€…è¿‡æ»¤
        uint256 indexed timestamp,    // ç´¢å¼•å­—æ®µ - æŒ‰æ—¶é—´è¿‡æ»¤
        uint256 value,               // æ•°æ®å­—æ®µ
        bytes32 category,            // æ•°æ®å­—æ®µ
        string metadata              // é¢å¤–ä¿¡æ¯
    );
    
    event DataPointUpdated(
        bytes32 indexed id,
        uint256 oldValue,
        uint256 newValue,
        uint256 timestamp
    );
    
    event BatchDataProcessed(
        uint256 indexed batchId,
        uint256 processedCount,
        uint256 totalGasUsed,
        bytes32 batchHash
    );
    
    // âœ… åˆ†æå‹å¥½çš„äº‹ä»¶ç»“æ„
    struct AnalyticsEvent {
        bytes32 eventType;
        address user;
        uint256 timestamp;
        uint256 value;
        bytes data;
    }
    
    event AnalyticsDataEmitted(
        bytes32 indexed eventType,
        address indexed user,
        uint256 indexed timestamp,
        bytes data
    );
    
    function emitAnalyticsEvent(
        bytes32 eventType,
        uint256 value,
        bytes calldata additionalData
    ) external {
        emit AnalyticsDataEmitted(
            eventType,
            msg.sender,
            block.timestamp,
            abi.encode(value, additionalData)
        );
    }
    
    // âœ… çŠ¶æ€å˜åŒ–è¿½è¸ª
    event StateTransition(
        bytes32 indexed entityId,
        uint8 indexed fromState,
        uint8 indexed toState,
        uint256 timestamp,
        bytes32 reason
    );
    
    mapping(bytes32 => uint8) public entityStates;
    
    function transitionState(
        bytes32 entityId,
        uint8 newState,
        bytes32 reason
    ) external {
        uint8 oldState = entityStates[entityId];
        entityStates[entityId] = newState;
        
        emit StateTransition(
            entityId,
            oldState,
            newState,
            block.timestamp,
            reason
        );
    }
}
```

### æ—¥å¿—æŸ¥è¯¢ä¸è¿‡æ»¤

```javascript
// Web3.js äº‹ä»¶æŸ¥è¯¢ç¤ºä¾‹
const Web3 = require('web3');
const web3 = new Web3('https://mainnet.infura.io/v3/YOUR_PROJECT_ID');

class EventAnalyzer {
    constructor(contractAddress, contractABI) {
        this.contract = new web3.eth.Contract(contractABI, contractAddress);
    }
    
    // æŸ¥è¯¢ç‰¹å®šæ—¶é—´èŒƒå›´çš„äº‹ä»¶
    async getEventsByTimeRange(eventName, fromTimestamp, toTimestamp) {
        const fromBlock = await this.getBlockByTimestamp(fromTimestamp);
        const toBlock = await this.getBlockByTimestamp(toTimestamp);
        
        return await this.contract.getPastEvents(eventName, {
            fromBlock: fromBlock,
            toBlock: toBlock
        });
    }
    
    // æŒ‰ç”¨æˆ·è¿‡æ»¤äº‹ä»¶
    async getEventsByUser(eventName, userAddress, fromBlock = 0) {
        return await this.contract.getPastEvents(eventName, {
            filter: { user: userAddress },
            fromBlock: fromBlock,
            toBlock: 'latest'
        });
    }
    
    // æ‰¹é‡äº‹ä»¶åˆ†æ
    async analyzeEventPatterns(eventName, fromBlock, toBlock) {
        const events = await this.contract.getPastEvents(eventName, {
            fromBlock: fromBlock,
            toBlock: toBlock
        });
        
        const analysis = {
            totalEvents: events.length,
            uniqueUsers: new Set(),
            valueDistribution: {},
            timeDistribution: {},
            gasUsageStats: {
                total: 0,
                average: 0,
                min: Infinity,
                max: 0
            }
        };
        
        for (const event of events) {
            // ç”¨æˆ·åˆ†æ
            if (event.returnValues.user) {
                analysis.uniqueUsers.add(event.returnValues.user);
            }
            
            // å€¼åˆ†å¸ƒåˆ†æ
            const value = event.returnValues.value;
            if (value) {
                const range = this.getValueRange(value);
                analysis.valueDistribution[range] = 
                    (analysis.valueDistribution[range] || 0) + 1;
            }
            
            // æ—¶é—´åˆ†å¸ƒåˆ†æ
            const timestamp = event.returnValues.timestamp;
            if (timestamp) {
                const hour = new Date(timestamp * 1000).getHours();
                analysis.timeDistribution[hour] = 
                    (analysis.timeDistribution[hour] || 0) + 1;
            }
            
            // Gasä½¿ç”¨åˆ†æ
            const gasUsed = event.gasUsed || 0;
            analysis.gasUsageStats.total += gasUsed;
            analysis.gasUsageStats.min = Math.min(analysis.gasUsageStats.min, gasUsed);
            analysis.gasUsageStats.max = Math.max(analysis.gasUsageStats.max, gasUsed);
        }
        
        analysis.uniqueUsers = analysis.uniqueUsers.size;
        analysis.gasUsageStats.average = 
            analysis.gasUsageStats.total / events.length;
        
        return analysis;
    }
    
    getValueRange(value) {
        const val = parseInt(value);
        if (val < 1000) return '0-1K';
        if (val < 10000) return '1K-10K';
        if (val < 100000) return '10K-100K';
        return '100K+';
    }
    
    async getBlockByTimestamp(timestamp) {
        // äºŒåˆ†æŸ¥æ‰¾è·å–æ—¶é—´æˆ³å¯¹åº”çš„åŒºå—
        let low = 0;
        let high = await web3.eth.getBlockNumber();
        
        while (low <= high) {
            const mid = Math.floor((low + high) / 2);
            const block = await web3.eth.getBlock(mid);
            
            if (block.timestamp === timestamp) {
                return mid;
            } else if (block.timestamp < timestamp) {
                low = mid + 1;
            } else {
                high = mid - 1;
            }
        }
        
        return high; // è¿”å›æœ€æ¥è¿‘çš„åŒºå—
    }
}
```

---

## ğŸ” æ•°æ®æŸ¥è¯¢ä¼˜åŒ–

### é“¾ä¸ŠæŸ¥è¯¢ä¼˜åŒ–

```solidity
contract QueryOptimization {
    // âœ… åˆ†é¡µæŸ¥è¯¢æ”¯æŒ
    struct PaginatedResult {
        bytes32[] data;
        uint256 totalCount;
        uint256 currentPage;
        uint256 pageSize;
        bool hasNextPage;
    }
    
    bytes32[] public allData;
    
    function getPaginatedData(
        uint256 page,
        uint256 pageSize
    ) external view returns (PaginatedResult memory) {
        require(pageSize > 0 && pageSize <= 100, "Invalid page size");
        
        uint256 totalCount = allData.length;
        uint256 startIndex = page * pageSize;
        
        if (startIndex >= totalCount) {
            return PaginatedResult({
                data: new bytes32[](0),
                totalCount: totalCount,
                currentPage: page,
                pageSize: pageSize,
                hasNextPage: false
            });
        }
        
        uint256 endIndex = startIndex + pageSize;
        if (endIndex > totalCount) {
            endIndex = totalCount;
        }
        
        bytes32[] memory pageData = new bytes32[](endIndex - startIndex);
        for (uint256 i = startIndex; i < endIndex; i++) {
            pageData[i - startIndex] = allData[i];
        }
        
        return PaginatedResult({
            data: pageData,
            totalCount: totalCount,
            currentPage: page,
            pageSize: pageSize,
            hasNextPage: endIndex < totalCount
        });
    }
    
    // âœ… èŒƒå›´æŸ¥è¯¢ä¼˜åŒ–
    mapping(uint256 => bytes32[]) public dataByTimeRange;
    
    function getDataByTimeRange(
        uint256 startTime,
        uint256 endTime
    ) external view returns (bytes32[] memory) {
        require(startTime <= endTime, "Invalid time range");
        
        // æŒ‰å¤©åˆ†ç»„æŸ¥è¯¢
        uint256 startDay = startTime / 86400;
        uint256 endDay = endTime / 86400;
        
        uint256 totalCount = 0;
        
        // è®¡ç®—æ€»æ•°é‡
        for (uint256 day = startDay; day <= endDay; day++) {
            totalCount += dataByTimeRange[day].length;
        }
        
        bytes32[] memory result = new bytes32[](totalCount);
        uint256 index = 0;
        
        // æ”¶é›†æ•°æ®
        for (uint256 day = startDay; day <= endDay; day++) {
            bytes32[] memory dayData = dataByTimeRange[day];
            for (uint256 i = 0; i < dayData.length; i++) {
                result[index++] = dayData[i];
            }
        }
        
        return result;
    }
    
    // âœ… èšåˆæŸ¥è¯¢
    struct AggregateQuery {
        uint256 sum;
        uint256 count;
        uint256 average;
        uint256 min;
        uint256 max;
    }
    
    function getAggregateData(
        bytes32[] calldata keys
    ) external view returns (AggregateQuery memory) {
        require(keys.length > 0, "Empty keys array");
        
        AggregateQuery memory result;
        result.min = type(uint256).max;
        
        for (uint256 i = 0; i < keys.length; i++) {
            // å‡è®¾æœ‰ä¸€ä¸ªgetValueå‡½æ•°è·å–å€¼
            uint256 value = _getValue(keys[i]);
            
            result.sum += value;
            result.count++;
            
            if (value < result.min) result.min = value;
            if (value > result.max) result.max = value;
        }
        
        if (result.count > 0) {
            result.average = result.sum / result.count;
        }
        
        return result;
    }
    
    function _getValue(bytes32 key) internal pure returns (uint256) {
        // æ¨¡æ‹Ÿæ•°æ®è·å–
        return uint256(key) % 1000;
    }
}
```

---

## ğŸ“ˆ é“¾ä¸Šæ•°æ®å¯è§†åŒ–

### å‰ç«¯æ•°æ®å¯è§†åŒ–é›†æˆ

```javascript
// React + Chart.js æ•°æ®å¯è§†åŒ–ç»„ä»¶
import React, { useState, useEffect } from 'react';
import {
    Chart as ChartJS,
    CategoryScale,
    LinearScale,
    PointElement,
    LineElement,
    BarElement,
    Title,
    Tooltip,
    Legend,
} from 'chart.js';
import { Line, Bar, Doughnut } from 'react-chartjs-2';
import Web3 from 'web3';

ChartJS.register(
    CategoryScale,
    LinearScale,
    PointElement,
    LineElement,
    BarElement,
    Title,
    Tooltip,
    Legend
);

class BlockchainDataVisualizer {
    constructor(web3Provider, contractAddress, contractABI) {
        this.web3 = new Web3(web3Provider);
        this.contract = new this.web3.eth.Contract(contractABI, contractAddress);
    }
    
    // è·å–æ—¶é—´åºåˆ—æ•°æ®
    async getTimeSeriesData(eventName, timeRange) {
        const events = await this.contract.getPastEvents(eventName, {
            fromBlock: timeRange.fromBlock,
            toBlock: timeRange.toBlock
        });
        
        const timeSeriesData = {};
        
        for (const event of events) {
            const timestamp = event.returnValues.timestamp;
            const date = new Date(timestamp * 1000).toISOString().split('T')[0];
            const value = parseFloat(event.returnValues.value);
            
            if (!timeSeriesData[date]) {
                timeSeriesData[date] = { sum: 0, count: 0, values: [] };
            }
            
            timeSeriesData[date].sum += value;
            timeSeriesData[date].count += 1;
            timeSeriesData[date].values.push(value);
        }
        
        // è½¬æ¢ä¸ºå›¾è¡¨æ•°æ®æ ¼å¼
        const labels = Object.keys(timeSeriesData).sort();
        const data = labels.map(date => {
            const dayData = timeSeriesData[date];
            return {
                date,
                average: dayData.sum / dayData.count,
                total: dayData.sum,
                count: dayData.count,
                min: Math.min(...dayData.values),
                max: Math.max(...dayData.values)
            };
        });
        
        return { labels, data };
    }
    
    // è·å–ç”¨æˆ·æ´»åŠ¨åˆ†å¸ƒ
    async getUserActivityDistribution(eventName, fromBlock) {
        const events = await this.contract.getPastEvents(eventName, {
            fromBlock: fromBlock,
            toBlock: 'latest'
        });
        
        const userActivity = {};
        
        for (const event of events) {
            const user = event.returnValues.user;
            if (!userActivity[user]) {
                userActivity[user] = 0;
            }
            userActivity[user]++;
        }
        
        // æŒ‰æ´»åŠ¨æ¬¡æ•°æ’åº
        const sortedUsers = Object.entries(userActivity)
            .sort(([,a], [,b]) => b - a)
            .slice(0, 20); // å–å‰20å
        
        return {
            labels: sortedUsers.map(([user]) => `${user.slice(0, 6)}...${user.slice(-4)}`),
            data: sortedUsers.map(([, count]) => count)
        };
    }
    
    // è·å–Gasä½¿ç”¨åˆ†æ
    async getGasUsageAnalysis(fromBlock, toBlock) {
        const gasData = [];
        
        for (let blockNum = fromBlock; blockNum <= toBlock; blockNum += 100) {
            const block = await this.web3.eth.getBlock(blockNum, true);
            if (block && block.transactions) {
                let blockGasUsed = 0;
                let transactionCount = 0;
                
                for (const tx of block.transactions) {
                    if (tx.to === this.contract.options.address) {
                        const receipt = await this.web3.eth.getTransactionReceipt(tx.hash);
                        blockGasUsed += receipt.gasUsed;
                        transactionCount++;
                    }
                }
                
                if (transactionCount > 0) {
                    gasData.push({
                        blockNumber: blockNum,
                        timestamp: block.timestamp,
                        totalGasUsed: blockGasUsed,
                        averageGasPerTx: blockGasUsed / transactionCount,
                        transactionCount: transactionCount
                    });
                }
            }
        }
        
        return gasData;
    }
}

// Reactç»„ä»¶ç¤ºä¾‹
const DataAnalyticsDashboard = ({ contractAddress, contractABI }) => {
    const [timeSeriesData, setTimeSeriesData] = useState(null);
    const [userDistribution, setUserDistribution] = useState(null);
    const [gasAnalysis, setGasAnalysis] = useState(null);
    const [loading, setLoading] = useState(true);
    
    useEffect(() => {
        const loadData = async () => {
            try {
                const visualizer = new BlockchainDataVisualizer(
                    window.ethereum,
                    contractAddress,
                    contractABI
                );
                
                // å¹¶è¡ŒåŠ è½½æ•°æ®
                const [timeSeries, userDist, gasData] = await Promise.all([
                    visualizer.getTimeSeriesData('DataPointCreated', {
                        fromBlock: 'earliest',
                        toBlock: 'latest'
                    }),
                    visualizer.getUserActivityDistribution('DataPointCreated', 0),
                    visualizer.getGasUsageAnalysis(18000000, 18001000)
                ]);
                
                setTimeSeriesData(timeSeries);
                setUserDistribution(userDist);
                setGasAnalysis(gasData);
                setLoading(false);
            } catch (error) {
                console.error('Error loading data:', error);
                setLoading(false);
            }
        };
        
        loadData();
    }, [contractAddress, contractABI]);
    
    if (loading) {
        return <div>Loading analytics data...</div>;
    }
    
    const timeSeriesChartData = {
        labels: timeSeriesData?.labels || [],
        datasets: [
            {
                label: 'Daily Average Value',
                data: timeSeriesData?.data.map(d => d.average) || [],
                borderColor: 'rgb(75, 192, 192)',
                backgroundColor: 'rgba(75, 192, 192, 0.2)',
                tension: 0.1
            },
            {
                label: 'Daily Total',
                data: timeSeriesData?.data.map(d => d.total) || [],
                borderColor: 'rgb(255, 99, 132)',
                backgroundColor: 'rgba(255, 99, 132, 0.2)',
                yAxisID: 'y1'
            }
        ]
    };
    
    const userDistributionChartData = {
        labels: userDistribution?.labels || [],
        datasets: [
            {
                label: 'Activity Count',
                data: userDistribution?.data || [],
                backgroundColor: [
                    'rgba(255, 99, 132, 0.8)',
                    'rgba(54, 162, 235, 0.8)',
                    'rgba(255, 205, 86, 0.8)',
                    'rgba(75, 192, 192, 0.8)',
                    'rgba(153, 102, 255, 0.8)',
                ]
            }
        ]
    };
    
    return (
        <div className="analytics-dashboard">
            <h2>Blockchain Data Analytics Dashboard</h2>
            
            <div className="chart-container">
                <h3>Time Series Analysis</h3>
                <Line 
                    data={timeSeriesChartData}
                    options={{
                        responsive: true,
                        plugins: {
                            legend: {
                                position: 'top',
                            },
                            title: {
                                display: true,
                                text: 'Daily Data Trends'
                            }
                        },
                        scales: {
                            y: {
                                type: 'linear',
                                display: true,
                                position: 'left',
                            },
                            y1: {
                                type: 'linear',
                                display: true,
                                position: 'right',
                                grid: {
                                    drawOnChartArea: false,
                                },
                            }
                        }
                    }}
                />
            </div>
            
            <div className="chart-container">
                <h3>Top User Activity</h3>
                <Bar 
                    data={userDistributionChartData}
                    options={{
                        responsive: true,
                        plugins: {
                            legend: {
                                display: false
                            },
                            title: {
                                display: true,
                                text: 'Most Active Users'
                            }
                        }
                    }}
                />
            </div>
            
            <div className="stats-grid">
                <div className="stat-card">
                    <h4>Total Data Points</h4>
                    <p>{timeSeriesData?.data.reduce((sum, d) => sum + d.count, 0) || 0}</p>
                </div>
                <div className="stat-card">
                    <h4>Unique Users</h4>
                    <p>{userDistribution?.labels.length || 0}</p>
                </div>
                <div className="stat-card">
                    <h4>Average Daily Volume</h4>
                    <p>{timeSeriesData?.data.reduce((sum, d) => sum + d.total, 0) / timeSeriesData?.data.length || 0}</p>
                </div>
            </div>
        </div>
    );
};

export default DataAnalyticsDashboard;
```

---

## âš¡ å®æ—¶æ•°æ®å¤„ç†

### WebSocketäº‹ä»¶ç›‘å¬

```javascript
class RealTimeDataProcessor {
    constructor(wsProvider, contractAddress, contractABI) {
        this.web3 = new Web3(wsProvider);
        this.contract = new this.web3.eth.Contract(contractABI, contractAddress);
        this.eventSubscriptions = new Map();
        this.dataBuffer = [];
        this.processingInterval = null;
    }
    
    // å¯åŠ¨å®æ—¶ç›‘å¬
    startRealTimeMonitoring() {
        // ç›‘å¬æ–°çš„æ•°æ®ç‚¹åˆ›å»º
        const dataPointSubscription = this.contract.events.DataPointCreated({
            fromBlock: 'latest'
        })
        .on('data', (event) => {
            this.handleNewDataPoint(event);
        })
        .on('error', (error) => {
            console.error('DataPoint event error:', error);
        });
        
        this.eventSubscriptions.set('DataPointCreated', dataPointSubscription);
        
        // å¯åŠ¨æ‰¹é‡å¤„ç†
        this.processingInterval = setInterval(() => {
            this.processBatchData();
        }, 5000); // æ¯5ç§’å¤„ç†ä¸€æ¬¡
    }
    
    // å¤„ç†æ–°æ•°æ®ç‚¹
    handleNewDataPoint(event) {
        const dataPoint = {
            id: event.returnValues.id,
            creator: event.returnValues.creator,
            timestamp: parseInt(event.returnValues.timestamp),
            value: parseFloat(event.returnValues.value),
            category: event.returnValues.category,
            blockNumber: event.blockNumber,
            transactionHash: event.transactionHash
        };
        
        // æ·»åŠ åˆ°ç¼“å†²åŒº
        this.dataBuffer.push(dataPoint);
        
        // å®æ—¶åˆ†æ
        this.performRealTimeAnalysis(dataPoint);
        
        // è§¦å‘å®æ—¶æ›´æ–°äº‹ä»¶
        this.emit('newDataPoint', dataPoint);
    }
    
    // å®æ—¶åˆ†æ
    performRealTimeAnalysis(dataPoint) {
        // å¼‚å¸¸æ£€æµ‹
        if (this.isAnomalousValue(dataPoint.value)) {
            this.emit('anomalyDetected', {
                dataPoint,
                reason: 'Unusual value detected',
                severity: this.calculateAnomalySeverity(dataPoint.value)
            });
        }
        
        // è¶‹åŠ¿åˆ†æ
        const trend = this.calculateTrend(dataPoint);
        if (trend.significance > 0.8) {
            this.emit('trendAlert', {
                dataPoint,
                trend,
                direction: trend.direction
            });
        }
        
        // é¢‘ç‡åˆ†æ
        const frequency = this.analyzeFrequency(dataPoint.creator);
        if (frequency.isHighFrequency) {
            this.emit('highFrequencyActivity', {
                user: dataPoint.creator,
                frequency: frequency.rate,
                timeWindow: frequency.timeWindow
            });
        }
    }
    
    // æ‰¹é‡æ•°æ®å¤„ç†
    processBatchData() {
        if (this.dataBuffer.length === 0) return;
        
        const batchData = [...this.dataBuffer];
        this.dataBuffer = [];
        
        // æ‰¹é‡ç»Ÿè®¡åˆ†æ
        const batchStats = this.calculateBatchStatistics(batchData);
        
        // å­˜å‚¨åˆ°æœ¬åœ°æ•°æ®åº“æˆ–å‘é€åˆ°åç«¯
        this.storeBatchData(batchData, batchStats);
        
        // æ›´æ–°å®æ—¶ä»ªè¡¨æ¿
        this.emit('batchProcessed', {
            count: batchData.length,
            stats: batchStats,
            timestamp: Date.now()
        });
    }
    
    // å¼‚å¸¸å€¼æ£€æµ‹
    isAnomalousValue(value) {
        // ä½¿ç”¨Z-scoreæ–¹æ³•æ£€æµ‹å¼‚å¸¸å€¼
        const recentValues = this.getRecentValues(100);
        if (recentValues.length < 10) return false;
        
        const mean = recentValues.reduce((sum, v) => sum + v, 0) / recentValues.length;
        const variance = recentValues.reduce((sum, v) => sum + Math.pow(v - mean, 2), 0) / recentValues.length;
        const stdDev = Math.sqrt(variance);
        
        const zScore = Math.abs((value - mean) / stdDev);
        return zScore > 3; // 3-sigmaè§„åˆ™
    }
    
    // è¶‹åŠ¿è®¡ç®—
    calculateTrend(newDataPoint) {
        const recentData = this.getRecentDataPoints(50);
        if (recentData.length < 10) {
            return { direction: 'unknown', significance: 0 };
        }
        
        // ç®€å•çº¿æ€§å›å½’
        const n = recentData.length;
        const sumX = recentData.reduce((sum, _, i) => sum + i, 0);
        const sumY = recentData.reduce((sum, d) => sum + d.value, 0);
        const sumXY = recentData.reduce((sum, d, i) => sum + i * d.value, 0);
        const sumXX = recentData.reduce((sum, _, i) => sum + i * i, 0);
        
        const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
        const correlation = this.calculateCorrelation(recentData);
        
        return {
            direction: slope > 0 ? 'up' : 'down',
            slope: slope,
            significance: Math.abs(correlation)
        };
    }
    
    // é¢‘ç‡åˆ†æ
    analyzeFrequency(userAddress) {
        const timeWindow = 60 * 1000; // 1åˆ†é’Ÿ
        const currentTime = Date.now();
        const recentActivity = this.getUserRecentActivity(userAddress, timeWindow);
        
        const rate = recentActivity.length / (timeWindow / 1000); // æ¯ç§’é¢‘ç‡
        
        return {
            rate: rate,
            isHighFrequency: rate > 0.1, // æ¯ç§’è¶…è¿‡0.1æ¬¡
            timeWindow: timeWindow,
            activityCount: recentActivity.length
        };
    }
    
    // åœæ­¢ç›‘å¬
    stopRealTimeMonitoring() {
        // å–æ¶ˆæ‰€æœ‰äº‹ä»¶è®¢é˜…
        for (const [eventName, subscription] of this.eventSubscriptions) {
            subscription.unsubscribe();
        }
        this.eventSubscriptions.clear();
        
        // åœæ­¢æ‰¹é‡å¤„ç†
        if (this.processingInterval) {
            clearInterval(this.processingInterval);
            this.processingInterval = null;
        }
    }
    
    // äº‹ä»¶å‘å°„å™¨æ–¹æ³•
    emit(eventName, data) {
        // å®ç°äº‹ä»¶å‘å°„é€»è¾‘
        if (this.listeners && this.listeners[eventName]) {
            this.listeners[eventName].forEach(callback => callback(data));
        }
    }
    
    // è¾…åŠ©æ–¹æ³•
    getRecentValues(count) {
        return this.dataBuffer.slice(-count).map(d => d.value);
    }
    
    getRecentDataPoints(count) {
        return this.dataBuffer.slice(-count);
    }
    
    getUserRecentActivity(userAddress, timeWindow) {
        const cutoffTime = Date.now() - timeWindow;
        return this.dataBuffer.filter(d => 
            d.creator === userAddress && d.timestamp * 1000 > cutoffTime
        );
    }
    
    calculateCorrelation(data) {
        // å®ç°ç›¸å…³ç³»æ•°è®¡ç®—
        if (data.length < 2) return 0;
        
        const n = data.length;
        const indices = data.map((_, i) => i);
        const values = data.map(d => d.value);
        
        const meanX = indices.reduce((sum, x) => sum + x, 0) / n;
        const meanY = values.reduce((sum, y) => sum + y, 0) / n;
        
        let numerator = 0;
        let denomX = 0;
        let denomY = 0;
        
        for (let i = 0; i < n; i++) {
            const deltaX = indices[i] - meanX;
            const deltaY = values[i] - meanY;
            
            numerator += deltaX * deltaY;
            denomX += deltaX * deltaX;
            denomY += deltaY * deltaY;
        }
        
        const denominator = Math.sqrt(denomX * denomY);
        return denominator === 0 ? 0 : numerator / denominator;
    }
    
    calculateBatchStatistics(batchData) {
        if (batchData.length === 0) return {};
        
        const values = batchData.map(d => d.value);
        const sum = values.reduce((s, v) => s + v, 0);
        const mean = sum / values.length;
        const sortedValues = [...values].sort((a, b) => a - b);
        
        return {
            count: batchData.length,
            sum: sum,
            mean: mean,
            median: sortedValues[Math.floor(sortedValues.length / 2)],
            min: Math.min(...values),
            max: Math.max(...values),
            uniqueUsers: new Set(batchData.map(d => d.creator)).size,
            categories: this.getCategoryDistribution(batchData)
        };
    }
    
    getCategoryDistribution(batchData) {
        const distribution = {};
        for (const dataPoint of batchData) {
            const category = dataPoint.category;
            distribution[category] = (distribution[category] || 0) + 1;
        }
        return distribution;
    }
    
    storeBatchData(batchData, stats) {
        // å®ç°æ•°æ®å­˜å‚¨é€»è¾‘
        // å¯ä»¥å­˜å‚¨åˆ°æœ¬åœ°æ•°æ®åº“ã€å‘é€åˆ°åç«¯APIç­‰
        console.log('Storing batch data:', { batchData, stats });
    }
}
```

---

## ğŸ¯ å­¦ä¹ å¿ƒå¾—ä¸æ€»ç»“

ä½œä¸ºä¸“æ³¨äºæ•°æ®åˆ†æçš„å¼€å‘è€…ï¼Œæˆ‘æ·±åˆ»ç†è§£åˆ°ï¼š

### 1. æ•°æ®é©±åŠ¨çš„åˆçº¦è®¾è®¡
```
è®¾è®¡åŸåˆ™:
1. æ•°æ®ç»“æ„ä¼˜åŒ–
   â””â”€â”€ é€‰æ‹©åˆé€‚çš„å­˜å‚¨æ–¹å¼å’Œç´¢å¼•ç­–ç•¥
2. äº‹ä»¶è®¾è®¡
   â””â”€â”€ ç»“æ„åŒ–ã€å¯æŸ¥è¯¢çš„äº‹ä»¶æ—¥å¿—
3. æŸ¥è¯¢å‹å¥½
   â””â”€â”€ æ”¯æŒåˆ†é¡µã€è¿‡æ»¤ã€èšåˆæŸ¥è¯¢
4. å®æ—¶æ€§è€ƒè™‘
   â””â”€â”€ å¹³è¡¡å®æ—¶æ€§ä¸æˆæœ¬
```

### 2. åˆ†æç»´åº¦
- **æ—¶é—´ç»´åº¦**: è¶‹åŠ¿åˆ†æã€å‘¨æœŸæ€§æ£€æµ‹
- **ç”¨æˆ·ç»´åº¦**: è¡Œä¸ºåˆ†æã€æ´»è·ƒåº¦ç»Ÿè®¡
- **ä»·å€¼ç»´åº¦**: åˆ†å¸ƒåˆ†æã€å¼‚å¸¸æ£€æµ‹
- **ç½‘ç»œç»´åº¦**: Gasä½¿ç”¨ã€äº¤æ˜“æ¨¡å¼

### 3. æŠ€æœ¯æ ˆæ•´åˆ
- **é“¾ä¸Š**: Solidityåˆçº¦ + äº‹ä»¶æ—¥å¿—
- **é“¾ä¸‹**: Web3.js + æ•°æ®å¤„ç†
- **å­˜å‚¨**: IPFS + ä¼ ç»Ÿæ•°æ®åº“
- **å¯è§†åŒ–**: React + Chart.js
- **å®æ—¶**: WebSocket + æµå¤„ç†

### 4. æœªæ¥å‘å±•æ–¹å‘
- æœºå™¨å­¦ä¹ é›†æˆ
- è·¨é“¾æ•°æ®åˆ†æ
- éšç§ä¿æŠ¤åˆ†æ
- å»ä¸­å¿ƒåŒ–æ•°æ®å¸‚åœº

æ•°æ®æ˜¯åŒºå—é“¾ä¸–ç•Œçš„çŸ³æ²¹ï¼Œè€Œåˆ†ææ˜¯æç‚¼ä»·å€¼çš„ç‚¼æ²¹å‚ã€‚

---

**å¤‡æ³¨**: é“¾ä¸Šæ•°æ®åˆ†æéœ€è¦å¹³è¡¡æˆæœ¬ã€æ€§èƒ½å’Œå®ç”¨æ€§ï¼ŒæŒç»­ä¼˜åŒ–æŸ¥è¯¢ç­–ç•¥å’Œå¯è§†åŒ–æ–¹æ¡ˆæ˜¯å…³é”®ã€‚