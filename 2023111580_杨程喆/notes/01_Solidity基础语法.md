# SolidityÂü∫Á°ÄËØ≠Ê≥ïÂ≠¶‰π†Á¨îËÆ∞

**Â≠¶ÁîüÂßìÂêçÔºö** Êù®Á®ãÂñÜ  
**Â≠¶Âè∑Ôºö** 2023111580  
**Â≠¶‰π†Êó•ÊúüÔºö** 2024Âπ¥3Êúà15Êó• - 2024Âπ¥6Êúà20Êó•  
**ËØæÁ®ãÔºö** Âå∫ÂùóÈìæÊäÄÊúØ‰∏éÊô∫ËÉΩÂêàÁ∫¶ÂºÄÂèë  

---

## üßÆ Â≠¶‰π†ÁõÆÊ†á

‰Ωú‰∏∫‰∏ÄÂêçÊ≥®ÈáçÁÆóÊ≥ï‰ºòÂåñÂíåÊï∞ÊçÆÁªìÊûÑÁöÑÂºÄÂèëËÄÖÔºåÊàëÁöÑÂ≠¶‰π†ÈáçÁÇπÊòØÔºö
- Ê∑±ÂÖ•ÁêÜËß£Solidity‰∏≠ÁöÑÊï∞ÊçÆÁªìÊûÑÂÆûÁé∞ÂéüÁêÜ
- ÊéåÊè°Êô∫ËÉΩÂêàÁ∫¶‰∏≠ÁöÑÁÆóÊ≥ï‰ºòÂåñÊäÄÂ∑ß
- Êé¢Á¥¢È´òÊïàÁöÑÂ≠òÂÇ®ÂíåËÆ°ÁÆóÊ®°Âºè
- Á†îÁ©∂Â§çÊùÇÂ∫¶ÂàÜÊûêÂú®Âå∫ÂùóÈìæÁéØÂ¢É‰∏≠ÁöÑÂ∫îÁî®

---

## üîç Á¨¨‰∏ÄÁ´†ÔºöÊï∞ÊçÆÁªìÊûÑÊ∑±Â∫¶Ëß£Êûê

### 1.1 È´òÊïàÁöÑÊò†Â∞ÑÁªìÊûÑËÆæËÆ°

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

/**
 * @title AdvancedDataStructures
 * @dev È´òÁ∫ßÊï∞ÊçÆÁªìÊûÑÂÆûÁé∞‰∏é‰ºòÂåñ
 * @author Êù®Á®ãÂñÜ (2023111580)
 * @notice Êé¢Á¥¢Solidity‰∏≠È´òÊïàÊï∞ÊçÆÁªìÊûÑÁöÑËÆæËÆ°Ê®°Âºè
 */
contract AdvancedDataStructures {
    
    // ÂèåÂêëÈìæË°®ËäÇÁÇπÁªìÊûÑ
    struct DoublyLinkedNode {
        uint256 value;
        uint256 prev;        // Ââç‰∏Ä‰∏™ËäÇÁÇπID
        uint256 next;        // Âêé‰∏Ä‰∏™ËäÇÁÇπID
        bool exists;         // ËäÇÁÇπÊòØÂê¶Â≠òÂú®
    }
    
    // ÂèåÂêëÈìæË°®ÁªìÊûÑ
    struct DoublyLinkedList {
        uint256 head;        // Â§¥ËäÇÁÇπID
        uint256 tail;        // Â∞æËäÇÁÇπID
        uint256 size;        // ÈìæË°®Â§ßÂ∞è
        uint256 nextId;      // ‰∏ã‰∏Ä‰∏™ÂèØÁî®ID
        mapping(uint256 => DoublyLinkedNode) nodes;
    }
    
    // ‰ºòÂÖàÈòüÂàóËäÇÁÇπÔºàÊúÄÂ∞èÂ†ÜÂÆûÁé∞Ôºâ
    struct PriorityQueueNode {
        uint256 priority;    // ‰ºòÂÖàÁ∫ß
        uint256 value;       // ÂÄº
        uint256 timestamp;   // Êó∂Èó¥Êà≥ÔºàÁî®‰∫éÁõ∏Âêå‰ºòÂÖàÁ∫ßÁöÑÊéíÂ∫èÔºâ
    }
    
    // ‰ºòÂÖàÈòüÂàóÁªìÊûÑ
    struct PriorityQueue {
        PriorityQueueNode[] heap;
        mapping(uint256 => uint256) valueToIndex; // ÂÄºÂà∞Á¥¢ÂºïÁöÑÊò†Â∞Ñ
        uint256 size;
    }
    
    // Â∏ÉÈöÜËøáÊª§Âô®ÁªìÊûÑ
    struct BloomFilter {
        mapping(uint256 => uint256) bitArray;  // ‰ΩçÊï∞ÁªÑ
        uint256 size;                          // ËøáÊª§Âô®Â§ßÂ∞è
        uint256 hashCount;                     // ÂìàÂ∏åÂáΩÊï∞Êï∞Èáè
        uint256 elementCount;                  // Â∑≤Ê∑ªÂä†ÂÖÉÁ¥†Êï∞Èáè
    }
    
    // TrieÊ†ëËäÇÁÇπ
    struct TrieNode {
        mapping(bytes1 => uint256) children;  // Â≠êËäÇÁÇπÊò†Â∞Ñ
        bool isEndOfWord;                     // ÊòØÂê¶‰∏∫ÂçïËØçÁªìÂ∞æ
        uint256 value;                        // Â≠òÂÇ®ÁöÑÂÄº
    }
    
    // TrieÊ†ëÁªìÊûÑ
    struct Trie {
        mapping(uint256 => TrieNode) nodes;
        uint256 nextNodeId;
        uint256 root;
    }
    
    DoublyLinkedList private _linkedList;
    PriorityQueue private _priorityQueue;
    BloomFilter private _bloomFilter;
    Trie private _trie;
    
    // ‰∫ã‰ª∂ÂÆö‰πâ
    event NodeInserted(uint256 indexed nodeId, uint256 value, string operation);
    event NodeRemoved(uint256 indexed nodeId, uint256 value, string operation);
    event PriorityQueueOperation(string operation, uint256 priority, uint256 value);
    event BloomFilterQuery(bytes32 indexed element, bool exists, uint256 falsePositiveRate);
    
    constructor() {
        // ÂàùÂßãÂåñÂèåÂêëÈìæË°®
        _linkedList.nextId = 1;
        
        // ÂàùÂßãÂåñÂ∏ÉÈöÜËøáÊª§Âô®Ôºà1024‰ΩçÔºå3‰∏™ÂìàÂ∏åÂáΩÊï∞Ôºâ
        _bloomFilter.size = 1024;
        _bloomFilter.hashCount = 3;
        
        // ÂàùÂßãÂåñTrieÊ†ë
        _trie.nextNodeId = 1;
        _trie.root = 0;
    }
    
    /**
     * @dev ÂèåÂêëÈìæË°®ÊèíÂÖ•Êìç‰Ωú - O(1)Êó∂Èó¥Â§çÊùÇÂ∫¶
     * @param value Ë¶ÅÊèíÂÖ•ÁöÑÂÄº
     * @param position ÊèíÂÖ•‰ΩçÁΩÆÔºö0=Â§¥ÈÉ®Ôºå1=Â∞æÈÉ®
     * @return nodeId Êñ∞ËäÇÁÇπÁöÑID
     */
    function insertLinkedList(uint256 value, uint8 position) 
        external 
        returns (uint256 nodeId) 
    {
        nodeId = _linkedList.nextId++;
        DoublyLinkedNode storage newNode = _linkedList.nodes[nodeId];
        
        newNode.value = value;
        newNode.exists = true;
        
        if (_linkedList.size == 0) {
            // Á¨¨‰∏Ä‰∏™ËäÇÁÇπ
            _linkedList.head = nodeId;
            _linkedList.tail = nodeId;
            newNode.prev = 0;
            newNode.next = 0;
        } else if (position == 0) {
            // ÊèíÂÖ•Â§¥ÈÉ®
            DoublyLinkedNode storage oldHead = _linkedList.nodes[_linkedList.head];
            newNode.next = _linkedList.head;
            newNode.prev = 0;
            oldHead.prev = nodeId;
            _linkedList.head = nodeId;
        } else {
            // ÊèíÂÖ•Â∞æÈÉ®
            DoublyLinkedNode storage oldTail = _linkedList.nodes[_linkedList.tail];
            newNode.prev = _linkedList.tail;
            newNode.next = 0;
            oldTail.next = nodeId;
            _linkedList.tail = nodeId;
        }
        
        _linkedList.size++;
        
        emit NodeInserted(nodeId, value, "LinkedList Insert");
    }
    
    /**
     * @dev ÂèåÂêëÈìæË°®Âà†Èô§Êìç‰Ωú - O(1)Êó∂Èó¥Â§çÊùÇÂ∫¶
     * @param nodeId Ë¶ÅÂà†Èô§ÁöÑËäÇÁÇπID
     */
    function removeLinkedList(uint256 nodeId) external {
        DoublyLinkedNode storage node = _linkedList.nodes[nodeId];
        require(node.exists, "Node does not exist");
        
        uint256 value = node.value;
        
        if (_linkedList.size == 1) {
            // ÂîØ‰∏ÄËäÇÁÇπ
            _linkedList.head = 0;
            _linkedList.tail = 0;
        } else if (nodeId == _linkedList.head) {
            // Âà†Èô§Â§¥ËäÇÁÇπ
            _linkedList.head = node.next;
            _linkedList.nodes[node.next].prev = 0;
        } else if (nodeId == _linkedList.tail) {
            // Âà†Èô§Â∞æËäÇÁÇπ
            _linkedList.tail = node.prev;
            _linkedList.nodes[node.prev].next = 0;
        } else {
            // Âà†Èô§‰∏≠Èó¥ËäÇÁÇπ
            _linkedList.nodes[node.prev].next = node.next;
            _linkedList.nodes[node.next].prev = node.prev;
        }
        
        delete _linkedList.nodes[nodeId];
        _linkedList.size--;
        
        emit NodeRemoved(nodeId, value, "LinkedList Remove");
    }
    
    /**
     * @dev ‰ºòÂÖàÈòüÂàóÊèíÂÖ• - O(log n)Êó∂Èó¥Â§çÊùÇÂ∫¶
     * @param priority ‰ºòÂÖàÁ∫ßÔºàÊï∞ÂÄºË∂äÂ∞è‰ºòÂÖàÁ∫ßË∂äÈ´òÔºâ
     * @param value ÂÄº
     */
    function enqueue(uint256 priority, uint256 value) external {
        PriorityQueueNode memory newNode = PriorityQueueNode({
            priority: priority,
            value: value,
            timestamp: block.timestamp
        });
        
        _priorityQueue.heap.push(newNode);
        _priorityQueue.valueToIndex[value] = _priorityQueue.size;
        _priorityQueue.size++;
        
        // ‰∏äÊµÆÊìç‰Ωú
        _heapifyUp(_priorityQueue.size - 1);
        
        emit PriorityQueueOperation("Enqueue", priority, value);
    }
    
    /**
     * @dev ‰ºòÂÖàÈòüÂàóÂá∫Èòü - O(log n)Êó∂Èó¥Â§çÊùÇÂ∫¶
     * @return priority ÊúÄÈ´ò‰ºòÂÖàÁ∫ß
     * @return value ÂØπÂ∫îÁöÑÂÄº
     */
    function dequeue() external returns (uint256 priority, uint256 value) {
        require(_priorityQueue.size > 0, "Priority queue is empty");
        
        PriorityQueueNode memory root = _priorityQueue.heap[0];
        priority = root.priority;
        value = root.value;
        
        // Â∞ÜÊúÄÂêé‰∏Ä‰∏™ÂÖÉÁ¥†ÁßªÂà∞Ê†πÈÉ®
        _priorityQueue.heap[0] = _priorityQueue.heap[_priorityQueue.size - 1];
        _priorityQueue.heap.pop();
        _priorityQueue.size--;
        
        if (_priorityQueue.size > 0) {
            // ‰∏ãÊ≤âÊìç‰Ωú
            _heapifyDown(0);
        }
        
        delete _priorityQueue.valueToIndex[value];
        
        emit PriorityQueueOperation("Dequeue", priority, value);
    }
    
    /**
     * @dev Â†Ü‰∏äÊµÆÊìç‰Ωú
     * @param index ÂΩìÂâçÁ¥¢Âºï
     */
    function _heapifyUp(uint256 index) internal {
        while (index > 0) {
            uint256 parentIndex = (index - 1) / 2;
            
            if (_compareNodes(_priorityQueue.heap[index], _priorityQueue.heap[parentIndex])) {
                // ‰∫§Êç¢ËäÇÁÇπ
                PriorityQueueNode memory temp = _priorityQueue.heap[index];
                _priorityQueue.heap[index] = _priorityQueue.heap[parentIndex];
                _priorityQueue.heap[parentIndex] = temp;
                
                // Êõ¥Êñ∞Á¥¢ÂºïÊò†Â∞Ñ
                _priorityQueue.valueToIndex[_priorityQueue.heap[index].value] = index;
                _priorityQueue.valueToIndex[_priorityQueue.heap[parentIndex].value] = parentIndex;
                
                index = parentIndex;
            } else {
                break;
            }
        }
    }
    
    /**
     * @dev Â†Ü‰∏ãÊ≤âÊìç‰Ωú
     * @param index ÂΩìÂâçÁ¥¢Âºï
     */
    function _heapifyDown(uint256 index) internal {
        while (true) {
            uint256 leftChild = 2 * index + 1;
            uint256 rightChild = 2 * index + 2;
            uint256 smallest = index;
            
            if (leftChild < _priorityQueue.size && 
                _compareNodes(_priorityQueue.heap[leftChild], _priorityQueue.heap[smallest])) {
                smallest = leftChild;
            }
            
            if (rightChild < _priorityQueue.size && 
                _compareNodes(_priorityQueue.heap[rightChild], _priorityQueue.heap[smallest])) {
                smallest = rightChild;
            }
            
            if (smallest != index) {
                // ‰∫§Êç¢ËäÇÁÇπ
                PriorityQueueNode memory temp = _priorityQueue.heap[index];
                _priorityQueue.heap[index] = _priorityQueue.heap[smallest];
                _priorityQueue.heap[smallest] = temp;
                
                // Êõ¥Êñ∞Á¥¢ÂºïÊò†Â∞Ñ
                _priorityQueue.valueToIndex[_priorityQueue.heap[index].value] = index;
                _priorityQueue.valueToIndex[_priorityQueue.heap[smallest].value] = smallest;
                
                index = smallest;
            } else {
                break;
            }
        }
    }
    
    /**
     * @dev ÊØîËæÉ‰∏§‰∏™‰ºòÂÖàÈòüÂàóËäÇÁÇπ
     * @param a ËäÇÁÇπA
     * @param b ËäÇÁÇπB
     * @return Â¶ÇÊûúAÁöÑ‰ºòÂÖàÁ∫ßÈ´ò‰∫éBËøîÂõûtrue
     */
    function _compareNodes(PriorityQueueNode memory a, PriorityQueueNode memory b) 
        internal 
        pure 
        returns (bool) 
    {
        if (a.priority != b.priority) {
            return a.priority < b.priority; // Êï∞ÂÄºË∂äÂ∞è‰ºòÂÖàÁ∫ßË∂äÈ´ò
        }
        return a.timestamp < b.timestamp; // Áõ∏Âêå‰ºòÂÖàÁ∫ßÊó∂ÔºåÊó∂Èó¥Êà≥Ë∂äÂ∞è‰ºòÂÖàÁ∫ßË∂äÈ´ò
    }
    
    /**
     * @dev Â∏ÉÈöÜËøáÊª§Âô®Ê∑ªÂä†ÂÖÉÁ¥† - O(k)Êó∂Èó¥Â§çÊùÇÂ∫¶Ôºåk‰∏∫ÂìàÂ∏åÂáΩÊï∞Êï∞Èáè
     * @param element Ë¶ÅÊ∑ªÂä†ÁöÑÂÖÉÁ¥†
     */
    function bloomFilterAdd(bytes32 element) external {
        for (uint256 i = 0; i < _bloomFilter.hashCount; i++) {
            uint256 hash = _hash(element, i) % _bloomFilter.size;
            uint256 wordIndex = hash / 256;
            uint256 bitIndex = hash % 256;
            _bloomFilter.bitArray[wordIndex] |= (1 << bitIndex);
        }
        _bloomFilter.elementCount++;
    }
    
    /**
     * @dev Â∏ÉÈöÜËøáÊª§Âô®Êü•ËØ¢ÂÖÉÁ¥† - O(k)Êó∂Èó¥Â§çÊùÇÂ∫¶
     * @param element Ë¶ÅÊü•ËØ¢ÁöÑÂÖÉÁ¥†
     * @return exists ÂèØËÉΩÂ≠òÂú®ÔºàtrueÔºâÊàñÁ°ÆÂÆö‰∏çÂ≠òÂú®ÔºàfalseÔºâ
     * @return falsePositiveRate ÂΩìÂâçÂÅáÈò≥ÊÄßÁéáÔºà‰º∞ÁÆóÔºâ
     */
    function bloomFilterQuery(bytes32 element) 
        external 
        returns (bool exists, uint256 falsePositiveRate) 
    {
        exists = true;
        
        for (uint256 i = 0; i < _bloomFilter.hashCount; i++) {
            uint256 hash = _hash(element, i) % _bloomFilter.size;
            uint256 wordIndex = hash / 256;
            uint256 bitIndex = hash % 256;
            
            if ((_bloomFilter.bitArray[wordIndex] & (1 << bitIndex)) == 0) {
                exists = false;
                break;
            }
        }
        
        // ‰º∞ÁÆóÂÅáÈò≥ÊÄßÁéáÔºö(1 - e^(-kn/m))^k
        // ÁÆÄÂåñËÆ°ÁÆóÔºö‰ΩøÁî®Ëøë‰ººÂÖ¨Âºè
        if (_bloomFilter.elementCount > 0) {
            uint256 ratio = (_bloomFilter.hashCount * _bloomFilter.elementCount * 1000) / _bloomFilter.size;
            falsePositiveRate = ratio > 1000 ? 500 : (ratio * ratio) / 2000; // ÁÆÄÂåñÁöÑÂÅáÈò≥ÊÄßÁéá‰º∞ÁÆó
        }
        
        emit BloomFilterQuery(element, exists, falsePositiveRate);
    }
    
    /**
     * @dev TrieÊ†ëÊèíÂÖ• - O(m)Êó∂Èó¥Â§çÊùÇÂ∫¶Ôºåm‰∏∫ÈîÆÁöÑÈïøÂ∫¶
     * @param key ÈîÆ
     * @param value ÂÄº
     */
    function trieInsert(bytes memory key, uint256 value) external {
        uint256 currentNode = _trie.root;
        
        // Â¶ÇÊûúÊ†πËäÇÁÇπ‰∏çÂ≠òÂú®ÔºåÂàõÂª∫ÂÆÉ
        if (currentNode == 0) {
            currentNode = _trie.nextNodeId++;
            _trie.root = currentNode;
        }
        
        for (uint256 i = 0; i < key.length; i++) {
            bytes1 char = key[i];
            uint256 childNode = _trie.nodes[currentNode].children[char];
            
            if (childNode == 0) {
                // ÂàõÂª∫Êñ∞ÁöÑÂ≠êËäÇÁÇπ
                childNode = _trie.nextNodeId++;
                _trie.nodes[currentNode].children[char] = childNode;
            }
            
            currentNode = childNode;
        }
        
        _trie.nodes[currentNode].isEndOfWord = true;
        _trie.nodes[currentNode].value = value;
    }
    
    /**
     * @dev TrieÊ†ëÊü•ËØ¢ - O(m)Êó∂Èó¥Â§çÊùÇÂ∫¶
     * @param key ÈîÆ
     * @return exists ÊòØÂê¶Â≠òÂú®
     * @return value ÂØπÂ∫îÁöÑÂÄº
     */
    function trieQuery(bytes memory key) 
        external 
        view 
        returns (bool exists, uint256 value) 
    {
        uint256 currentNode = _trie.root;
        
        if (currentNode == 0) {
            return (false, 0);
        }
        
        for (uint256 i = 0; i < key.length; i++) {
            bytes1 char = key[i];
            currentNode = _trie.nodes[currentNode].children[char];
            
            if (currentNode == 0) {
                return (false, 0);
            }
        }
        
        exists = _trie.nodes[currentNode].isEndOfWord;
        value = _trie.nodes[currentNode].value;
    }
    
    /**
     * @dev ÂìàÂ∏åÂáΩÊï∞ÔºàÁî®‰∫éÂ∏ÉÈöÜËøáÊª§Âô®Ôºâ
     * @param data Êï∞ÊçÆ
     * @param seed ÁßçÂ≠ê
     * @return ÂìàÂ∏åÂÄº
     */
    function _hash(bytes32 data, uint256 seed) internal pure returns (uint256) {
        return uint256(keccak256(abi.encodePacked(data, seed)));
    }
    
    // Êü•ËØ¢ÂáΩÊï∞
    function getLinkedListSize() external view returns (uint256) {
        return _linkedList.size;
    }
    
    function getPriorityQueueSize() external view returns (uint256) {
        return _priorityQueue.size;
    }
    
    function getBloomFilterStats() external view returns (uint256 size, uint256 elementCount) {
        return (_bloomFilter.size, _bloomFilter.elementCount);
    }
    
    // ‰∏™‰∫∫ÂøÉÂæóÔºöÊï∞ÊçÆÁªìÊûÑÁöÑÈÄâÊã©Áõ¥Êé•ÂΩ±ÂìçÁÆóÊ≥ïÊïàÁéá
    // Âú®Âå∫ÂùóÈìæÁéØÂ¢É‰∏≠ÔºåGasÊàêÊú¨ËÆ©Êàë‰ª¨Êõ¥Âä†ÈáçËßÜÁÆóÊ≥ïÂ§çÊùÇÂ∫¶
}
```

### 1.2 È´òÊïàÊéíÂ∫èÁÆóÊ≥ïÂÆûÁé∞

```solidity
contract OptimizedSorting {
    
    // ÊéíÂ∫èÁªìÊûúÁªìÊûÑ
    struct SortResult {
        uint256[] sortedArray;
        uint256 comparisons;     // ÊØîËæÉÊ¨°Êï∞
        uint256 swaps;          // ‰∫§Êç¢Ê¨°Êï∞
        uint256 gasUsed;        // Ê∂àËÄóÁöÑGas
        string algorithm;       // ‰ΩøÁî®ÁöÑÁÆóÊ≥ï
    }
    
    event SortCompleted(
        string algorithm,
        uint256 arrayLength,
        uint256 comparisons,
        uint256 swaps,
        uint256 gasUsed
    );
    
    /**
     * @dev Âø´ÈÄüÊéíÂ∫èÂÆûÁé∞ - Âπ≥ÂùáO(n log n)ÔºåÊúÄÂùèO(n¬≤)
     * @param arr ÂæÖÊéíÂ∫èÊï∞ÁªÑ
     * @return result ÊéíÂ∫èÁªìÊûú
     */
    function quickSort(uint256[] memory arr) 
        external 
        returns (SortResult memory result) 
    {
        uint256 gasStart = gasleft();
        uint256 comparisons = 0;
        uint256 swaps = 0;
        
        if (arr.length <= 1) {
            return SortResult({
                sortedArray: arr,
                comparisons: 0,
                swaps: 0,
                gasUsed: gasStart - gasleft(),
                algorithm: "QuickSort"
            });
        }
        
        _quickSortRecursive(arr, 0, int256(arr.length - 1), comparisons, swaps);
        
        uint256 gasUsed = gasStart - gasleft();
        
        result = SortResult({
            sortedArray: arr,
            comparisons: comparisons,
            swaps: swaps,
            gasUsed: gasUsed,
            algorithm: "QuickSort"
        });
        
        emit SortCompleted("QuickSort", arr.length, comparisons, swaps, gasUsed);
    }
    
    /**
     * @dev Âø´ÈÄüÊéíÂ∫èÈÄíÂΩíÂÆûÁé∞
     */
    function _quickSortRecursive(
        uint256[] memory arr,
        int256 low,
        int256 high,
        uint256 comparisons,
        uint256 swaps
    ) internal {
        if (low < high) {
            int256 pivotIndex = _partition(arr, low, high, comparisons, swaps);
            _quickSortRecursive(arr, low, pivotIndex - 1, comparisons, swaps);
            _quickSortRecursive(arr, pivotIndex + 1, high, comparisons, swaps);
        }
    }
    
    /**
     * @dev ÂàÜÂå∫ÂáΩÊï∞
     */
    function _partition(
        uint256[] memory arr,
        int256 low,
        int256 high,
        uint256 comparisons,
        uint256 swaps
    ) internal returns (int256) {
        uint256 pivot = arr[uint256(high)];
        int256 i = low - 1;
        
        for (int256 j = low; j < high; j++) {
            comparisons++;
            if (arr[uint256(j)] <= pivot) {
                i++;
                if (i != j) {
                    _swap(arr, uint256(i), uint256(j));
                    swaps++;
                }
            }
        }
        
        if (i + 1 != high) {
            _swap(arr, uint256(i + 1), uint256(high));
            swaps++;
        }
        
        return i + 1;
    }
    
    /**
     * @dev ÂΩíÂπ∂ÊéíÂ∫èÂÆûÁé∞ - O(n log n)Á®≥ÂÆöÊéíÂ∫è
     * @param arr ÂæÖÊéíÂ∫èÊï∞ÁªÑ
     * @return result ÊéíÂ∫èÁªìÊûú
     */
    function mergeSort(uint256[] memory arr) 
        external 
        returns (SortResult memory result) 
    {
        uint256 gasStart = gasleft();
        uint256 comparisons = 0;
        
        if (arr.length <= 1) {
            return SortResult({
                sortedArray: arr,
                comparisons: 0,
                swaps: 0,
                gasUsed: gasStart - gasleft(),
                algorithm: "MergeSort"
            });
        }
        
        uint256[] memory temp = new uint256[](arr.length);
        _mergeSortRecursive(arr, temp, 0, arr.length - 1, comparisons);
        
        uint256 gasUsed = gasStart - gasleft();
        
        result = SortResult({
            sortedArray: arr,
            comparisons: comparisons,
            swaps: 0, // ÂΩíÂπ∂ÊéíÂ∫è‰∏çÊ∂âÂèä‰∫§Êç¢ÔºåËÄåÊòØÂ§çÂà∂
            gasUsed: gasUsed,
            algorithm: "MergeSort"
        });
        
        emit SortCompleted("MergeSort", arr.length, comparisons, 0, gasUsed);
    }
    
    /**
     * @dev ÂΩíÂπ∂ÊéíÂ∫èÈÄíÂΩíÂÆûÁé∞
     */
    function _mergeSortRecursive(
        uint256[] memory arr,
        uint256[] memory temp,
        uint256 left,
        uint256 right,
        uint256 comparisons
    ) internal {
        if (left < right) {
            uint256 mid = left + (right - left) / 2;
            
            _mergeSortRecursive(arr, temp, left, mid, comparisons);
            _mergeSortRecursive(arr, temp, mid + 1, right, comparisons);
            _merge(arr, temp, left, mid, right, comparisons);
        }
    }
    
    /**
     * @dev ÂêàÂπ∂ÂáΩÊï∞
     */
    function _merge(
        uint256[] memory arr,
        uint256[] memory temp,
        uint256 left,
        uint256 mid,
        uint256 right,
        uint256 comparisons
    ) internal {
        // Â§çÂà∂Âà∞‰∏¥Êó∂Êï∞ÁªÑ
        for (uint256 i = left; i <= right; i++) {
            temp[i] = arr[i];
        }
        
        uint256 i = left;
        uint256 j = mid + 1;
        uint256 k = left;
        
        // ÂêàÂπ∂‰∏§‰∏™ÊúâÂ∫èÊï∞ÁªÑ
        while (i <= mid && j <= right) {
            comparisons++;
            if (temp[i] <= temp[j]) {
                arr[k] = temp[i];
                i++;
            } else {
                arr[k] = temp[j];
                j++;
            }
            k++;
        }
        
        // Â§çÂà∂Ââ©‰ΩôÂÖÉÁ¥†
        while (i <= mid) {
            arr[k] = temp[i];
            i++;
            k++;
        }
        
        while (j <= right) {
            arr[k] = temp[j];
            j++;
            k++;
        }
    }
    
    /**
     * @dev Â†ÜÊéíÂ∫èÂÆûÁé∞ - O(n log n)ÂéüÂú∞ÊéíÂ∫è
     * @param arr ÂæÖÊéíÂ∫èÊï∞ÁªÑ
     * @return result ÊéíÂ∫èÁªìÊûú
     */
    function heapSort(uint256[] memory arr) 
        external 
        returns (SortResult memory result) 
    {
        uint256 gasStart = gasleft();
        uint256 comparisons = 0;
        uint256 swaps = 0;
        
        if (arr.length <= 1) {
            return SortResult({
                sortedArray: arr,
                comparisons: 0,
                swaps: 0,
                gasUsed: gasStart - gasleft(),
                algorithm: "HeapSort"
            });
        }
        
        // ÊûÑÂª∫ÊúÄÂ§ßÂ†Ü
        for (int256 i = int256(arr.length / 2) - 1; i >= 0; i--) {
            _heapify(arr, arr.length, uint256(i), comparisons, swaps);
        }
        
        // ÈÄê‰∏™ÊèêÂèñÂÖÉÁ¥†
        for (uint256 i = arr.length - 1; i > 0; i--) {
            _swap(arr, 0, i);
            swaps++;
            _heapify(arr, i, 0, comparisons, swaps);
        }
        
        uint256 gasUsed = gasStart - gasleft();
        
        result = SortResult({
            sortedArray: arr,
            comparisons: comparisons,
            swaps: swaps,
            gasUsed: gasUsed,
            algorithm: "HeapSort"
        });
        
        emit SortCompleted("HeapSort", arr.length, comparisons, swaps, gasUsed);
    }
    
    /**
     * @dev Â†ÜÂåñÊìç‰Ωú
     */
    function _heapify(
        uint256[] memory arr,
        uint256 n,
        uint256 i,
        uint256 comparisons,
        uint256 swaps
    ) internal {
        uint256 largest = i;
        uint256 left = 2 * i + 1;
        uint256 right = 2 * i + 2;
        
        if (left < n) {
            comparisons++;
            if (arr[left] > arr[largest]) {
                largest = left;
            }
        }
        
        if (right < n) {
            comparisons++;
            if (arr[right] > arr[largest]) {
                largest = right;
            }
        }
        
        if (largest != i) {
            _swap(arr, i, largest);
            swaps++;
            _heapify(arr, n, largest, comparisons, swaps);
        }
    }
    
    /**
     * @dev ËÆ°Êï∞ÊéíÂ∫èÂÆûÁé∞ - O(n + k)Á∫øÊÄßÊó∂Èó¥ÊéíÂ∫è
     * @param arr ÂæÖÊéíÂ∫èÊï∞ÁªÑ
     * @param maxValue Êï∞ÁªÑ‰∏≠ÁöÑÊúÄÂ§ßÂÄº
     * @return result ÊéíÂ∫èÁªìÊûú
     */
    function countingSort(uint256[] memory arr, uint256 maxValue) 
        external 
        returns (SortResult memory result) 
    {
        uint256 gasStart = gasleft();
        
        if (arr.length <= 1) {
            return SortResult({
                sortedArray: arr,
                comparisons: 0,
                swaps: 0,
                gasUsed: gasStart - gasleft(),
                algorithm: "CountingSort"
            });
        }
        
        // ÂàõÂª∫ËÆ°Êï∞Êï∞ÁªÑ
        uint256[] memory count = new uint256[](maxValue + 1);
        
        // ËÆ°Êï∞
        for (uint256 i = 0; i < arr.length; i++) {
            count[arr[i]]++;
        }
        
        // Á¥ØÁßØËÆ°Êï∞
        for (uint256 i = 1; i <= maxValue; i++) {
            count[i] += count[i - 1];
        }
        
        // ÊûÑÂª∫ËæìÂá∫Êï∞ÁªÑ
        uint256[] memory output = new uint256[](arr.length);
        for (int256 i = int256(arr.length) - 1; i >= 0; i--) {
            uint256 value = arr[uint256(i)];
            output[count[value] - 1] = value;
            count[value]--;
        }
        
        // Â§çÂà∂ÂõûÂéüÊï∞ÁªÑ
        for (uint256 i = 0; i < arr.length; i++) {
            arr[i] = output[i];
        }
        
        uint256 gasUsed = gasStart - gasleft();
        
        result = SortResult({
            sortedArray: arr,
            comparisons: 0, // ËÆ°Êï∞ÊéíÂ∫è‰∏çÈúÄË¶ÅÊØîËæÉ
            swaps: 0,
            gasUsed: gasUsed,
            algorithm: "CountingSort"
        });
        
        emit SortCompleted("CountingSort", arr.length, 0, 0, gasUsed);
    }
    
    /**
     * @dev Âü∫Êï∞ÊéíÂ∫èÂÆûÁé∞ - O(d * (n + k))Á∫øÊÄßÊó∂Èó¥ÊéíÂ∫è
     * @param arr ÂæÖÊéíÂ∫èÊï∞ÁªÑ
     * @return result ÊéíÂ∫èÁªìÊûú
     */
    function radixSort(uint256[] memory arr) 
        external 
        returns (SortResult memory result) 
    {
        uint256 gasStart = gasleft();
        
        if (arr.length <= 1) {
            return SortResult({
                sortedArray: arr,
                comparisons: 0,
                swaps: 0,
                gasUsed: gasStart - gasleft(),
                algorithm: "RadixSort"
            });
        }
        
        // ÊâæÂà∞ÊúÄÂ§ßÂÄº‰ª•Á°ÆÂÆö‰ΩçÊï∞
        uint256 maxValue = arr[0];
        for (uint256 i = 1; i < arr.length; i++) {
            if (arr[i] > maxValue) {
                maxValue = arr[i];
            }
        }
        
        // ÂØπÊØè‰∏Ä‰ΩçËøõË°åËÆ°Êï∞ÊéíÂ∫è
        for (uint256 exp = 1; maxValue / exp > 0; exp *= 10) {
            _countingSortByDigit(arr, exp);
        }
        
        uint256 gasUsed = gasStart - gasleft();
        
        result = SortResult({
            sortedArray: arr,
            comparisons: 0,
            swaps: 0,
            gasUsed: gasUsed,
            algorithm: "RadixSort"
        });
        
        emit SortCompleted("RadixSort", arr.length, 0, 0, gasUsed);
    }
    
    /**
     * @dev ÊåâÊåáÂÆö‰ΩçËøõË°åËÆ°Êï∞ÊéíÂ∫è
     */
    function _countingSortByDigit(uint256[] memory arr, uint256 exp) internal {
        uint256[] memory output = new uint256[](arr.length);
        uint256[] memory count = new uint256[](10); // 0-9ÁöÑËÆ°Êï∞
        
        // ËÆ°Êï∞
        for (uint256 i = 0; i < arr.length; i++) {
            count[(arr[i] / exp) % 10]++;
        }
        
        // Á¥ØÁßØËÆ°Êï∞
        for (uint256 i = 1; i < 10; i++) {
            count[i] += count[i - 1];
        }
        
        // ÊûÑÂª∫ËæìÂá∫Êï∞ÁªÑ
        for (int256 i = int256(arr.length) - 1; i >= 0; i--) {
            uint256 digit = (arr[uint256(i)] / exp) % 10;
            output[count[digit] - 1] = arr[uint256(i)];
            count[digit]--;
        }
        
        // Â§çÂà∂ÂõûÂéüÊï∞ÁªÑ
        for (uint256 i = 0; i < arr.length; i++) {
            arr[i] = output[i];
        }
    }
    
    /**
     * @dev ‰∫§Êç¢Êï∞ÁªÑ‰∏≠ÁöÑ‰∏§‰∏™ÂÖÉÁ¥†
     */
    function _swap(uint256[] memory arr, uint256 i, uint256 j) internal pure {
        uint256 temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
    
    /**
     * @dev ÁÆóÊ≥ïÊÄßËÉΩÊØîËæÉ
     * @param arr ÊµãËØïÊï∞ÁªÑ
     * @return results ÂêÑÁÆóÊ≥ïÁöÑÊÄßËÉΩÁªìÊûú
     */
    function compareAlgorithms(uint256[] memory arr) 
        external 
        returns (SortResult[] memory results) 
    {
        results = new SortResult[](3);
        
        // ÊµãËØïÂø´ÈÄüÊéíÂ∫è
        uint256[] memory arr1 = new uint256[](arr.length);
        for (uint256 i = 0; i < arr.length; i++) {
            arr1[i] = arr[i];
        }
        results[0] = this.quickSort(arr1);
        
        // ÊµãËØïÂΩíÂπ∂ÊéíÂ∫è
        uint256[] memory arr2 = new uint256[](arr.length);
        for (uint256 i = 0; i < arr.length; i++) {
            arr2[i] = arr[i];
        }
        results[1] = this.mergeSort(arr2);
        
        // ÊµãËØïÂ†ÜÊéíÂ∫è
        uint256[] memory arr3 = new uint256[](arr.length);
        for (uint256 i = 0; i < arr.length; i++) {
            arr3[i] = arr[i];
        }
        results[2] = this.heapSort(arr3);
    }
    
    // ‰∏™‰∫∫ÂøÉÂæóÔºö‰∏çÂêåÁöÑÊéíÂ∫èÁÆóÊ≥ïÂú®‰∏çÂêåÂú∫ÊôØ‰∏ãÊúâ‰∏çÂêåÁöÑ‰ºòÂäø
    // Âú®Âå∫ÂùóÈìæÁéØÂ¢É‰∏≠ÔºåGasÊïàÁéáÂæÄÂæÄÊØîÊó∂Èó¥Â§çÊùÇÂ∫¶Êõ¥ÈáçË¶Å
}
```

---

## üî¨ Á¨¨‰∫åÁ´†ÔºöÁÆóÊ≥ïÂ§çÊùÇÂ∫¶ÂàÜÊûê‰∏é‰ºòÂåñ

### 2.1 Êó∂Èó¥Â§çÊùÇÂ∫¶‰ºòÂåñÊäÄÂ∑ß

```solidity
contract ComplexityOptimization {
    
    // ÁºìÂ≠òÁªìÊûÑ
    struct Cache {
        mapping(bytes32 => uint256) results;
        mapping(bytes32 => bool) exists;
        uint256 hitCount;
        uint256 missCount;
    }
    
    // ÂàÜÊÆµÂ§ÑÁêÜÈÖçÁΩÆ
    struct BatchConfig {
        uint256 batchSize;       // ÊâπÂ§ÑÁêÜÂ§ßÂ∞è
        uint256 maxGasPerBatch;  // ÊØèÊâπÊúÄÂ§ßGas
        uint256 currentBatch;    // ÂΩìÂâçÊâπÊ¨°
        uint256 totalBatches;    // ÊÄªÊâπÊ¨°Êï∞
    }
    
    Cache private _fibonacciCache;
    Cache private _factorialCache;
    mapping(uint256 => BatchConfig) private _batchConfigs;
    
    event ComplexityAnalysis(
        string operation,
        uint256 inputSize,
        uint256 gasUsed,
        uint256 timeComplexity,
        string optimizationApplied
    );
    
    event CacheHit(string operation, bytes32 key, uint256 result);
    event CacheMiss(string operation, bytes32 key);
    
    /**
     * @dev ‰ºòÂåñÁöÑÊñêÊ≥¢ÈÇ£Â•ëÊï∞ÂàóËÆ°ÁÆó - ‰ªéO(2^n)‰ºòÂåñÂà∞O(n)
     * @param n Á¨¨nÈ°π
     * @return result ÊñêÊ≥¢ÈÇ£Â•ëÊï∞
     */
    function optimizedFibonacci(uint256 n) external returns (uint256 result) {
        uint256 gasStart = gasleft();
        
        bytes32 key = keccak256(abi.encodePacked("fibonacci", n));
        
        // Ê£ÄÊü•ÁºìÂ≠ò
        if (_fibonacciCache.exists[key]) {
            _fibonacciCache.hitCount++;
            result = _fibonacciCache.results[key];
            emit CacheHit("Fibonacci", key, result);
            return result;
        }
        
        _fibonacciCache.missCount++;
        emit CacheMiss("Fibonacci", key);
        
        if (n <= 1) {
            result = n;
        } else {
            // ‰ΩøÁî®Âä®ÊÄÅËßÑÂàíÔºåÈÅøÂÖçÈáçÂ§çËÆ°ÁÆó
            uint256 prev = 0;
            uint256 curr = 1;
            
            for (uint256 i = 2; i <= n; i++) {
                uint256 temp = curr;
                curr = prev + curr;
                prev = temp;
                
                // ÁºìÂ≠ò‰∏≠Èó¥ÁªìÊûú
                bytes32 intermediateKey = keccak256(abi.encodePacked("fibonacci", i));
                _fibonacciCache.results[intermediateKey] = curr;
                _fibonacciCache.exists[intermediateKey] = true;
            }
            
            result = curr;
        }
        
        // ÁºìÂ≠òÊúÄÁªàÁªìÊûú
        _fibonacciCache.results[key] = result;
        _fibonacciCache.exists[key] = true;
        
        uint256 gasUsed = gasStart - gasleft();
        
        emit ComplexityAnalysis(
            "Fibonacci",
            n,
            gasUsed,
            n, // O(n)Êó∂Èó¥Â§çÊùÇÂ∫¶
            "Dynamic Programming + Memoization"
        );
    }
    
    /**
     * @dev ‰ºòÂåñÁöÑÈò∂‰πòËÆ°ÁÆó - ‰ΩøÁî®ÁºìÂ≠òÂíåÂ¢ûÈáèËÆ°ÁÆó
     * @param n ËÆ°ÁÆón!
     * @return result Èò∂‰πòÁªìÊûú
     */
    function optimizedFactorial(uint256 n) external returns (uint256 result) {
        uint256 gasStart = gasleft();
        
        bytes32 key = keccak256(abi.encodePacked("factorial", n));
        
        // Ê£ÄÊü•ÁºìÂ≠ò
        if (_factorialCache.exists[key]) {
            _factorialCache.hitCount++;
            result = _factorialCache.results[key];
            emit CacheHit("Factorial", key, result);
            return result;
        }
        
        _factorialCache.missCount++;
        emit CacheMiss("Factorial", key);
        
        if (n == 0 || n == 1) {
            result = 1;
        } else {
            // ÂØªÊâæÊúÄÂ§ßÁöÑÂ∑≤ÁºìÂ≠òÂÄº
            uint256 startFrom = 1;
            uint256 startValue = 1;
            
            for (uint256 i = n - 1; i > 1; i--) {
                bytes32 checkKey = keccak256(abi.encodePacked("factorial", i));
                if (_factorialCache.exists[checkKey]) {
                    startFrom = i;
                    startValue = _factorialCache.results[checkKey];
                    break;
                }
            }
            
            // ‰ªéÂ∑≤Áü•ÂÄºÂºÄÂßãËÆ°ÁÆó
            result = startValue;
            for (uint256 i = startFrom + 1; i <= n; i++) {
                result *= i;
                
                // ÁºìÂ≠ò‰∏≠Èó¥ÁªìÊûú
                bytes32 intermediateKey = keccak256(abi.encodePacked("factorial", i));
                _factorialCache.results[intermediateKey] = result;
                _factorialCache.exists[intermediateKey] = true;
            }
        }
        
        uint256 gasUsed = gasStart - gasleft();
        
        emit ComplexityAnalysis(
            "Factorial",
            n,
            gasUsed,
            n - startFrom, // ÂÆûÈôÖËÆ°ÁÆóÁöÑÊ≠•Êï∞
            "Incremental Calculation + Memoization"
        );
    }
    
    /**
     * @dev ‰ºòÂåñÁöÑÊï∞ÁªÑÊü•Êâæ - ‰ΩøÁî®‰∫åÂàÜÊü•Êâæ
     * @param sortedArray Â∑≤ÊéíÂ∫èÊï∞ÁªÑ
     * @param target ÁõÆÊ†áÂÄº
     * @return found ÊòØÂê¶ÊâæÂà∞
     * @return index Á¥¢Âºï‰ΩçÁΩÆ
     */
    function optimizedBinarySearch(
        uint256[] memory sortedArray,
        uint256 target
    ) external returns (bool found, uint256 index) {
        uint256 gasStart = gasleft();
        uint256 comparisons = 0;
        
        uint256 left = 0;
        uint256 right = sortedArray.length;
        
        while (left < right) {
            uint256 mid = left + (right - left) / 2;
            comparisons++;
            
            if (sortedArray[mid] == target) {
                found = true;
                index = mid;
                break;
            } else if (sortedArray[mid] < target) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        
        uint256 gasUsed = gasStart - gasleft();
        
        emit ComplexityAnalysis(
            "Binary Search",
            sortedArray.length,
            gasUsed,
            comparisons, // ÂÆûÈôÖÊØîËæÉÊ¨°Êï∞ÔºåÁêÜËÆ∫‰∏äÊòØO(log n)
            "Binary Search Algorithm"
        );
    }
    
    /**
     * @dev ÊâπÂ§ÑÁêÜ‰ºòÂåñ - Â∞ÜÂ§ß‰ªªÂä°ÂàÜËß£‰∏∫Â∞èÊâπÊ¨°
     * @param data ÂæÖÂ§ÑÁêÜÊï∞ÊçÆ
     * @param batchId ÊâπÂ§ÑÁêÜID
     * @return completed ÊòØÂê¶ÂÆåÊàê
     * @return nextBatch ‰∏ã‰∏ÄÊâπÊ¨°Á¥¢Âºï
     */
    function batchProcess(
        uint256[] memory data,
        uint256 batchId
    ) external returns (bool completed, uint256 nextBatch) {
        uint256 gasStart = gasleft();
        
        BatchConfig storage config = _batchConfigs[batchId];
        
        // ÂàùÂßãÂåñÊâπÂ§ÑÁêÜÈÖçÁΩÆ
        if (config.batchSize == 0) {
            config.batchSize = 50; // ÈªòËÆ§ÊâπÂ§ßÂ∞è
            config.maxGasPerBatch = 200000; // ÊúÄÂ§ßGasÈôêÂà∂
            config.totalBatches = (data.length + config.batchSize - 1) / config.batchSize;
        }
        
        uint256 startIndex = config.currentBatch * config.batchSize;
        uint256 endIndex = startIndex + config.batchSize;
        
        if (endIndex > data.length) {
            endIndex = data.length;
        }
        
        // Â§ÑÁêÜÂΩìÂâçÊâπÊ¨°
        uint256 processedCount = 0;
        for (uint256 i = startIndex; i < endIndex; i++) {
            // Ê£ÄÊü•GasÈôêÂà∂
            if (gasStart - gasleft() > config.maxGasPerBatch) {
                break;
            }
            
            // Ê®°ÊãüÂ§çÊùÇÂ§ÑÁêÜ
            _complexProcessing(data[i]);
            processedCount++;
        }
        
        config.currentBatch++;
        completed = config.currentBatch >= config.totalBatches;
        nextBatch = config.currentBatch;
        
        uint256 gasUsed = gasStart - gasleft();
        
        emit ComplexityAnalysis(
            "Batch Processing",
            processedCount,
            gasUsed,
            processedCount, // O(n)‰ΩÜÂàÜÊâπÊâßË°å
            "Batch Processing Optimization"
        );
    }
    
    /**
     * @dev Ê®°ÊãüÂ§çÊùÇÂ§ÑÁêÜ
     */
    function _complexProcessing(uint256 value) internal pure {
        // Ê®°Êãü‰∏Ä‰∫õÂ§çÊùÇËÆ°ÁÆó
        uint256 result = value;
        for (uint256 i = 0; i < 10; i++) {
            result = (result * 31 + 17) % 1000000007;
        }
    }
    
    /**
     * @dev Á©∫Èó¥Â§çÊùÇÂ∫¶‰ºòÂåñ - ÂéüÂú∞ÁÆóÊ≥ï
     * @param arr Êï∞ÁªÑ
     * @return ÂèçËΩ¨ÂêéÁöÑÊï∞ÁªÑ
     */
    function inPlaceReverse(uint256[] memory arr) 
        external 
        returns (uint256[] memory) 
    {
        uint256 gasStart = gasleft();
        
        uint256 left = 0;
        uint256 right = arr.length - 1;
        uint256 swaps = 0;
        
        while (left < right) {
            // ÂéüÂú∞‰∫§Êç¢Ôºå‰∏ç‰ΩøÁî®È¢ùÂ§ñÁ©∫Èó¥
            uint256 temp = arr[left];
            arr[left] = arr[right];
            arr[right] = temp;
            
            left++;
            right--;
            swaps++;
        }
        
        uint256 gasUsed = gasStart - gasleft();
        
        emit ComplexityAnalysis(
            "In-Place Reverse",
            arr.length,
            gasUsed,
            swaps, // O(n/2)
            "In-Place Algorithm (O(1) space)"
        );
        
        return arr;
    }
    
    /**
     * @dev Ëé∑ÂèñÁºìÂ≠òÁªüËÆ°
     * @param cacheType ÁºìÂ≠òÁ±ªÂûã
     * @return hitCount ÂëΩ‰∏≠Ê¨°Êï∞
     * @return missCount Êú™ÂëΩ‰∏≠Ê¨°Êï∞
     * @return hitRate ÂëΩ‰∏≠Áéá
     */
    function getCacheStats(string memory cacheType) 
        external 
        view 
        returns (uint256 hitCount, uint256 missCount, uint256 hitRate) 
    {
        Cache storage cache;
        
        if (keccak256(bytes(cacheType)) == keccak256(bytes("fibonacci"))) {
            cache = _fibonacciCache;
        } else if (keccak256(bytes(cacheType)) == keccak256(bytes("factorial"))) {
            cache = _factorialCache;
        }
        
        hitCount = cache.hitCount;
        missCount = cache.missCount;
        
        uint256 totalAccess = hitCount + missCount;
        hitRate = totalAccess > 0 ? (hitCount * 100) / totalAccess : 0;
    }
    
    /**
     * @dev Ê∏ÖÈô§ÁºìÂ≠ò
     * @param cacheType ÁºìÂ≠òÁ±ªÂûã
     */
    function clearCache(string memory cacheType) external {
        if (keccak256(bytes(cacheType)) == keccak256(bytes("fibonacci"))) {
            _fibonacciCache.hitCount = 0;
            _fibonacciCache.missCount = 0;
        } else if (keccak256(bytes(cacheType)) == keccak256(bytes("factorial"))) {
            _factorialCache.hitCount = 0;
            _factorialCache.missCount = 0;
        }
    }
    
    // ‰∏™‰∫∫ÂøÉÂæóÔºöÁÆóÊ≥ï‰ºòÂåñ‰∏ç‰ªÖË¶ÅËÄÉËôëÊó∂Èó¥Â§çÊùÇÂ∫¶ÔºåËøòË¶ÅËÄÉËôëÁ©∫Èó¥Â§çÊùÇÂ∫¶ÂíåGasÊàêÊú¨
    // ÁºìÂ≠òÂíåÊâπÂ§ÑÁêÜÊòØÂå∫ÂùóÈìæÁéØÂ¢É‰∏≠Â∏∏Áî®ÁöÑ‰ºòÂåñÊäÄÂ∑ß
}
```

### 2.2 Á©∫Èó¥Â§çÊùÇÂ∫¶‰ºòÂåñ

```solidity
contract SpaceOptimization {
    
    // ÂéãÁº©Â≠òÂÇ®ÁªìÊûÑ
    struct PackedData {
        uint128 value1;      // ‰ΩøÁî®Êõ¥Â∞èÁöÑÊï∞ÊçÆÁ±ªÂûã
        uint64 value2;
        uint32 value3;
        uint16 value4;
        uint8 value5;
        bool flag1;
        bool flag2;
        // ÊÄªÂÖ±256‰ΩçÔºåÊ≠£Â•Ω‰∏Ä‰∏™Â≠òÂÇ®ÊßΩ
    }
    
    // ‰ΩçÊìç‰Ωú‰ºòÂåñÁöÑÈõÜÂêà
    struct BitSet {
        mapping(uint256 => uint256) bits;
        uint256 size;
    }
    
    // Á®ÄÁñèÊï∞ÁªÑ‰ºòÂåñ
    struct SparseArray {
        mapping(uint256 => uint256) data;
        mapping(uint256 => bool) exists;
        uint256[] indices;
        uint256 count;
    }
    
    PackedData[] private _packedArray;
    BitSet private _bitSet;
    SparseArray private _sparseArray;
    
    event SpaceOptimization(
        string operation,
        uint256 originalSize,
        uint256 optimizedSize,
        uint256 spaceSaved,
        string technique
    );
    
    /**
     * @dev ‰ΩçÈõÜÂêàÊìç‰Ωú - ËäÇÁúÅÂ≠òÂÇ®Á©∫Èó¥
     * @param element ÂÖÉÁ¥†ÂÄº
     */
    function addToBitSet(uint256 element) external {
        uint256 wordIndex = element / 256;
        uint256 bitIndex = element % 256;
        
        uint256 originalSize = _bitSet.size;
        
        // ËÆæÁΩÆÂØπÂ∫î‰Ωç
        _bitSet.bits[wordIndex] |= (1 << bitIndex);
        
        // Êõ¥Êñ∞Â§ßÂ∞è
        if (element >= _bitSet.size) {
            _bitSet.size = element + 1;
        }
        
        uint256 optimizedSize = (_bitSet.size + 255) / 256; // ÂÆûÈôÖ‰ΩøÁî®ÁöÑÂ≠óÊï∞
        uint256 spaceSaved = _bitSet.size - optimizedSize;
        
        emit SpaceOptimization(
            "BitSet Add",
            _bitSet.size,
            optimizedSize,
            spaceSaved,
            "Bit Manipulation"
        );
    }
    
    /**
     * @dev Ê£ÄÊü•‰ΩçÈõÜÂêà‰∏≠ÊòØÂê¶Â≠òÂú®ÂÖÉÁ¥†
     * @param element ÂÖÉÁ¥†ÂÄº
     * @return exists ÊòØÂê¶Â≠òÂú®
     */
    function existsInBitSet(uint256 element) external view returns (bool exists) {
        if (element >= _bitSet.size) {
            return false;
        }
        
        uint256 wordIndex = element / 256;
        uint256 bitIndex = element % 256;
        
        return (_bitSet.bits[wordIndex] & (1 << bitIndex)) != 0;
    }
    
    /**
     * @dev Á®ÄÁñèÊï∞ÁªÑÊìç‰Ωú - Âè™Â≠òÂÇ®ÈùûÈõ∂ÂÄº
     * @param index Á¥¢Âºï
     * @param value ÂÄº
     */
    function setSparseArrayValue(uint256 index, uint256 value) external {
        uint256 originalCount = _sparseArray.count;
        
        if (value == 0) {
            // Âà†Èô§ÂÖÉÁ¥†
            if (_sparseArray.exists[index]) {
                delete _sparseArray.data[index];
                _sparseArray.exists[index] = false;
                
                // ‰ªéÁ¥¢ÂºïÊï∞ÁªÑ‰∏≠ÁßªÈô§
                for (uint256 i = 0; i < _sparseArray.indices.length; i++) {
                    if (_sparseArray.indices[i] == index) {
                        _sparseArray.indices[i] = _sparseArray.indices[_sparseArray.indices.length - 1];
                        _sparseArray.indices.pop();
                        break;
                    }
                }
                _sparseArray.count--;
            }
        } else {
            // Ê∑ªÂä†ÊàñÊõ¥Êñ∞ÂÖÉÁ¥†
            if (!_sparseArray.exists[index]) {
                _sparseArray.indices.push(index);
                _sparseArray.count++;
            }
            
            _sparseArray.data[index] = value;
            _sparseArray.exists[index] = true;
        }
        
        // ËÆ°ÁÆóÁ©∫Èó¥ËäÇÁúÅ
        uint256 denseArraySize = index + 1; // Â¶ÇÊûú‰ΩøÁî®ÂØÜÈõÜÊï∞ÁªÑÈúÄË¶ÅÁöÑÂ§ßÂ∞è
        uint256 sparseArraySize = _sparseArray.count;
        uint256 spaceSaved = denseArraySize > sparseArraySize ? 
                            denseArraySize - sparseArraySize : 0;
        
        emit SpaceOptimization(
            "Sparse Array",
            denseArraySize,
            sparseArraySize,
            spaceSaved,
            "Sparse Data Structure"
        );
    }
    
    /**
     * @dev Ëé∑ÂèñÁ®ÄÁñèÊï∞ÁªÑÂÄº
     * @param index Á¥¢Âºï
     * @return value ÂÄº
     */
    function getSparseArrayValue(uint256 index) external view returns (uint256 value) {
        return _sparseArray.exists[index] ? _sparseArray.data[index] : 0;
    }
    
    /**
     * @dev Êï∞ÊçÆÊâìÂåÖ‰ºòÂåñ
     * @param values Ë¶ÅÊâìÂåÖÁöÑÂÄºÊï∞ÁªÑ
     */
    function packData(
        uint128 value1,
        uint64 value2,
        uint32 value3,
        uint16 value4,
        uint8 value5,
        bool flag1,
        bool flag2
    ) external {
        uint256 originalSize = 5; // Â¶ÇÊûúÊØè‰∏™ÂÄºÈÉΩÁî®uint256Â≠òÂÇ®
        
        PackedData memory packed = PackedData({
            value1: value1,
            value2: value2,
            value3: value3,
            value4: value4,
            value5: value5,
            flag1: flag1,
            flag2: flag2
        });
        
        _packedArray.push(packed);
        
        uint256 optimizedSize = 1; // ÊâìÂåÖÂêéÂè™ÈúÄË¶Å1‰∏™Â≠òÂÇ®ÊßΩ
        uint256 spaceSaved = originalSize - optimizedSize;
        
        emit SpaceOptimization(
            "Data Packing",
            originalSize,
            optimizedSize,
            spaceSaved,
            "Struct Packing"
        );
    }
    
    /**
     * @dev Â≠óÁ¨¶‰∏≤ÂéãÁº©Â≠òÂÇ®
     * @param longString ÈïøÂ≠óÁ¨¶‰∏≤
     * @return compressedHash ÂéãÁº©ÂêéÁöÑÂìàÂ∏å
     */
    function compressString(string memory longString) 
        external 
        pure 
        returns (bytes32 compressedHash) 
    {
        // ‰ΩøÁî®ÂìàÂ∏åÊù•ÂéãÁº©ÈïøÂ≠óÁ¨¶‰∏≤
        compressedHash = keccak256(bytes(longString));
        
        // Ê≥®ÊÑèÔºöËøôÁßçÂéãÁº©ÊòØÊúâÊçüÁöÑÔºåÂè™ÈÄÇÁî®‰∫é‰∏çÈúÄË¶ÅÊÅ¢Â§çÂéüÂßãÊï∞ÊçÆÁöÑÂú∫ÊôØ
        // Âú®ÂÆûÈôÖÂ∫îÁî®‰∏≠ÔºåÂèØ‰ª•ÁªìÂêàÈìæ‰∏ãÂ≠òÂÇ®Êù•ÂÆûÁé∞Êó†ÊçüÂéãÁº©
    }
    
    /**
     * @dev Âä®ÊÄÅÊï∞ÁªÑ‰ºòÂåñ - È¢ÑÂàÜÈÖçÂíåÊâπÈáèÊìç‰Ωú
     * @param elements Ë¶ÅÊ∑ªÂä†ÁöÑÂÖÉÁ¥†
     */
    function optimizedBatchAdd(uint256[] memory elements) external {
        uint256 originalLength = _packedArray.length;
        
        // È¢ÑÂàÜÈÖçÁ©∫Èó¥ÔºàÂú®Solidity‰∏≠ÈÄöËøáÂæ™ÁéØÂÆûÁé∞Ôºâ
        for (uint256 i = 0; i < elements.length; i++) {
            PackedData memory newData = PackedData({
                value1: uint128(elements[i]),
                value2: uint64(elements[i] >> 128),
                value3: uint32(elements[i] >> 192),
                value4: uint16(elements[i] >> 224),
                value5: uint8(elements[i] >> 240),
                flag1: (elements[i] & 1) == 1,
                flag2: (elements[i] & 2) == 2
            });
            
            _packedArray.push(newData);
        }
        
        uint256 newLength = _packedArray.length;
        
        emit SpaceOptimization(
            "Batch Add",
            elements.length,
            newLength - originalLength,
            0, // ÊâπÈáèÊìç‰Ωú‰∏ªË¶Å‰ºòÂåñÊó∂Èó¥ËÄåÈùûÁ©∫Èó¥
            "Batch Operations"
        );
    }
    
    /**
     * @dev ÂÜÖÂ≠òÊ±†‰ºòÂåñ - ÈáçÁî®Â∑≤Âà†Èô§ÁöÑÊßΩ‰Ωç
     * @param index Ë¶ÅÂà†Èô§ÁöÑÁ¥¢Âºï
     */
    function optimizedDelete(uint256 index) external {
        require(index < _packedArray.length, "Index out of bounds");
        
        uint256 originalLength = _packedArray.length;
        
        // Â∞ÜÊúÄÂêé‰∏Ä‰∏™ÂÖÉÁ¥†ÁßªÂà∞Ë¶ÅÂà†Èô§ÁöÑ‰ΩçÁΩÆ
        if (index < _packedArray.length - 1) {
            _packedArray[index] = _packedArray[_packedArray.length - 1];
        }
        
        _packedArray.pop();
        
        uint256 newLength = _packedArray.length;
        
        emit SpaceOptimization(
            "Optimized Delete",
            originalLength,
            newLength,
            1, // ËäÇÁúÅ‰∏Ä‰∏™Â≠òÂÇ®ÊßΩ
            "Swap and Pop"
        );
    }
    
    /**
     * @dev Ëé∑ÂèñÂ≠òÂÇ®ÁªüËÆ°‰ø°ÊÅØ
     * @return packedArraySize ÊâìÂåÖÊï∞ÁªÑÂ§ßÂ∞è
     * @return bitSetSize ‰ΩçÈõÜÂêàÂ§ßÂ∞è
     * @return sparseArraySize Á®ÄÁñèÊï∞ÁªÑÂ§ßÂ∞è
     */
    function getStorageStats() 
        external 
        view 
        returns (
            uint256 packedArraySize,
            uint256 bitSetSize,
            uint256 sparseArraySize
        ) 
    {
        packedArraySize = _packedArray.length;
        bitSetSize = (_bitSet.size + 255) / 256; // ÂÆûÈôÖ‰ΩøÁî®ÁöÑÂ≠óÊï∞
        sparseArraySize = _sparseArray.count;
    }
    
    // ‰∏™‰∫∫ÂøÉÂæóÔºöÁ©∫Èó¥‰ºòÂåñÂú®Âå∫ÂùóÈìæ‰∏≠Â∞§‰∏∫ÈáçË¶ÅÔºåÊØè‰∏™Â≠òÂÇ®ÊßΩÈÉΩÊúâÊàêÊú¨
    // ‰ΩçÊìç‰Ωú„ÄÅÊï∞ÊçÆÊâìÂåÖ„ÄÅÁ®ÄÁñèÁªìÊûÑÈÉΩÊòØÊúâÊïàÁöÑ‰ºòÂåñÊâãÊÆµ
}
```

---

## üéØ Á¨¨‰∏âÁ´†ÔºöÈ´òÁ∫ßÁÆóÊ≥ïÂÆûÁé∞

### 3.1 ÂõæÁÆóÊ≥ïÂÆûÁé∞

```solidity
contract GraphAlgorithms {
    
    // ÂõæÁöÑËæπÁªìÊûÑ
    struct Edge {
        uint256 from;
        uint256 to;
        uint256 weight;
        bool exists;
    }
    
    // ÂõæÁªìÊûÑ
    struct Graph {
        mapping(uint256 => mapping(uint256 => Edge)) edges;
        mapping(uint256 => uint256[]) adjacencyList;
        mapping(uint256 => bool) vertices;
        uint256 vertexCount;
        uint256 edgeCount;
        bool isDirected;
    }
    
    // ÊúÄÁü≠Ë∑ØÂæÑÁªìÊûú
    struct ShortestPathResult {
        uint256[] path;
        uint256 distance;
        bool pathExists;
    }
    
    Graph private _graph;
    
    event GraphOperation(
        string operation,
        uint256 vertex1,
        uint256 vertex2,
        uint256 weight,
        string algorithm
    );
    
    event PathFound(
        uint256 source,
        uint256 destination,
        uint256[] path,
        uint256 distance,
        string algorithm
    );
    
    constructor(bool isDirected) {
        _graph.isDirected = isDirected;
    }
    
    /**
     * @dev Ê∑ªÂä†Ëæπ
     * @param from Ëµ∑ÂßãÈ°∂ÁÇπ
     * @param to ÁõÆÊ†áÈ°∂ÁÇπ
     * @param weight ÊùÉÈáç
     */
    function addEdge(uint256 from, uint256 to, uint256 weight) external {
        // Ê∑ªÂä†È°∂ÁÇπ
        if (!_graph.vertices[from]) {
            _graph.vertices[from] = true;
            _graph.vertexCount++;
        }
        
        if (!_graph.vertices[to]) {
            _graph.vertices[to] = true;
            _graph.vertexCount++;
        }
        
        // Ê∑ªÂä†Ëæπ
        if (!_graph.edges[from][to].exists) {
            _graph.edges[from][to] = Edge(from, to, weight, true);
            _graph.adjacencyList[from].push(to);
            _graph.edgeCount++;
            
            // Êó†ÂêëÂõæÈúÄË¶ÅÊ∑ªÂä†ÂèçÂêëËæπ
            if (!_graph.isDirected && from != to) {
                _graph.edges[to][from] = Edge(to, from, weight, true);
                _graph.adjacencyList[to].push(from);
            }
        } else {
            // Êõ¥Êñ∞ÊùÉÈáç
            _graph.edges[from][to].weight = weight;
            if (!_graph.isDirected) {
                _graph.edges[to][from].weight = weight;
            }
        }
        
        emit GraphOperation("Add Edge", from, to, weight, "Graph Construction");
    }
    
    /**
     * @dev DijkstraÊúÄÁü≠Ë∑ØÂæÑÁÆóÊ≥ï - O((V + E) log V)
     * @param source Ê∫êÈ°∂ÁÇπ
     * @param destination ÁõÆÊ†áÈ°∂ÁÇπ
     * @return result ÊúÄÁü≠Ë∑ØÂæÑÁªìÊûú
     */
    function dijkstraShortestPath(uint256 source, uint256 destination)
        external
        returns (ShortestPathResult memory result)
    {
        require(_graph.vertices[source], "Source vertex does not exist");
        require(_graph.vertices[destination], "Destination vertex does not exist");
        
        // Ë∑ùÁ¶ªÊï∞ÁªÑ
        mapping(uint256 => uint256) storage distances;
        mapping(uint256 => uint256) storage previous;
        mapping(uint256 => bool) storage visited;
        
        // ÂàùÂßãÂåñ
        uint256[] memory unvisited = new uint256[](_graph.vertexCount);
        uint256 unvisitedCount = 0;
        
        // Êî∂ÈõÜÊâÄÊúâÈ°∂ÁÇπÂπ∂ÂàùÂßãÂåñË∑ùÁ¶ª
        for (uint256 v = 0; v < 1000; v++) { // ÂÅáËÆæÈ°∂ÁÇπIDÂ∞è‰∫é1000
            if (_graph.vertices[v]) {
                distances[v] = v == source ? 0 : type(uint256).max;
                unvisited[unvisitedCount] = v;
                unvisitedCount++;
            }
        }
        
        while (unvisitedCount > 0) {
            // ÊâæÂà∞Ë∑ùÁ¶ªÊúÄÂ∞èÁöÑÊú™ËÆøÈóÆÈ°∂ÁÇπ
            uint256 minDistance = type(uint256).max;
            uint256 currentVertex;
            uint256 currentIndex;
            
            for (uint256 i = 0; i < unvisitedCount; i++) {
                uint256 vertex = unvisited[i];
                if (distances[vertex] < minDistance) {
                    minDistance = distances[vertex];
                    currentVertex = vertex;
                    currentIndex = i;
                }
            }
            
            // Â¶ÇÊûúÊâæ‰∏çÂà∞ÂèØËææÈ°∂ÁÇπÔºåÈÄÄÂá∫
            if (minDistance == type(uint256).max) {
                break;
            }
            
            // Ê†áËÆ∞‰∏∫Â∑≤ËÆøÈóÆ
            visited[currentVertex] = true;
            
            // ‰ªéÊú™ËÆøÈóÆÂàóË°®‰∏≠ÁßªÈô§
            unvisited[currentIndex] = unvisited[unvisitedCount - 1];
            unvisitedCount--;
            
            // Â¶ÇÊûúÂà∞ËææÁõÆÊ†áÔºåÂèØ‰ª•ÊèêÂâçÈÄÄÂá∫
            if (currentVertex == destination) {
                break;
            }
            
            // Êõ¥Êñ∞ÈÇªÂ±ÖË∑ùÁ¶ª
            uint256[] storage neighbors = _graph.adjacencyList[currentVertex];
            for (uint256 i = 0; i < neighbors.length; i++) {
                uint256 neighbor = neighbors[i];
                if (!visited[neighbor]) {
                    uint256 newDistance = distances[currentVertex] + 
                                        _graph.edges[currentVertex][neighbor].weight;
                    
                    if (newDistance < distances[neighbor]) {
                        distances[neighbor] = newDistance;
                        previous[neighbor] = currentVertex;
                    }
                }
            }
        }
        
        // ÊûÑÂª∫Ë∑ØÂæÑ
        if (distances[destination] == type(uint256).max) {
            result.pathExists = false;
            result.distance = 0;
            result.path = new uint256[](0);
        } else {
            result.pathExists = true;
            result.distance = distances[destination];
            
            // ÂõûÊ∫ØË∑ØÂæÑ
            uint256[] memory tempPath = new uint256[](1000);
            uint256 pathLength = 0;
            uint256 current = destination;
            
            while (current != source) {
                tempPath[pathLength] = current;
                pathLength++;
                current = previous[current];
            }
            tempPath[pathLength] = source;
            pathLength++;
            
            // ÂèçËΩ¨Ë∑ØÂæÑ
            result.path = new uint256[](pathLength);
            for (uint256 i = 0; i < pathLength; i++) {
                result.path[i] = tempPath[pathLength - 1 - i];
            }
        }
        
        emit PathFound(
            source,
            destination,
            result.path,
            result.distance,
            "Dijkstra"
        );
    }
    
    /**
     * @dev Ê∑±Â∫¶‰ºòÂÖàÊêúÁ¥¢ - O(V + E)
     * @param startVertex Ëµ∑ÂßãÈ°∂ÁÇπ
     * @return visitOrder ËÆøÈóÆÈ°∫Â∫è
     */
    function depthFirstSearch(uint256 startVertex)
        external
        returns (uint256[] memory visitOrder)
    {
        require(_graph.vertices[startVertex], "Start vertex does not exist");
        
        mapping(uint256 => bool) storage visited;
        uint256[] memory stack = new uint256[](1000);
        uint256[] memory result = new uint256[](1000);
        uint256 stackTop = 0;
        uint256 resultCount = 0;
        
        // ÂàùÂßãÂåñÊ†à
        stack[stackTop] = startVertex;
        stackTop++;
        
        while (stackTop > 0) {
            // Âá∫Ê†à
            stackTop--;
            uint256 current = stack[stackTop];
            
            if (!visited[current]) {
                visited[current] = true;
                result[resultCount] = current;
                resultCount++;
                
                // Â∞ÜÈÇªÂ±ÖÂÖ•Ê†àÔºàÈÄÜÂ∫è‰ª•‰øùÊåÅÊ≠£Á°ÆÁöÑËÆøÈóÆÈ°∫Â∫èÔºâ
                uint256[] storage neighbors = _graph.adjacencyList[current];
                for (int256 i = int256(neighbors.length) - 1; i >= 0; i--) {
                    uint256 neighbor = neighbors[uint256(i)];
                    if (!visited[neighbor]) {
                        stack[stackTop] = neighbor;
                        stackTop++;
                    }
                }
            }
        }
        
        // Â§çÂà∂ÁªìÊûúÂà∞Ê≠£Á°ÆÂ§ßÂ∞èÁöÑÊï∞ÁªÑ
        visitOrder = new uint256[](resultCount);
        for (uint256 i = 0; i < resultCount; i++) {
            visitOrder[i] = result[i];
        }
        
        emit GraphOperation(
            "DFS",
            startVertex,
            0,
            resultCount,
            "Depth First Search"
        );
    }
    
    /**
     * @dev ÂπøÂ∫¶‰ºòÂÖàÊêúÁ¥¢ - O(V + E)
     * @param startVertex Ëµ∑ÂßãÈ°∂ÁÇπ
     * @return visitOrder ËÆøÈóÆÈ°∫Â∫è
     */
    function breadthFirstSearch(uint256 startVertex)
        external
        returns (uint256[] memory visitOrder)
    {
        require(_graph.vertices[startVertex], "Start vertex does not exist");
        
        mapping(uint256 => bool) storage visited;
        uint256[] memory queue = new uint256[](1000);
        uint256[] memory result = new uint256[](1000);
        uint256 queueFront = 0;
        uint256 queueRear = 0;
        uint256 resultCount = 0;
        
        // ÂàùÂßãÂåñÈòüÂàó
        queue[queueRear] = startVertex;
        queueRear++;
        visited[startVertex] = true;
        
        while (queueFront < queueRear) {
            // Âá∫Èòü
            uint256 current = queue[queueFront];
            queueFront++;
            
            result[resultCount] = current;
            resultCount++;
            
            // Â∞ÜÊú™ËÆøÈóÆÁöÑÈÇªÂ±ÖÂÖ•Èòü
            uint256[] storage neighbors = _graph.adjacencyList[current];
            for (uint256 i = 0; i < neighbors.length; i++) {
                uint256 neighbor = neighbors[i];
                if (!visited[neighbor]) {
                    visited[neighbor] = true;
                    queue[queueRear] = neighbor;
                    queueRear++;
                }
            }
        }
        
        // Â§çÂà∂ÁªìÊûúÂà∞Ê≠£Á°ÆÂ§ßÂ∞èÁöÑÊï∞ÁªÑ
        visitOrder = new uint256[](resultCount);
        for (uint256 i = 0; i < resultCount; i++) {
            visitOrder[i] = result[i];
        }
        
        emit GraphOperation(
            "BFS",
            startVertex,
            0,
            resultCount,
            "Breadth First Search"
        );
    }
    
    /**
     * @dev Ê£ÄÊµãÁéØË∑ØÔºàÊúâÂêëÂõæÔºâ- O(V + E)
     * @return hasCycle ÊòØÂê¶Â≠òÂú®ÁéØË∑Ø
     */
    function detectCycle() external returns (bool hasCycle) {
        require(_graph.isDirected, "Cycle detection implemented for directed graphs only");
        
        mapping(uint256 => uint8) storage color; // 0: ÁôΩËâ≤, 1: ÁÅ∞Ëâ≤, 2: ÈªëËâ≤
        
        // ÂØπÊâÄÊúâÈ°∂ÁÇπËøõË°åDFS
        for (uint256 v = 0; v < 1000; v++) {
            if (_graph.vertices[v] && color[v] == 0) {
                if (_dfsForCycle(v, color)) {
                    hasCycle = true;
                    break;
                }
            }
        }
        
        emit GraphOperation(
            "Cycle Detection",
            0,
            0,
            hasCycle ? 1 : 0,
            "DFS Cycle Detection"
        );
    }
    
    /**
     * @dev DFSÁéØË∑ØÊ£ÄÊµãËæÖÂä©ÂáΩÊï∞
     */
    function _dfsForCycle(
        uint256 vertex,
        mapping(uint256 => uint8) storage color
    ) internal returns (bool) {
        color[vertex] = 1; // Ê†áËÆ∞‰∏∫ÁÅ∞Ëâ≤ÔºàÊ≠£Âú®ËÆøÈóÆÔºâ
        
        uint256[] storage neighbors = _graph.adjacencyList[vertex];
        for (uint256 i = 0; i < neighbors.length; i++) {
            uint256 neighbor = neighbors[i];
            
            if (color[neighbor] == 1) {
                // ÂèëÁé∞ÂêéÂêëËæπÔºåÂ≠òÂú®ÁéØË∑Ø
                return true;
            }
            
            if (color[neighbor] == 0 && _dfsForCycle(neighbor, color)) {
                return true;
            }
        }
        
        color[vertex] = 2; // Ê†áËÆ∞‰∏∫ÈªëËâ≤ÔºàËÆøÈóÆÂÆåÊàêÔºâ
        return false;
    }
    
    /**
     * @dev Ëé∑ÂèñÂõæÁöÑÁªüËÆ°‰ø°ÊÅØ
     * @return vertexCount È°∂ÁÇπÊï∞
     * @return edgeCount ËæπÊï∞
     * @return isDirected ÊòØÂê¶‰∏∫ÊúâÂêëÂõæ
     */
    function getGraphStats()
        external
        view
        returns (
            uint256 vertexCount,
            uint256 edgeCount,
            bool isDirected
        )
    {
        return (_graph.vertexCount, _graph.edgeCount, _graph.isDirected);
    }
    
    // ‰∏™‰∫∫ÂøÉÂæóÔºöÂõæÁÆóÊ≥ïÊòØËÆ°ÁÆóÊú∫ÁßëÂ≠¶ÁöÑÊ†∏ÂøÉÔºåÂú®Âå∫ÂùóÈìæ‰∏≠ÊúâÂπøÊ≥õÂ∫îÁî®
    // Â¶ÇÁΩëÁªúÊãìÊâëÂàÜÊûê„ÄÅ‰æùËµñÂÖ≥Á≥ªÁÆ°ÁêÜ„ÄÅË∑ØÁî±‰ºòÂåñÁ≠â
}
```

---

## üìö Â≠¶‰π†ÂøÉÂæó‰∏éÊÄªÁªì

### üéØ Ê†∏ÂøÉÊî∂Ëé∑

1. **Êï∞ÊçÆÁªìÊûÑÈÄâÊã©ÁöÑÈáçË¶ÅÊÄß**
   - ‰∏çÂêåÁöÑÊï∞ÊçÆÁªìÊûÑÈÄÇÁî®‰∫é‰∏çÂêåÁöÑÂú∫ÊôØ
   - Âú®Âå∫ÂùóÈìæÁéØÂ¢É‰∏≠ÔºåÂ≠òÂÇ®ÊàêÊú¨ÊòØÈáçË¶ÅËÄÉÈáèÂõ†Á¥†
   - ÂêàÁêÜÁöÑÊï∞ÊçÆÁªìÊûÑËÆæËÆ°ÂèØ‰ª•ÊòæËëóÈôç‰ΩéGasÊ∂àËÄó

2. **ÁÆóÊ≥ïÂ§çÊùÇÂ∫¶‰ºòÂåñÁ≠ñÁï•**
   - Êó∂Èó¥Â§çÊùÇÂ∫¶‰ºòÂåñÔºöÁºìÂ≠ò„ÄÅÂä®ÊÄÅËßÑÂàí„ÄÅÂàÜÊ≤ªÊ≥ï
   - Á©∫Èó¥Â§çÊùÇÂ∫¶‰ºòÂåñÔºöÂéüÂú∞ÁÆóÊ≥ï„ÄÅ‰ΩçÊìç‰Ωú„ÄÅÊï∞ÊçÆÂéãÁº©
   - ÂÆûÈôÖÂ∫îÁî®‰∏≠ÈúÄË¶ÅÂú®Êó∂Èó¥ÂíåÁ©∫Èó¥‰πãÈó¥ÊâæÂà∞Âπ≥Ë°°

3. **Âå∫ÂùóÈìæÁâπÊúâÁöÑ‰ºòÂåñËÄÉËôë**
   - GasÊàêÊú¨‰ºòÂåñÊØî‰º†ÁªüÁöÑÊó∂Èó¥Â§çÊùÇÂ∫¶Êõ¥ÈáçË¶Å
   - ÊâπÂ§ÑÁêÜÊìç‰ΩúÂèØ‰ª•ÊúâÊïàÈôç‰Ωé‰∫§ÊòìÊàêÊú¨
   - Áä∂ÊÄÅÂèòÈáèÁöÑËØªÂÜôÊàêÊú¨Â∑ÆÂºÇÂ∑®Â§ß

4. **È´òÁ∫ßÁÆóÊ≥ïÁöÑÂÆûÈôÖÂ∫îÁî®**
   - ÂõæÁÆóÊ≥ïÂú®Âéª‰∏≠ÂøÉÂåñÁΩëÁªú‰∏≠ÁöÑÂ∫îÁî®
   - ÊéíÂ∫èÁÆóÊ≥ïÂú®Êï∞ÊçÆÂ§ÑÁêÜ‰∏≠ÁöÑÈÄâÊã©Á≠ñÁï•
   - ÊêúÁ¥¢ÁÆóÊ≥ïÂú®Â§ßËßÑÊ®°Êï∞ÊçÆÊü•ËØ¢‰∏≠ÁöÑ‰ºòÂåñ

### üîç Ê∑±Â∫¶ÊÄùËÄÉ

ÈÄöËøáËøôÊÆµÊó∂Èó¥ÁöÑÂ≠¶‰π†ÔºåÊàëÊ∑±ÂàªËÆ§ËØÜÂà∞ÁÆóÊ≥ïÂíåÊï∞ÊçÆÁªìÊûÑ‰∏ç‰ªÖ‰ªÖÊòØÁêÜËÆ∫Áü•ËØÜÔºåÊõ¥ÊòØËß£ÂÜ≥ÂÆûÈôÖÈóÆÈ¢òÁöÑÊúâÂäõÂ∑•ÂÖ∑„ÄÇÂú®Âå∫ÂùóÈìæÂºÄÂèë‰∏≠ÔºåÊØè‰∏ÄË°å‰ª£Á†ÅÈÉΩÂèØËÉΩÂΩ±ÂìçÂà∞Áî®Êà∑ÁöÑ‰ΩøÁî®ÊàêÊú¨ÔºåËøôËÆ©ÊàëÊõ¥Âä†ÈáçËßÜ‰ª£Á†ÅÁöÑÊïàÁéáÂíå‰ºòÂåñ„ÄÇ

ÁâπÂà´ÊòØÂú®ÂÆûÁé∞Â§çÊùÇÁÆóÊ≥ïÊó∂ÔºåÊàëÂ≠¶‰ºö‰∫ÜÂ¶Ç‰ΩïÂú®‰øùËØÅÂäüËÉΩÊ≠£Á°ÆÊÄßÁöÑÂâçÊèê‰∏ãÔºåÈÄöËøáÂ∑ßÂ¶ôÁöÑËÆæËÆ°Êù•Èôç‰ΩéËÆ°ÁÆóÂ§çÊùÇÂ∫¶ÂíåÂ≠òÂÇ®ÂºÄÈîÄ„ÄÇËøôÁßçÊÄùÁª¥ÊñπÂºè‰∏ç‰ªÖÈÄÇÁî®‰∫éÊô∫ËÉΩÂêàÁ∫¶ÂºÄÂèëÔºå‰πü‰∏∫Êàë‰ªäÂêéÁöÑËΩØ‰ª∂ÂºÄÂèëÁîüÊ∂ØÂ•†ÂÆö‰∫ÜÂùöÂÆûÁöÑÂü∫Á°Ä„ÄÇ

### üöÄ Êú™Êù•Â≠¶‰π†ÊñπÂêë

1. **È´òÁ∫ßÊï∞ÊçÆÁªìÊûÑÁ†îÁ©∂**
   - Ë∑≥Ë°®„ÄÅÁ∫¢ÈªëÊ†ëÁ≠âÂπ≥Ë°°Ê†ëÁªìÊûÑ
   - Â∏ÉÈöÜËøáÊª§Âô®ÁöÑÂèòÁßçÂíå‰ºòÂåñ
   - ÂàÜÂ∏ÉÂºèÊï∞ÊçÆÁªìÊûÑËÆæËÆ°

2. **ÁÆóÊ≥ï‰ºòÂåñÊ∑±ÂÖ•**
   - Âπ∂Ë°åÁÆóÊ≥ïËÆæËÆ°
   - Ëøë‰ººÁÆóÊ≥ïÂíåÂêØÂèëÂºèÁÆóÊ≥ï
   - Êú∫Âô®Â≠¶‰π†ÁÆóÊ≥ïÂú®Âå∫ÂùóÈìæ‰∏≠ÁöÑÂ∫îÁî®

3. **Âå∫ÂùóÈìæÁâπÂÆö‰ºòÂåñ**
   - Layer2Ëß£ÂÜ≥ÊñπÊ°àÁöÑÁÆóÊ≥ï‰ºòÂåñ
   - Ë∑®ÈìæÈÄö‰ø°ÁöÑÁÆóÊ≥ïËÆæËÆ°
   - ÂÖ±ËØÜÁÆóÊ≥ïÁöÑÊÄßËÉΩ‰ºòÂåñ

---

**Â≠¶‰π†ÊÑüÊÇüÔºö** ÁÆóÊ≥ïÂíåÊï∞ÊçÆÁªìÊûÑÊòØÁ®ãÂ∫èÂëòÁöÑÂÜÖÂäüÔºåËÄåÂú®Âå∫ÂùóÈìæËøô‰∏™Êñ∞ÂÖ¥È¢ÜÂüüÔºå‰º†ÁªüÁöÑ‰ºòÂåñÊÄùË∑ØÈúÄË¶ÅÁªìÂêàÊñ∞ÁöÑÁ∫¶ÊùüÊù°‰ª∂„ÄÇÊØè‰∏ÄÊ¨°‰ºòÂåñÈÉΩÊòØÂØπÈóÆÈ¢òÊú¨Ë¥®ÁöÑÊ∑±ÂÖ•ÁêÜËß£ÔºåÊØè‰∏Ä‰∏™ÁÆóÊ≥ïÁöÑÂÆûÁé∞ÈÉΩÊòØÂØπÁºñÁ®ãËÉΩÂäõÁöÑÊèêÂçá„ÄÇ

**Êó•ÊúüÔºö** 2024Âπ¥6Êúà20Êó•  
**Á≠æÂêçÔºö** Êù®Á®ãÂñÜ (2023111580)