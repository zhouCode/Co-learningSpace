# è¯¾å ‚é‡ç‚¹è®°å½•

> **å­¦ä¹ è€…**: æ¨ç¨‹å–†  
> **å­¦å·**: 2023111423  
> **å­¦ä¹ ç‰¹è‰²**: æ³¨é‡ç®—æ³•ä¼˜åŒ–å’Œæ•°æ®ç»“æ„  
> **ä»£ç é£æ ¼**: é«˜æ•ˆç®—æ³•å®ç°  
> **ç¬”è®°é‡ç‚¹**: é«˜æ•ˆç®—æ³•åº“è®¾è®¡ä¸å¤æ‚åº¦åˆ†æ  
> **é¡¹ç›®ä»£ç **: EfficientAlgorithms.sol - é«˜æ•ˆç®—æ³•åº“  
> **è®°å½•æ—¶é—´**: 2024å¹´æ˜¥å­£å­¦æœŸ

---

## ğŸ“š ç¬¬ä¸€å‘¨ï¼šæ™ºèƒ½åˆçº¦ç®—æ³•åŸºç¡€

### è¯¾å ‚ä¸»é¢˜ï¼šåŒºå—é“¾ä¸­çš„ç®—æ³•è®¾è®¡åŸåˆ™
**æ—¶é—´**: 2024å¹´3æœˆ4æ—¥  
**é‡ç‚¹å†…å®¹**:

#### 1. Gasä¼˜åŒ–ç®—æ³•è®¾è®¡
- **å¾ªç¯ä¼˜åŒ–**: å‡å°‘ä¸å¿…è¦çš„è¿­ä»£
- **å­˜å‚¨ä¼˜åŒ–**: åˆç†ä½¿ç”¨storageå’Œmemory
- **è®¡ç®—å¤æ‚åº¦**: æ—¶é—´ä¸ç©ºé—´çš„æƒè¡¡
- **æ‰¹å¤„ç†ç®—æ³•**: å‡å°‘äº¤æ˜“æ¬¡æ•°

#### 2. é«˜æ•ˆæ•°æ®ç»“æ„å®ç°
```solidity
// EfficientDataStructures.sol - é«˜æ•ˆæ•°æ®ç»“æ„åº“
library EfficientDataStructures {
    // âœ… åŠ¨æ€æ•°ç»„ç»“æ„
    struct DynamicArray {
        mapping(uint256 => uint256) data;
        uint256 length;
        uint256 capacity;
    }
    
    // âœ… å“ˆå¸Œè¡¨ç»“æ„
    struct HashTable {
        mapping(bytes32 => uint256) indices;
        mapping(uint256 => bytes32) keys;
        mapping(uint256 => uint256) values;
        uint256 size;
        uint256 capacity;
    }
    
    // âœ… ä¼˜å…ˆé˜Ÿåˆ—ï¼ˆæœ€å°å †ï¼‰
    struct PriorityQueue {
        mapping(uint256 => uint256) heap;
        uint256 size;
    }
    
    // âœ… å¹¶æŸ¥é›†ç»“æ„
    struct UnionFind {
        mapping(uint256 => uint256) parent;
        mapping(uint256 => uint256) rank;
        uint256 components;
    }
    
    // âœ… åŠ¨æ€æ•°ç»„æ“ä½œ
    function push(DynamicArray storage arr, uint256 value) internal {
        if (arr.length >= arr.capacity) {
            _resize(arr);
        }
        arr.data[arr.length] = value;
        arr.length++;
    }
    
    function pop(DynamicArray storage arr) internal returns (uint256) {
        require(arr.length > 0, "Array is empty");
        arr.length--;
        uint256 value = arr.data[arr.length];
        delete arr.data[arr.length];
        return value;
    }
    
    function get(DynamicArray storage arr, uint256 index) internal view returns (uint256) {
        require(index < arr.length, "Index out of bounds");
        return arr.data[index];
    }
    
    function set(DynamicArray storage arr, uint256 index, uint256 value) internal {
        require(index < arr.length, "Index out of bounds");
        arr.data[index] = value;
    }
    
    function _resize(DynamicArray storage arr) private {
        arr.capacity = arr.capacity == 0 ? 1 : arr.capacity * 2;
    }
    
    // âœ… å“ˆå¸Œè¡¨æ“ä½œ
    function put(HashTable storage table, bytes32 key, uint256 value) internal {
        bytes32 hash = keccak256(abi.encodePacked(key, block.timestamp));
        uint256 index = uint256(hash) % (table.capacity == 0 ? 16 : table.capacity);
        
        // çº¿æ€§æ¢æµ‹è§£å†³å†²çª
        while (table.keys[index] != bytes32(0) && table.keys[index] != key) {
            index = (index + 1) % table.capacity;
        }
        
        if (table.keys[index] == bytes32(0)) {
            table.size++;
        }
        
        table.keys[index] = key;
        table.values[index] = value;
        table.indices[key] = index;
        
        // è´Ÿè½½å› å­è¿‡é«˜æ—¶æ‰©å®¹
        if (table.size * 4 > table.capacity * 3) {
            _rehash(table);
        }
    }
    
    function get(HashTable storage table, bytes32 key) internal view returns (uint256) {
        uint256 index = table.indices[key];
        require(table.keys[index] == key, "Key not found");
        return table.values[index];
    }
    
    function remove(HashTable storage table, bytes32 key) internal {
        uint256 index = table.indices[key];
        require(table.keys[index] == key, "Key not found");
        
        delete table.keys[index];
        delete table.values[index];
        delete table.indices[key];
        table.size--;
    }
    
    function _rehash(HashTable storage table) private {
        // ç®€åŒ–å®ç°ï¼Œå®é™…éœ€è¦é‡æ–°åˆ†é…æ‰€æœ‰å…ƒç´ 
        table.capacity = table.capacity * 2;
    }
    
    // âœ… ä¼˜å…ˆé˜Ÿåˆ—æ“ä½œï¼ˆæœ€å°å †ï¼‰
    function insert(PriorityQueue storage pq, uint256 value) internal {
        pq.size++;
        pq.heap[pq.size] = value;
        _heapifyUp(pq, pq.size);
    }
    
    function extractMin(PriorityQueue storage pq) internal returns (uint256) {
        require(pq.size > 0, "Priority queue is empty");
        
        uint256 min = pq.heap[1];
        pq.heap[1] = pq.heap[pq.size];
        delete pq.heap[pq.size];
        pq.size--;
        
        if (pq.size > 0) {
            _heapifyDown(pq, 1);
        }
        
        return min;
    }
    
    function peek(PriorityQueue storage pq) internal view returns (uint256) {
        require(pq.size > 0, "Priority queue is empty");
        return pq.heap[1];
    }
    
    function _heapifyUp(PriorityQueue storage pq, uint256 index) private {
        while (index > 1) {
            uint256 parent = index / 2;
            if (pq.heap[index] >= pq.heap[parent]) break;
            
            // äº¤æ¢
            uint256 temp = pq.heap[index];
            pq.heap[index] = pq.heap[parent];
            pq.heap[parent] = temp;
            
            index = parent;
        }
    }
    
    function _heapifyDown(PriorityQueue storage pq, uint256 index) private {
        while (index * 2 <= pq.size) {
            uint256 leftChild = index * 2;
            uint256 rightChild = index * 2 + 1;
            uint256 smallest = index;
            
            if (pq.heap[leftChild] < pq.heap[smallest]) {
                smallest = leftChild;
            }
            
            if (rightChild <= pq.size && pq.heap[rightChild] < pq.heap[smallest]) {
                smallest = rightChild;
            }
            
            if (smallest == index) break;
            
            // äº¤æ¢
            uint256 temp = pq.heap[index];
            pq.heap[index] = pq.heap[smallest];
            pq.heap[smallest] = temp;
            
            index = smallest;
        }
    }
    
    // âœ… å¹¶æŸ¥é›†æ“ä½œ
    function makeSet(UnionFind storage uf, uint256 x) internal {
        if (uf.parent[x] == 0) {
            uf.parent[x] = x;
            uf.rank[x] = 0;
            uf.components++;
        }
    }
    
    function find(UnionFind storage uf, uint256 x) internal returns (uint256) {
        if (uf.parent[x] != x) {
            uf.parent[x] = find(uf, uf.parent[x]); // è·¯å¾„å‹ç¼©
        }
        return uf.parent[x];
    }
    
    function union(UnionFind storage uf, uint256 x, uint256 y) internal {
        uint256 rootX = find(uf, x);
        uint256 rootY = find(uf, y);
        
        if (rootX != rootY) {
            // æŒ‰ç§©åˆå¹¶
            if (uf.rank[rootX] < uf.rank[rootY]) {
                uf.parent[rootX] = rootY;
            } else if (uf.rank[rootX] > uf.rank[rootY]) {
                uf.parent[rootY] = rootX;
            } else {
                uf.parent[rootY] = rootX;
                uf.rank[rootX]++;
            }
            uf.components--;
        }
    }
    
    function connected(UnionFind storage uf, uint256 x, uint256 y) internal returns (bool) {
        return find(uf, x) == find(uf, y);
    }
}

// âœ… é«˜æ•ˆç®—æ³•åˆçº¦
contract EfficientAlgorithms {
    using EfficientDataStructures for EfficientDataStructures.DynamicArray;
    using EfficientDataStructures for EfficientDataStructures.HashTable;
    using EfficientDataStructures for EfficientDataStructures.PriorityQueue;
    using EfficientDataStructures for EfficientDataStructures.UnionFind;
    
    // âœ… æ•°æ®ç»“æ„å®ä¾‹
    EfficientDataStructures.DynamicArray private dynamicArray;
    EfficientDataStructures.HashTable private hashTable;
    EfficientDataStructures.PriorityQueue private priorityQueue;
    EfficientDataStructures.UnionFind private unionFind;
    
    // âœ… äº‹ä»¶å®šä¹‰
    event AlgorithmExecuted(string algorithmName, uint256 gasUsed, uint256 result);
    event DataStructureOperation(string operation, uint256 gasUsed);
    
    // âœ… äºŒåˆ†æŸ¥æ‰¾ç®—æ³•
    function binarySearch(
        uint256[] calldata sortedArray,
        uint256 target
    ) external pure returns (int256) {
        int256 left = 0;
        int256 right = int256(sortedArray.length) - 1;
        
        while (left <= right) {
            int256 mid = left + (right - left) / 2;
            
            if (sortedArray[uint256(mid)] == target) {
                return mid;
            } else if (sortedArray[uint256(mid)] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        
        return -1; // æœªæ‰¾åˆ°
    }
    
    // âœ… å¿«é€Ÿæ’åºç®—æ³•ï¼ˆGasä¼˜åŒ–ç‰ˆæœ¬ï¼‰
    function quickSort(uint256[] memory arr) public pure returns (uint256[] memory) {
        if (arr.length <= 1) return arr;
        
        _quickSortRecursive(arr, 0, int256(arr.length) - 1);
        return arr;
    }
    
    function _quickSortRecursive(
        uint256[] memory arr,
        int256 low,
        int256 high
    ) private pure {
        if (low < high) {
            int256 pivotIndex = _partition(arr, low, high);
            _quickSortRecursive(arr, low, pivotIndex - 1);
            _quickSortRecursive(arr, pivotIndex + 1, high);
        }
    }
    
    function _partition(
        uint256[] memory arr,
        int256 low,
        int256 high
    ) private pure returns (int256) {
        uint256 pivot = arr[uint256(high)];
        int256 i = low - 1;
        
        for (int256 j = low; j < high; j++) {
            if (arr[uint256(j)] <= pivot) {
                i++;
                // äº¤æ¢å…ƒç´ 
                uint256 temp = arr[uint256(i)];
                arr[uint256(i)] = arr[uint256(j)];
                arr[uint256(j)] = temp;
            }
        }
        
        // å°†pivotæ”¾åˆ°æ­£ç¡®ä½ç½®
        uint256 temp = arr[uint256(i + 1)];
        arr[uint256(i + 1)] = arr[uint256(high)];
        arr[uint256(high)] = temp;
        
        return i + 1;
    }
    
    // âœ… å½’å¹¶æ’åºç®—æ³•
    function mergeSort(uint256[] memory arr) public pure returns (uint256[] memory) {
        if (arr.length <= 1) return arr;
        
        uint256[] memory temp = new uint256[](arr.length);
        _mergeSortRecursive(arr, temp, 0, arr.length - 1);
        return arr;
    }
    
    function _mergeSortRecursive(
        uint256[] memory arr,
        uint256[] memory temp,
        uint256 left,
        uint256 right
    ) private pure {
        if (left < right) {
            uint256 mid = left + (right - left) / 2;
            _mergeSortRecursive(arr, temp, left, mid);
            _mergeSortRecursive(arr, temp, mid + 1, right);
            _merge(arr, temp, left, mid, right);
        }
    }
    
    function _merge(
        uint256[] memory arr,
        uint256[] memory temp,
        uint256 left,
        uint256 mid,
        uint256 right
    ) private pure {
        // å¤åˆ¶åˆ°ä¸´æ—¶æ•°ç»„
        for (uint256 i = left; i <= right; i++) {
            temp[i] = arr[i];
        }
        
        uint256 i = left;
        uint256 j = mid + 1;
        uint256 k = left;
        
        // åˆå¹¶ä¸¤ä¸ªæœ‰åºæ•°ç»„
        while (i <= mid && j <= right) {
            if (temp[i] <= temp[j]) {
                arr[k] = temp[i];
                i++;
            } else {
                arr[k] = temp[j];
                j++;
            }
            k++;
        }
        
        // å¤åˆ¶å‰©ä½™å…ƒç´ 
        while (i <= mid) {
            arr[k] = temp[i];
            i++;
            k++;
        }
        
        while (j <= right) {
            arr[k] = temp[j];
            j++;
            k++;
        }
    }
    
    // âœ… æœ€å¤§å­æ•°ç»„å’Œï¼ˆKadaneç®—æ³•ï¼‰
    function maxSubarraySum(int256[] calldata arr) external pure returns (int256) {
        if (arr.length == 0) return 0;
        
        int256 maxSoFar = arr[0];
        int256 maxEndingHere = arr[0];
        
        for (uint256 i = 1; i < arr.length; i++) {
            maxEndingHere = _max(arr[i], maxEndingHere + arr[i]);
            maxSoFar = _max(maxSoFar, maxEndingHere);
        }
        
        return maxSoFar;
    }
    
    // âœ… æœ€é•¿å…¬å…±å­åºåˆ—
    function longestCommonSubsequence(
        string calldata text1,
        string calldata text2
    ) external pure returns (uint256) {
        bytes memory s1 = bytes(text1);
        bytes memory s2 = bytes(text2);
        
        uint256 m = s1.length;
        uint256 n = s2.length;
        
        // åˆ›å»ºDPè¡¨
        uint256[][] memory dp = new uint256[][](m + 1);
        for (uint256 i = 0; i <= m; i++) {
            dp[i] = new uint256[](n + 1);
        }
        
        // åˆå§‹åŒ–è¾¹ç•Œæ¡ä»¶
        for (uint256 i = 0; i <= m; i++) {
            dp[i][0] = i;
        }
        for (uint256 j = 0; j <= n; j++) {
            dp[0][j] = j;
        }
        
        // å¡«å……DPè¡¨
        for (uint256 i = 1; i <= m; i++) {
            for (uint256 j = 1; j <= n; j++) {
                if (s1[i - 1] == s2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1];
                } else {
                    dp[i][j] = 1 + _min3(
                        dp[i - 1][j],     // åˆ é™¤
                        dp[i][j - 1],     // æ’å…¥
                        dp[i - 1][j - 1]  // æ›¿æ¢
                    );
                }
            }
        }
        
        return dp[m][n];
    }
    
    // âœ… æœ€å¤§å­çŸ©é˜µå’Œ
    function maxSubmatrixSum(int256[][] calldata matrix) external pure returns (int256) {
        if (matrix.length == 0 || matrix[0].length == 0) return 0;
        
        uint256 rows = matrix.length;
        uint256 cols = matrix[0].length;
        int256 maxSum = type(int256).min;
        
        // æšä¸¾æ‰€æœ‰å¯èƒ½çš„ä¸Šä¸‹è¾¹ç•Œ
        for (uint256 top = 0; top < rows; top++) {
            int256[] memory temp = new int256[](cols);
            
            for (uint256 bottom = top; bottom < rows; bottom++) {
                // å°†å½“å‰è¡ŒåŠ åˆ°ä¸´æ—¶æ•°ç»„
                for (uint256 j = 0; j < cols; j++) {
                    temp[j] += matrix[bottom][j];
                }
                
                // å¯¹ä¸´æ—¶æ•°ç»„åº”ç”¨Kadaneç®—æ³•
                int256 currentMax = _kadaneAlgorithm(temp);
                maxSum = _maxInt(maxSum, currentMax);
            }
        }
        
        return maxSum;
    }
    
    function _kadaneAlgorithm(int256[] memory arr) private pure returns (int256) {
        int256 maxSoFar = arr[0];
        int256 maxEndingHere = arr[0];
        
        for (uint256 i = 1; i < arr.length; i++) {
            maxEndingHere = _maxInt(arr[i], maxEndingHere + arr[i]);
            maxSoFar = _maxInt(maxSoFar, maxEndingHere);
        }
        
        return maxSoFar;
    }
    
    // âœ… ç¡¬å¸æ‰¾é›¶é—®é¢˜
    function coinChange(
        uint256[] calldata coins,
        uint256 amount
    ) external pure returns (uint256) {
        uint256[] memory dp = new uint256[](amount + 1);
        
        // åˆå§‹åŒ–ä¸ºæœ€å¤§å€¼ï¼ˆè¡¨ç¤ºä¸å¯èƒ½ï¼‰
        for (uint256 i = 1; i <= amount; i++) {
            dp[i] = type(uint256).max;
        }
        
        dp[0] = 0; // 0å…ƒéœ€è¦0ä¸ªç¡¬å¸
        
        // å¡«å……DPæ•°ç»„
        for (uint256 i = 1; i <= amount; i++) {
            for (uint256 j = 0; j < coins.length; j++) {
                if (coins[j] <= i && dp[i - coins[j]] != type(uint256).max) {
                    dp[i] = _min(dp[i], dp[i - coins[j]] + 1);
                }
            }
        }
        
        return dp[amount] == type(uint256).max ? 0 : dp[amount];
    }
    
    // âœ… æœ€é•¿å›æ–‡å­åºåˆ—
    function longestPalindromicSubsequence(string calldata s) external pure returns (uint256) {
        bytes memory str = bytes(s);
        uint256 n = str.length;
        
        if (n == 0) return 0;
        
        // åˆ›å»ºDPè¡¨
        uint256[][] memory dp = new uint256[][](n);
        for (uint256 i = 0; i < n; i++) {
            dp[i] = new uint256[](n);
            dp[i][i] = 1; // å•ä¸ªå­—ç¬¦çš„å›æ–‡é•¿åº¦ä¸º1
        }
        
        // å¡«å……DPè¡¨
        for (uint256 len = 2; len <= n; len++) {
            for (uint256 i = 0; i <= n - len; i++) {
                uint256 j = i + len - 1;
                
                if (str[i] == str[j]) {
                    dp[i][j] = dp[i + 1][j - 1] + 2;
                } else {
                    dp[i][j] = _max(dp[i + 1][j], dp[i][j - 1]);
                }
            }
        }
        
        return dp[0][n - 1];
    }
    
    // âœ… å·¥å…·å‡½æ•°
    function _max(uint256 a, uint256 b) private pure returns (uint256) {
        return a > b ? a : b;
    }
    
    function _min(uint256 a, uint256 b) private pure returns (uint256) {
        return a < b ? a : b;
    }
    
    function _min3(uint256 a, uint256 b, uint256 c) private pure returns (uint256) {
        return _min(_min(a, b), c);
    }
    
    function _maxInt(int256 a, int256 b) private pure returns (int256) {
        return a > b ? a : b;
    }
    
    // âœ… æ¸…é™¤è®°å¿†åŒ–ç¼“å­˜
    function clearFibonacciMemo() external {
        // æ³¨æ„ï¼šåœ¨å®é™…åº”ç”¨ä¸­ï¼Œå¯èƒ½éœ€è¦æ›´é«˜æ•ˆçš„æ¸…é™¤æ–¹æ³•
        for (uint256 i = 0; i < 100; i++) {
            delete fibMemo[i];
        }
    }
}
```

**ä¼˜åŒ–ç­–ç•¥**: è®°å¿†åŒ–æœç´¢å‡å°‘é‡å¤è®¡ç®—ï¼Œç©ºé—´ä¼˜åŒ–é™ä½å­˜å‚¨æˆæœ¬

---

## ğŸ“š ç¬¬äº”å‘¨ï¼šå­—ç¬¦ä¸²ç®—æ³•ä¸æ¨¡å¼åŒ¹é…

### è¯¾å ‚ä¸»é¢˜ï¼šé«˜æ•ˆå­—ç¬¦ä¸²å¤„ç†ç®—æ³•
**æ—¶é—´**: 2024å¹´4æœˆ1æ—¥  
**é‡ç‚¹å†…å®¹**:

#### 1. å­—ç¬¦ä¸²åŒ¹é…ç®—æ³•
```solidity
// StringAlgorithms.sol - å­—ç¬¦ä¸²ç®—æ³•åº“
contract StringAlgorithms {
    // âœ… äº‹ä»¶å®šä¹‰
    event StringAlgorithmExecuted(
        string algorithmName,
        uint256 textLength,
        uint256 patternLength,
        int256 result,
        uint256 gasUsed
    );
    
    // âœ… KMPç®—æ³•
    function kmpSearch(
        string calldata text,
        string calldata pattern
    ) external returns (int256) {
        uint256 gasBefore = gasleft();
        
        bytes memory textBytes = bytes(text);
        bytes memory patternBytes = bytes(pattern);
        
        if (patternBytes.length == 0) return 0;
        if (textBytes.length < patternBytes.length) return -1;
        
        // æ„å»ºå¤±æ•ˆå‡½æ•°ï¼ˆéƒ¨åˆ†åŒ¹é…è¡¨ï¼‰
        uint256[] memory lps = _computeLPSArray(patternBytes);
        
        uint256 i = 0; // textçš„ç´¢å¼•
        uint256 j = 0; // patternçš„ç´¢å¼•
        
        while (i < textBytes.length) {
            if (patternBytes[j] == textBytes[i]) {
                i++;
                j++;
            }
            
            if (j == patternBytes.length) {
                uint256 gasUsed = gasBefore - gasleft();
                emit StringAlgorithmExecuted(
                    "KMP",
                    textBytes.length,
                    patternBytes.length,
                    int256(i - j),
                    gasUsed
                );
                return int256(i - j);
            } else if (i < textBytes.length && patternBytes[j] != textBytes[i]) {
                if (j != 0) {
                    j = lps[j - 1];
                } else {
                    i++;
                }
            }
        }
        
        uint256 gasUsed = gasBefore - gasleft();
        emit StringAlgorithmExecuted(
            "KMP",
            textBytes.length,
            patternBytes.length,
            -1,
            gasUsed
        );
        return -1;
    }
    
    function _computeLPSArray(bytes memory pattern) private pure returns (uint256[] memory) {
        uint256[] memory lps = new uint256[](pattern.length);
        uint256 len = 0;
        uint256 i = 1;
        
        lps[0] = 0;
        
        while (i < pattern.length) {
            if (pattern[i] == pattern[len]) {
                len++;
                lps[i] = len;
                i++;
            } else {
                if (len != 0) {
                    len = lps[len - 1];
                } else {
                    lps[i] = 0;
                    i++;
                }
            }
        }
        
        return lps;
    }
    
    // âœ… Rabin-Karpç®—æ³•ï¼ˆæ»šåŠ¨å“ˆå¸Œï¼‰
    function rabinKarpSearch(
        string calldata text,
        string calldata pattern
    ) external pure returns (int256) {
        bytes memory textBytes = bytes(text);
        bytes memory patternBytes = bytes(pattern);
        
        uint256 n = textBytes.length;
        uint256 m = patternBytes.length;
        
        if (m > n) return -1;
        
        uint256 prime = 101; // è´¨æ•°
        uint256 base = 256;  // å­—ç¬¦é›†å¤§å°
        
        uint256 patternHash = 0;
        uint256 textHash = 0;
        uint256 h = 1;
        
        // è®¡ç®—h = base^(m-1) % prime
        for (uint256 i = 0; i < m - 1; i++) {
            h = (h * base) % prime;
        }
        
        // è®¡ç®—æ¨¡å¼å’Œæ–‡æœ¬ç¬¬ä¸€ä¸ªçª—å£çš„å“ˆå¸Œå€¼
        for (uint256 i = 0; i < m; i++) {
            patternHash = (base * patternHash + uint256(uint8(patternBytes[i]))) % prime;
            textHash = (base * textHash + uint256(uint8(textBytes[i]))) % prime;
        }
        
        // æ»‘åŠ¨çª—å£
        for (uint256 i = 0; i <= n - m; i++) {
            if (patternHash == textHash) {
                // å“ˆå¸Œå€¼åŒ¹é…ï¼Œè¿›è¡Œå­—ç¬¦æ¯”è¾ƒ
                bool match = true;
                for (uint256 j = 0; j < m; j++) {
                    if (textBytes[i + j] != patternBytes[j]) {
                        match = false;
                        break;
                    }
                }
                if (match) {
                    return int256(i);
                }
            }
            
            // è®¡ç®—ä¸‹ä¸€ä¸ªçª—å£çš„å“ˆå¸Œå€¼
            if (i < n - m) {
                textHash = (base * (textHash - uint256(uint8(textBytes[i])) * h) + 
                           uint256(uint8(textBytes[i + m]))) % prime;
                
                // å¤„ç†è´Ÿæ•°æƒ…å†µ
                if (textHash < 0) {
                    textHash = textHash + prime;
                }
            }
        }
        
        return -1;
    }
    
    // âœ… Boyer-Mooreç®—æ³•ï¼ˆç®€åŒ–ç‰ˆï¼‰
    function boyerMooreSearch(
        string calldata text,
        string calldata pattern
    ) external pure returns (int256) {
        bytes memory textBytes = bytes(text);
        bytes memory patternBytes = bytes(pattern);
        
        uint256 n = textBytes.length;
        uint256 m = patternBytes.length;
        
        if (m > n) return -1;
        
        // æ„å»ºåå­—ç¬¦è¡¨
        mapping(bytes1 => int256) badChar;
        for (uint256 i = 0; i < m; i++) {
            badChar[patternBytes[i]] = int256(i);
        }
        
        uint256 s = 0; // æ–‡æœ¬ä¸­çš„åç§»
        
        while (s <= n - m) {
            int256 j = int256(m) - 1;
            
            // ä»å³åˆ°å·¦åŒ¹é…
            while (j >= 0 && patternBytes[uint256(j)] == textBytes[s + uint256(j)]) {
                j--;
            }
            
            if (j < 0) {
                return int256(s);
            } else {
                // ä½¿ç”¨åå­—ç¬¦è§„åˆ™è®¡ç®—åç§»
                int256 badCharShift = j - badChar[textBytes[s + uint256(j)]];
                s += uint256(_maxInt(1, badCharShift));
            }
        }
        
        return -1;
    }
    
    // âœ… Zç®—æ³•ï¼ˆçº¿æ€§æ—¶é—´å­—ç¬¦ä¸²åŒ¹é…ï¼‰
    function zAlgorithm(string calldata s) external pure returns (uint256[] memory) {
        bytes memory str = bytes(s);
        uint256 n = str.length;
        
        if (n == 0) {
            return new uint256[](0);
        }
        
        uint256[] memory z = new uint256[](n);
        uint256 l = 0;
        uint256 r = 0;
        
        for (uint256 i = 1; i < n; i++) {
            if (i <= r) {
                z[i] = _min(r - i + 1, z[i - l]);
            }
            
            while (i + z[i] < n && str[z[i]] == str[i + z[i]]) {
                z[i]++;
            }
            
            if (i + z[i] - 1 > r) {
                l = i;
                r = i + z[i] - 1;
            }
        }
        
        return z;
    }
    
    // âœ… æœ€é•¿å…¬å…±å‰ç¼€
    function longestCommonPrefix(string[] calldata strs) external pure returns (string memory) {
        if (strs.length == 0) return "";
        
        bytes memory first = bytes(strs[0]);
        uint256 minLen = first.length;
        
        // æ‰¾åˆ°æœ€çŸ­å­—ç¬¦ä¸²é•¿åº¦
        for (uint256 i = 1; i < strs.length; i++) {
            bytes memory current = bytes(strs[i]);
            if (current.length < minLen) {
                minLen = current.length;
            }
        }
        
        // é€å­—ç¬¦æ¯”è¾ƒ
        for (uint256 i = 0; i < minLen; i++) {
            bytes1 char = first[i];
            for (uint256 j = 1; j < strs.length; j++) {
                if (bytes(strs[j])[i] != char) {
                    return string(_substring(first, 0, i));
                }
            }
        }
        
        return string(_substring(first, 0, minLen));
    }
    
    // âœ… å­—ç¬¦ä¸²åè½¬
    function reverseString(string calldata s) external pure returns (string memory) {
        bytes memory str = bytes(s);
        bytes memory reversed = new bytes(str.length);
        
        for (uint256 i = 0; i < str.length; i++) {
            reversed[i] = str[str.length - 1 - i];
        }
        
        return string(reversed);
    }
    
    // âœ… å›æ–‡æ£€æµ‹
    function isPalindrome(string calldata s) external pure returns (bool) {
        bytes memory str = bytes(s);
        uint256 left = 0;
        uint256 right = str.length - 1;
        
        while (left < right) {
            if (str[left] != str[right]) {
                return false;
            }
            left++;
            right--;
        }
        
        return true;
    }
    
    // âœ… å­—ç¬¦ä¸²å‹ç¼©ï¼ˆç®€å•ç‰ˆæœ¬ï¼‰
    function compressString(string calldata s) external pure returns (string memory) {
        bytes memory str = bytes(s);
        if (str.length == 0) return s;
        
        bytes memory compressed = new bytes(str.length * 2); // æœ€åæƒ…å†µ
        uint256 compressedIndex = 0;
        
        uint256 count = 1;
        bytes1 currentChar = str[0];
        
        for (uint256 i = 1; i < str.length; i++) {
            if (str[i] == currentChar) {
                count++;
            } else {
                // æ·»åŠ å­—ç¬¦å’Œè®¡æ•°
                compressed[compressedIndex++] = currentChar;
                
                // å°†è®¡æ•°è½¬æ¢ä¸ºå­—ç¬¦ä¸²
                bytes memory countStr = _uintToBytes(count);
                for (uint256 j = 0; j < countStr.length; j++) {
                    compressed[compressedIndex++] = countStr[j];
                }
                
                currentChar = str[i];
                count = 1;
            }
        }
        
        // å¤„ç†æœ€åä¸€ä¸ªå­—ç¬¦
        compressed[compressedIndex++] = currentChar;
        bytes memory countStr = _uintToBytes(count);
        for (uint256 j = 0; j < countStr.length; j++) {
            compressed[compressedIndex++] = countStr[j];
        }
        
        // åˆ›å»ºæ­£ç¡®å¤§å°çš„ç»“æœ
        bytes memory result = new bytes(compressedIndex);
        for (uint256 i = 0; i < compressedIndex; i++) {
            result[i] = compressed[i];
        }
        
        return string(result);
    }
    
    // âœ… å·¥å…·å‡½æ•°
    function _substring(
        bytes memory str,
        uint256 start,
        uint256 end
    ) private pure returns (bytes memory) {
        bytes memory result = new bytes(end - start);
        for (uint256 i = start; i < end; i++) {
            result[i - start] = str[i];
        }
        return result;
    }
    
    function _uintToBytes(uint256 value) private pure returns (bytes memory) {
        if (value == 0) {
            return "0";
        }
        
        uint256 temp = value;
        uint256 digits = 0;
        
        while (temp != 0) {
            digits++;
            temp /= 10;
        }
        
        bytes memory buffer = new bytes(digits);
        
        while (value != 0) {
            digits -= 1;
            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));
            value /= 10;
        }
        
        return buffer;
    }
    
    function _min(uint256 a, uint256 b) private pure returns (uint256) {
        return a < b ? a : b;
    }
    
    function _maxInt(int256 a, int256 b) private pure returns (int256) {
        return a > b ? a : b;
    }
}
```

**æ¨¡å¼åŒ¹é…**: KMPç®—æ³•O(n+m)æ—¶é—´å¤æ‚åº¦ï¼ŒRabin-Karpå¹³å‡O(n+m)

---

## ğŸ“š ç¬¬å…­å‘¨ï¼šé«˜çº§ç®—æ³•ä¼˜åŒ–ä¸Gasåˆ†æ

### è¯¾å ‚ä¸»é¢˜ï¼šæ™ºèƒ½åˆçº¦ç®—æ³•çš„Gasä¼˜åŒ–ç­–ç•¥
**æ—¶é—´**: 2024å¹´4æœˆ8æ—¥  
**é‡ç‚¹å†…å®¹**:

#### 1. Gasä¼˜åŒ–æŠ€æœ¯
```solidity
// GasOptimizedAlgorithms.sol - Gasä¼˜åŒ–ç®—æ³•åº“
contract GasOptimizedAlgorithms {
    // âœ… ä¼˜åŒ–çš„æ•°æ®ç»“æ„
    struct OptimizedArray {
        mapping(uint256 => uint256) data;
        uint256 length;
    }
    
    // âœ… ä½è¿ç®—ä¼˜åŒ–
    function fastPowerOfTwo(uint256 n) external pure returns (bool) {
        return n > 0 && (n & (n - 1)) == 0;
    }
    
    function fastMultiplyByPowerOfTwo(uint256 x, uint256 n) external pure returns (uint256) {
        return x << n; // ç›¸å½“äº x * (2^n)
    }
    
    function fastDivideByPowerOfTwo(uint256 x, uint256 n) external pure returns (uint256) {
        return x >> n; // ç›¸å½“äº x / (2^n)
    }
    
    // âœ… å¾ªç¯ä¼˜åŒ–
    function optimizedSum(uint256[] calldata arr) external pure returns (uint256) {
        uint256 sum = 0;
        uint256 len = arr.length;
        
        // å¾ªç¯å±•å¼€ä¼˜åŒ–
        uint256 i = 0;
        for (; i + 3 < len; i += 4) {
            sum += arr[i] + arr[i + 1] + arr[i + 2] + arr[i + 3];
        }
        
        // å¤„ç†å‰©ä½™å…ƒç´ 
        for (; i < len; i++) {
            sum += arr[i];
        }
        
        return sum;
    }
    
    // âœ… å†…å­˜ä¼˜åŒ–çš„æ’åº
    function optimizedQuickSort(uint256[] memory arr) external pure returns (uint256[] memory) {
        if (arr.length <= 1) return arr;
        
        _optimizedQuickSortInPlace(arr, 0, int256(arr.length) - 1);
        return arr;
    }
    
    function _optimizedQuickSortInPlace(
        uint256[] memory arr,
        int256 low,
        int256 high
    ) private pure {
        while (low < high) {
            // å°æ•°ç»„ä½¿ç”¨æ’å…¥æ’åº
            if (high - low < 10) {
                _insertionSort(arr, uint256(low), uint256(high));
                break;
            }
            
            int256 pivotIndex = _optimizedPartition(arr, low, high);
            
            // å°¾é€’å½’ä¼˜åŒ–ï¼šæ€»æ˜¯é€’å½’è¾ƒå°çš„éƒ¨åˆ†
            if (pivotIndex - low < high - pivotIndex) {
                _optimizedQuickSortInPlace(arr, low, pivotIndex - 1);
                low = pivotIndex + 1;
            } else {
                _optimizedQuickSortInPlace(arr, pivotIndex + 1, high);
                high = pivotIndex - 1;
            }
        }
    }
    
    function _optimizedPartition(
        uint256[] memory arr,
        int256 low,
        int256 high
    ) private pure returns (int256) {
        // ä¸‰æ•°å–ä¸­æ³•é€‰æ‹©pivot
        int256 mid = low + (high - low) / 2;
        
        if (arr[uint256(mid)] < arr[uint256(low)]) {
            _swap(arr, uint256(low), uint256(mid));
        }
        if (arr[uint256(high)] < arr[uint256(low)]) {
            _swap(arr, uint256(low), uint256(high));
        }
        if (arr[uint256(high)] < arr[uint256(mid)]) {
            _swap(arr, uint256(mid), uint256(high));
        }
        
        _swap(arr, uint256(mid), uint256(high));
        
        uint256 pivot = arr[uint256(high)];
        int256 i = low - 1;
        
        for (int256 j = low; j < high; j++) {
            if (arr[uint256(j)] <= pivot) {
                i++;
                _swap(arr, uint256(i), uint256(j));
            }
        }
        
        _swap(arr, uint256(i + 1), uint256(high));
        return i + 1;
    }
    
    function _insertionSort(
        uint256[] memory arr,
        uint256 start,
        uint256 end
    ) private pure {
        for (uint256 i = start + 1; i <= end; i++) {
            uint256 key = arr[i];
            uint256 j = i;
            
            while (j > start && arr[j - 1] > key) {
                arr[j] = arr[j - 1];
                j--;
            }
            
            arr[j] = key;
        }
    }
    
    function _swap(uint256[] memory arr, uint256 i, uint256 j) private pure {
        uint256 temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
    
    // âœ… æ‰¹é‡æ“ä½œä¼˜åŒ–
    function batchProcess(
        uint256[] calldata inputs,
        uint256 operation // 0: square, 1: double, 2: increment
    ) external pure returns (uint256[] memory) {
        uint256[] memory results = new uint256[](inputs.length);
        
        if (operation == 0) {
            // å¹³æ–¹æ“ä½œ
            for (uint256 i = 0; i < inputs.length; i++) {
                results[i] = inputs[i] * inputs[i];
            }
        } else if (operation == 1) {
            // åŒå€æ“ä½œ
            for (uint256 i = 0; i < inputs.length; i++) {
                results[i] = inputs[i] << 1; // ä½è¿ç®—ä¼˜åŒ–
            }
        } else if (operation == 2) {
            // é€’å¢æ“ä½œ
            for (uint256 i = 0; i < inputs.length; i++) {
                results[i] = inputs[i] + 1;
            }
        }
        
        return results;
    }
}
```

**Gasåˆ†æ**: ä½è¿ç®—æ¯”ä¹˜é™¤æ³•èŠ‚çœGasï¼Œå¾ªç¯å±•å¼€å‡å°‘è·³è½¬å¼€é”€

---

## ğŸ¯ å­¦ä¹ å¿ƒå¾—ä¸æ€»ç»“

### æ ¸å¿ƒç®—æ³•æŒæ¡
1. **æ•°æ®ç»“æ„ç²¾é€š**: åŠ¨æ€æ•°ç»„ã€å“ˆå¸Œè¡¨ã€ä¼˜å…ˆé˜Ÿåˆ—ã€å¹¶æŸ¥é›†
2. **æ’åºç®—æ³•ä¼˜åŒ–**: å¿«é€Ÿæ’åºã€å½’å¹¶æ’åºçš„Gasä¼˜åŒ–ç‰ˆæœ¬
3. **å›¾ç®—æ³•åº”ç”¨**: DFSã€BFSã€æœ€çŸ­è·¯å¾„ã€æœ€å°ç”Ÿæˆæ ‘
4. **åŠ¨æ€è§„åˆ’**: èƒŒåŒ…é—®é¢˜ã€æœ€é•¿å­åºåˆ—ã€ç¼–è¾‘è·ç¦»
5. **å­—ç¬¦ä¸²ç®—æ³•**: KMPã€Rabin-Karpã€Boyer-Mooreæ¨¡å¼åŒ¹é…

### ç®—æ³•å¤æ‚åº¦åˆ†æ
- **æ—¶é—´å¤æ‚åº¦**: ä»O(nÂ²)ä¼˜åŒ–åˆ°O(n log n)æˆ–O(n)
- **ç©ºé—´å¤æ‚åº¦**: åˆç†ä½¿ç”¨memoryå’Œstorage
- **Gaså¤æ‚åº¦**: ä½è¿ç®—ã€å¾ªç¯å±•å¼€ã€æ‰¹é‡å¤„ç†ä¼˜åŒ–

### å®è·µé¡¹ç›®æˆæœ
- **é«˜æ•ˆç®—æ³•åº“**: 15+æ ¸å¿ƒç®—æ³•çš„Solidityå®ç°
- **æ€§èƒ½åŸºå‡†æµ‹è¯•**: Gasæ¶ˆè€—å¯¹æ¯”åˆ†æ
- **ä¼˜åŒ–ç­–ç•¥æ€»ç»“**: 10+ç§Gasä¼˜åŒ–æŠ€æœ¯

### æœªæ¥å‘å±•æ–¹å‘
1. **é‡å­ç®—æ³•**: ç ”ç©¶é‡å­è®¡ç®—åœ¨åŒºå—é“¾ä¸­çš„åº”ç”¨
2. **å¹¶è¡Œç®—æ³•**: å¤šçº¿ç¨‹ä¼˜åŒ–ç­–ç•¥
3. **æœºå™¨å­¦ä¹ ç®—æ³•**: é“¾ä¸ŠAIç®—æ³•å®ç°
4. **å¯†ç å­¦ç®—æ³•**: é›¶çŸ¥è¯†è¯æ˜ã€åŒæ€åŠ å¯†

---

## ğŸ“š å‚è€ƒèµ„æº

### ç®—æ³•ä¹¦ç±
- ã€Šç®—æ³•å¯¼è®ºã€‹- Cormen, Leiserson, Rivest, Stein
- ã€Šç®—æ³•ã€‹ç¬¬4ç‰ˆ - Robert Sedgewick
- ã€Šç¼–ç¨‹ç ç‘ã€‹- Jon Bentley

### åœ¨çº¿èµ„æº
- [LeetCodeç®—æ³•é¢˜åº“](https://leetcode.com/)
- [GeeksforGeeksç®—æ³•æ•™ç¨‹](https://www.geeksforgeeks.org/)
- [Solidity Gasä¼˜åŒ–æŒ‡å—](https://docs.soliditylang.org/)

### å¼€æºé¡¹ç›®
- [OpenZeppelinç®—æ³•åº“](https://github.com/OpenZeppelin/openzeppelin-contracts)
- [Solidityç®—æ³•å®ç°](https://github.com/ethereum/solidity-examples)

---

*"ç®—æ³•æ˜¯ç¨‹åºçš„çµé­‚ï¼Œä¼˜åŒ–æ˜¯æ™ºèƒ½åˆçº¦çš„ç”Ÿå‘½ã€‚"* - æ¨ç¨‹å–†
        for (uint256 i = 0; i <= m; i++) {
            dp[i] = new uint256[](n + 1);
        }
        
        // å¡«å……DPè¡¨
        for (uint256 i = 1; i <= m; i++) {
            for (uint256 j = 1; j <= n; j++) {
                if (s1[i - 1] == s2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = _max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        
        return dp[m][n];
    }
    
    // âœ… å›¾ç®—æ³•ï¼šDijkstraæœ€çŸ­è·¯å¾„
    function dijkstra(
        uint256[][] calldata graph,
        uint256 source
    ) external pure returns (uint256[] memory) {
        uint256 n = graph.length;
        uint256[] memory dist = new uint256[](n);
        bool[] memory visited = new bool[](n);
        
        // åˆå§‹åŒ–è·ç¦»
        for (uint256 i = 0; i < n; i++) {
            dist[i] = type(uint256).max;
        }
        dist[source] = 0;
        
        // ä¸»å¾ªç¯
        for (uint256 count = 0; count < n - 1; count++) {
            uint256 u = _minDistance(dist, visited);
            visited[u] = true;
            
            // æ›´æ–°ç›¸é‚»èŠ‚ç‚¹çš„è·ç¦»
            for (uint256 v = 0; v < n; v++) {
                if (!visited[v] && graph[u][v] != 0 && 
                    dist[u] != type(uint256).max && 
                    dist[u] + graph[u][v] < dist[v]) {
                    dist[v] = dist[u] + graph[u][v];
                }
            }
        }
        
        return dist;
    }
    
    function _minDistance(
        uint256[] memory dist,
        bool[] memory visited
    ) private pure returns (uint256) {
        uint256 min = type(uint256).max;
        uint256 minIndex = 0;
        
        for (uint256 v = 0; v < dist.length; v++) {
            if (!visited[v] && dist[v] <= min) {
                min = dist[v];
                minIndex = v;
            }
        }
        
        return minIndex;
    }
    
    // âœ… å·¥å…·å‡½æ•°
    function _max(int256 a, int256 b) private pure returns (int256) {
        return a > b ? a : b;
    }
    
    function _max(uint256 a, uint256 b) private pure returns (uint256) {
        return a > b ? a : b;
    }
    
    // âœ… æ•°æ®ç»“æ„æ“ä½œæ¥å£
    function pushToArray(uint256 value) external {
        uint256 gasBefore = gasleft();
        dynamicArray.push(value);
        uint256 gasUsed = gasBefore - gasleft();
        emit DataStructureOperation("push", gasUsed);
    }
    
    function popFromArray() external returns (uint256) {
        uint256 gasBefore = gasleft();
        uint256 value = dynamicArray.pop();
        uint256 gasUsed = gasBefore - gasleft();
        emit DataStructureOperation("pop", gasUsed);
        return value;
    }
    
    function insertToPriorityQueue(uint256 value) external {
        uint256 gasBefore = gasleft();
        priorityQueue.insert(value);
        uint256 gasUsed = gasBefore - gasleft();
        emit DataStructureOperation("priorityQueue_insert", gasUsed);
    }
    
    function extractMinFromPriorityQueue() external returns (uint256) {
        uint256 gasBefore = gasleft();
        uint256 value = priorityQueue.extractMin();
        uint256 gasUsed = gasBefore - gasleft();
        emit DataStructureOperation("priorityQueue_extractMin", gasUsed);
        return value;
    }
    
    function putToHashTable(bytes32 key, uint256 value) external {
        uint256 gasBefore = gasleft();
        hashTable.put(key, value);
        uint256 gasUsed = gasBefore - gasleft();
        emit DataStructureOperation("hashTable_put", gasUsed);
    }
    
    function getFromHashTable(bytes32 key) external view returns (uint256) {
        return hashTable.get(key);
    }
    
    function unionFindMakeSet(uint256 x) external {
        unionFind.makeSet(x);
    }
    
    function unionFindUnion(uint256 x, uint256 y) external {
        unionFind.union(x, y);
    }
    
    function unionFindConnected(uint256 x, uint256 y) external returns (bool) {
        return unionFind.connected(x, y);
    }
}
```

**ç®—æ³•åˆ†æ**: æ—¶é—´å¤æ‚åº¦O(log n)çš„äºŒåˆ†æŸ¥æ‰¾ï¼ŒO(n log n)çš„æ’åºç®—æ³•

---

## ğŸ“š ç¬¬äºŒå‘¨ï¼šé«˜çº§æ•°æ®ç»“æ„

### è¯¾å ‚ä¸»é¢˜ï¼šåŒºå—é“¾ä¸­çš„é«˜çº§æ•°æ®ç»“æ„
**æ—¶é—´**: 2024å¹´3æœˆ11æ—¥  
**é‡ç‚¹å†…å®¹**:

#### 1. æ ‘å½¢æ•°æ®ç»“æ„
```solidity
// AdvancedTrees.sol - é«˜çº§æ ‘ç»“æ„
contract AdvancedTrees {
    // âœ… äºŒå‰æœç´¢æ ‘èŠ‚ç‚¹
    struct BSTNode {
        uint256 value;
        uint256 left;
        uint256 right;
        bool exists;
    }
    
    // âœ… AVLæ ‘èŠ‚ç‚¹
    struct AVLNode {
        uint256 value;
        uint256 left;
        uint256 right;
        uint256 height;
        bool exists;
    }
    
    // âœ… å­—å…¸æ ‘èŠ‚ç‚¹
    struct TrieNode {
        mapping(bytes1 => uint256) children;
        bool isEndOfWord;
        bool exists;
    }
    
    mapping(uint256 => BSTNode) private bstNodes;
    mapping(uint256 => AVLNode) private avlNodes;
    mapping(uint256 => TrieNode) private trieNodes;
    
    uint256 private nextNodeId = 1;
    uint256 public bstRoot;
    uint256 public avlRoot;
    uint256 public trieRoot;
    
    event TreeOperation(string treeType, string operation, uint256 value, uint256 gasUsed);
    
    constructor() {
        // åˆå§‹åŒ–å­—å…¸æ ‘æ ¹èŠ‚ç‚¹
        trieRoot = nextNodeId++;
        trieNodes[trieRoot].exists = true;
    }
    
    // âœ… äºŒå‰æœç´¢æ ‘æ“ä½œ
    function bstInsert(uint256 value) external {
        uint256 gasBefore = gasleft();
        bstRoot = _bstInsertRecursive(bstRoot, value);
        uint256 gasUsed = gasBefore - gasleft();
        emit TreeOperation("BST", "insert", value, gasUsed);
    }
    
    function _bstInsertRecursive(uint256 nodeId, uint256 value) private returns (uint256) {
        if (nodeId == 0 || !bstNodes[nodeId].exists) {
            uint256 newNodeId = nextNodeId++;
            bstNodes[newNodeId] = BSTNode({
                value: value,
                left: 0,
                right: 0,
                exists: true
            });
            return newNodeId;
        }
        
        if (value < bstNodes[nodeId].value) {
            bstNodes[nodeId].left = _bstInsertRecursive(bstNodes[nodeId].left, value);
        } else if (value > bstNodes[nodeId].value) {
            bstNodes[nodeId].right = _bstInsertRecursive(bstNodes[nodeId].right, value);
        }
        
        return nodeId;
    }
    
    function bstSearch(uint256 value) external view returns (bool) {
        return _bstSearchRecursive(bstRoot, value);
    }
    
    function _bstSearchRecursive(uint256 nodeId, uint256 value) private view returns (bool) {
        if (nodeId == 0 || !bstNodes[nodeId].exists) {
            return false;
        }
        
        if (bstNodes[nodeId].value == value) {
            return true;
        } else if (value < bstNodes[nodeId].value) {
            return _bstSearchRecursive(bstNodes[nodeId].left, value);
        } else {
            return _bstSearchRecursive(bstNodes[nodeId].right, value);
        }
    }
    
    function bstInorderTraversal() external view returns (uint256[] memory) {
        uint256[] memory result = new uint256[](100); // å‡è®¾æœ€å¤š100ä¸ªèŠ‚ç‚¹
        uint256 index = 0;
        _bstInorderRecursive(bstRoot, result, index);
        
        // åˆ›å»ºæ­£ç¡®å¤§å°çš„æ•°ç»„
        uint256[] memory finalResult = new uint256[](index);
        for (uint256 i = 0; i < index; i++) {
            finalResult[i] = result[i];
        }
        return finalResult;
    }
    
    function _bstInorderRecursive(
        uint256 nodeId,
        uint256[] memory result,
        uint256 index
    ) private view returns (uint256) {
        if (nodeId == 0 || !bstNodes[nodeId].exists) {
            return index;
        }
        
        index = _bstInorderRecursive(bstNodes[nodeId].left, result, index);
        result[index++] = bstNodes[nodeId].value;
        index = _bstInorderRecursive(bstNodes[nodeId].right, result, index);
        
        return index;
    }
    
    // âœ… AVLæ ‘æ“ä½œ
    function avlInsert(uint256 value) external {
        uint256 gasBefore = gasleft();
        avlRoot = _avlInsertRecursive(avlRoot, value);
        uint256 gasUsed = gasBefore - gasleft();
        emit TreeOperation("AVL", "insert", value, gasUsed);
    }
    
    function _avlInsertRecursive(uint256 nodeId, uint256 value) private returns (uint256) {
        // æ ‡å‡†BSTæ’å…¥
        if (nodeId == 0 || !avlNodes[nodeId].exists) {
            uint256 newNodeId = nextNodeId++;
            avlNodes[newNodeId] = AVLNode({
                value: value,
                left: 0,
                right: 0,
                height: 1,
                exists: true
            });
            return newNodeId;
        }
        
        if (value < avlNodes[nodeId].value) {
            avlNodes[nodeId].left = _avlInsertRecursive(avlNodes[nodeId].left, value);
        } else if (value > avlNodes[nodeId].value) {
            avlNodes[nodeId].right = _avlInsertRecursive(avlNodes[nodeId].right, value);
        } else {
            return nodeId; // é‡å¤å€¼
        }
        
        // æ›´æ–°é«˜åº¦
        avlNodes[nodeId].height = 1 + _max(
            _getHeight(avlNodes[nodeId].left),
            _getHeight(avlNodes[nodeId].right)
        );
        
        // è·å–å¹³è¡¡å› å­
        int256 balance = _getBalance(nodeId);
        
        // å·¦å·¦æƒ…å†µ
        if (balance > 1 && value < avlNodes[avlNodes[nodeId].left].value) {
            return _rightRotate(nodeId);
        }
        
        // å³å³æƒ…å†µ
        if (balance < -1 && value > avlNodes[avlNodes[nodeId].right].value) {
            return _leftRotate(nodeId);
        }
        
        // å·¦å³æƒ…å†µ
        if (balance > 1 && value > avlNodes[avlNodes[nodeId].left].value) {
            avlNodes[nodeId].left = _leftRotate(avlNodes[nodeId].left);
            return _rightRotate(nodeId);
        }
        
        // å³å·¦æƒ…å†µ
        if (balance < -1 && value < avlNodes[avlNodes[nodeId].right].value) {
            avlNodes[nodeId].right = _rightRotate(avlNodes[nodeId].right);
            return _leftRotate(nodeId);
        }
        
        return nodeId;
    }
    
    function _getHeight(uint256 nodeId) private view returns (uint256) {
        if (nodeId == 0 || !avlNodes[nodeId].exists) {
            return 0;
        }
        return avlNodes[nodeId].height;
    }
    
    function _getBalance(uint256 nodeId) private view returns (int256) {
        if (nodeId == 0 || !avlNodes[nodeId].exists) {
            return 0;
        }
        return int256(_getHeight(avlNodes[nodeId].left)) - int256(_getHeight(avlNodes[nodeId].right));
    }
    
    function _rightRotate(uint256 y) private returns (uint256) {
        uint256 x = avlNodes[y].left;
        uint256 T2 = avlNodes[x].right;
        
        // æ‰§è¡Œæ—‹è½¬
        avlNodes[x].right = y;
        avlNodes[y].left = T2;
        
        // æ›´æ–°é«˜åº¦
        avlNodes[y].height = 1 + _max(_getHeight(avlNodes[y].left), _getHeight(avlNodes[y].right));
        avlNodes[x].height = 1 + _max(_getHeight(avlNodes[x].left), _getHeight(avlNodes[x].right));
        
        return x;
    }
    
    function _leftRotate(uint256 x) private returns (uint256) {
        uint256 y = avlNodes[x].right;
        uint256 T2 = avlNodes[y].left;
        
        // æ‰§è¡Œæ—‹è½¬
        avlNodes[y].left = x;
        avlNodes[x].right = T2;
        
        // æ›´æ–°é«˜åº¦
        avlNodes[x].height = 1 + _max(_getHeight(avlNodes[x].left), _getHeight(avlNodes[x].right));
        avlNodes[y].height = 1 + _max(_getHeight(avlNodes[y].left), _getHeight(avlNodes[y].right));
        
        return y;
    }
    
    // âœ… å­—å…¸æ ‘æ“ä½œ
    function trieInsert(string calldata word) external {
        uint256 gasBefore = gasleft();
        bytes memory wordBytes = bytes(word);
        uint256 currentNode = trieRoot;
        
        for (uint256 i = 0; i < wordBytes.length; i++) {
            bytes1 char = wordBytes[i];
            
            if (trieNodes[currentNode].children[char] == 0) {
                uint256 newNodeId = nextNodeId++;
                trieNodes[newNodeId].exists = true;
                trieNodes[currentNode].children[char] = newNodeId;
            }
            
            currentNode = trieNodes[currentNode].children[char];
        }
        
        trieNodes[currentNode].isEndOfWord = true;
        
        uint256 gasUsed = gasBefore - gasleft();
        emit TreeOperation("Trie", "insert", wordBytes.length, gasUsed);
    }
    
    function trieSearch(string calldata word) external view returns (bool) {
        bytes memory wordBytes = bytes(word);
        uint256 currentNode = trieRoot;
        
        for (uint256 i = 0; i < wordBytes.length; i++) {
            bytes1 char = wordBytes[i];
            
            if (trieNodes[currentNode].children[char] == 0) {
                return false;
            }
            
            currentNode = trieNodes[currentNode].children[char];
        }
        
        return trieNodes[currentNode].isEndOfWord;
    }
    
    function trieStartsWith(string calldata prefix) external view returns (bool) {
        bytes memory prefixBytes = bytes(prefix);
        uint256 currentNode = trieRoot;
        
        for (uint256 i = 0; i < prefixBytes.length; i++) {
            bytes1 char = prefixBytes[i];
            
            if (trieNodes[currentNode].children[char] == 0) {
                return false;
            }
            
            currentNode = trieNodes[currentNode].children[char];
        }
        
        return true;
    }
    
    // âœ… å·¥å…·å‡½æ•°
    function _max(uint256 a, uint256 b) private pure returns (uint256) {
        return a > b ? a : b;
    }
    
    // âœ… æŸ¥è¯¢å‡½æ•°
    function getBSTNodeValue(uint256 nodeId) external view returns (uint256) {
        require(bstNodes[nodeId].exists, "Node does not exist");
        return bstNodes[nodeId].value;
    }
    
    function getAVLNodeHeight(uint256 nodeId) external view returns (uint256) {
        require(avlNodes[nodeId].exists, "Node does not exist");
        return avlNodes[nodeId].height;
    }
    
    function getNextNodeId() external view returns (uint256) {
        return nextNodeId;
    }
}
```

**å¤æ‚åº¦åˆ†æ**: AVLæ ‘ä¿è¯O(log n)çš„æŸ¥æ‰¾ã€æ’å…¥ã€åˆ é™¤æ—¶é—´å¤æ‚åº¦

---

## ğŸ“š ç¬¬ä¸‰å‘¨ï¼šå›¾ç®—æ³•ä¸ç½‘ç»œåˆ†æ

### è¯¾å ‚ä¸»é¢˜ï¼šåŒºå—é“¾ç½‘ç»œä¸­çš„å›¾ç®—æ³•åº”ç”¨
**æ—¶é—´**: 2024å¹´3æœˆ18æ—¥  
**é‡ç‚¹å†…å®¹**:

#### 1. å›¾ç®—æ³•å®ç°
```solidity
// GraphAlgorithms.sol - å›¾ç®—æ³•åº“
contract GraphAlgorithms {
    // âœ… å›¾çš„é‚»æ¥è¡¨è¡¨ç¤º
    struct Graph {
        mapping(uint256 => uint256[]) adjacencyList;
        mapping(uint256 => mapping(uint256 => uint256)) weights; // è¾¹æƒé‡
        uint256[] vertices;
        bool isDirected;
        uint256 vertexCount;
    }
    
    // âœ… è¾¹ç»“æ„
    struct Edge {
        uint256 from;
        uint256 to;
        uint256 weight;
    }
    
    Graph private graph;
    
    event GraphOperation(string operation, uint256 gasUsed, string result);
    
    constructor(bool _isDirected) {
        graph.isDirected = _isDirected;
    }
    
    // âœ… æ·»åŠ é¡¶ç‚¹
    function addVertex(uint256 vertex) external {
        bool exists = false;
        for (uint256 i = 0; i < graph.vertices.length; i++) {
            if (graph.vertices[i] == vertex) {
                exists = true;
                break;
            }
        }
        
        if (!exists) {
            graph.vertices.push(vertex);
            graph.vertexCount++;
        }
    }
    
    // âœ… æ·»åŠ è¾¹
    function addEdge(uint256 from, uint256 to, uint256 weight) external {
        // ç¡®ä¿é¡¶ç‚¹å­˜åœ¨
        addVertex(from);
        addVertex(to);
        
        graph.adjacencyList[from].push(to);
        graph.weights[from][to] = weight;
        
        if (!graph.isDirected) {
            graph.adjacencyList[to].push(from);
            graph.weights[to][from] = weight;
        }
    }
    
    // âœ… æ·±åº¦ä¼˜å…ˆæœç´¢
    function dfs(uint256 startVertex) external returns (uint256[] memory) {
        uint256 gasBefore = gasleft();
        
        uint256[] memory visited = new uint256[](graph.vertexCount);
        uint256[] memory result = new uint256[](graph.vertexCount);
        mapping(uint256 => bool) visitedMap;
        
        uint256 resultIndex = 0;
        _dfsRecursive(startVertex, visitedMap, result, resultIndex);
        
        // åˆ›å»ºæ­£ç¡®å¤§å°çš„ç»“æœæ•°ç»„
        uint256[] memory finalResult = new uint256[](resultIndex);
        for (uint256 i = 0; i < resultIndex; i++) {
            finalResult[i] = result[i];
        }
        
        uint256 gasUsed = gasBefore - gasleft();
        emit GraphOperation("DFS", gasUsed, "completed");
        
        return finalResult;
    }
    
    function _dfsRecursive(
        uint256 vertex,
        mapping(uint256 => bool) storage visited,
        uint256[] memory result,
        uint256 resultIndex
    ) private returns (uint256) {
        visited[vertex] = true;
        result[resultIndex++] = vertex;
        
        uint256[] memory neighbors = graph.adjacencyList[vertex];
        for (uint256 i = 0; i < neighbors.length; i++) {
            if (!visited[neighbors[i]]) {
                resultIndex = _dfsRecursive(neighbors[i], visited, result, resultIndex);
            }
        }
        
        return resultIndex;
    }
    
    // âœ… å¹¿åº¦ä¼˜å…ˆæœç´¢
    function bfs(uint256 startVertex) external view returns (uint256[] memory) {
        uint256[] memory queue = new uint256[](graph.vertexCount);
        uint256[] memory result = new uint256[](graph.vertexCount);
        mapping(uint256 => bool) visited;
        
        uint256 queueFront = 0;
        uint256 queueRear = 0;
        uint256 resultIndex = 0;
        
        // å°†èµ·å§‹é¡¶ç‚¹åŠ å…¥é˜Ÿåˆ—
        queue[queueRear++] = startVertex;
        visited[startVertex] = true;
        
        while (queueFront < queueRear) {
            uint256 currentVertex = queue[queueFront++];
            result[resultIndex++] = currentVertex;
            
            uint256[] memory neighbors = graph.adjacencyList[currentVertex];
            for (uint256 i = 0; i < neighbors.length; i++) {
                if (!visited[neighbors[i]]) {
                    visited[neighbors[i]] = true;
                    queue[queueRear++] = neighbors[i];
                }
            }
        }
        
        // åˆ›å»ºæ­£ç¡®å¤§å°çš„ç»“æœæ•°ç»„
        uint256[] memory finalResult = new uint256[](resultIndex);
        for (uint256 i = 0; i < resultIndex; i++) {
            finalResult[i] = result[i];
        }
        
        return finalResult;
    }
    
    // âœ… æ£€æµ‹ç¯ï¼ˆæœ‰å‘å›¾ï¼‰
    function hasCycle() external view returns (bool) {
        if (!graph.isDirected) {
            return _hasCycleUndirected();
        }
        
        mapping(uint256 => uint8) color; // 0: white, 1: gray, 2: black
        
        for (uint256 i = 0; i < graph.vertices.length; i++) {
            if (color[graph.vertices[i]] == 0) {
                if (_hasCycleDirectedDFS(graph.vertices[i], color)) {
                    return true;
                }
            }
        }
        
        return false;
    }
    
    function _hasCycleDirectedDFS(
        uint256 vertex,
        mapping(uint256 => uint8) storage color
    ) private view returns (bool) {
        color[vertex] = 1; // æ ‡è®°ä¸ºç°è‰²
        
        uint256[] memory neighbors = graph.adjacencyList[vertex];
        for (uint256 i = 0; i < neighbors.length; i++) {
            uint256 neighbor = neighbors[i];
            
            if (color[neighbor] == 1) {
                return true; // å‘ç°åå‘è¾¹ï¼Œå­˜åœ¨ç¯
            }
            
            if (color[neighbor] == 0 && _hasCycleDirectedDFS(neighbor, color)) {
                return true;
            }
        }
        
        color[vertex] = 2; // æ ‡è®°ä¸ºé»‘è‰²
        return false;
    }
    
    function _hasCycleUndirected() private view returns (bool) {
        mapping(uint256 => bool) visited;
        
        for (uint256 i = 0; i < graph.vertices.length; i++) {
            if (!visited[graph.vertices[i]]) {
                if (_hasCycleUndirectedDFS(graph.vertices[i], type(uint256).max, visited)) {
                    return true;
                }
            }
        }
        
        return false;
    }
    
    function _hasCycleUndirectedDFS(
        uint256 vertex,
        uint256 parent,
        mapping(uint256 => bool) storage visited
    ) private view returns (bool) {
        visited[vertex] = true;
        
        uint256[] memory neighbors = graph.adjacencyList[vertex];
        for (uint256 i = 0; i < neighbors.length; i++) {
            uint256 neighbor = neighbors[i];
            
            if (!visited[neighbor]) {
                if (_hasCycleUndirectedDFS(neighbor, vertex, visited)) {
                    return true;
                }
            } else if (neighbor != parent) {
                return true; // å‘ç°ç¯
            }
        }
        
        return false;
    }
    
    // âœ… æ‹“æ‰‘æ’åºï¼ˆKahnç®—æ³•ï¼‰
    function topologicalSort() external view returns (uint256[] memory) {
        require(graph.isDirected, "Topological sort only for directed graphs");
        
        // è®¡ç®—å…¥åº¦
        mapping(uint256 => uint256) inDegree;
        for (uint256 i = 0; i < graph.vertices.length; i++) {
            uint256 vertex = graph.vertices[i];
            uint256[] memory neighbors = graph.adjacencyList[vertex];
            for (uint256 j = 0; j < neighbors.length; j++) {
                inDegree[neighbors[j]]++;
            }
        }
        
        // æ‰¾åˆ°æ‰€æœ‰å…¥åº¦ä¸º0çš„é¡¶ç‚¹
        uint256[] memory queue = new uint256[](graph.vertexCount);
        uint256 queueRear = 0;
        
        for (uint256 i = 0; i < graph.vertices.length; i++) {
            if (inDegree[graph.vertices[i]] == 0) {
                queue[queueRear++] = graph.vertices[i];
            }
        }
        
        uint256[] memory result = new uint256[](graph.vertexCount);
        uint256 resultIndex = 0;
        uint256 queueFront = 0;
        
        while (queueFront < queueRear) {
            uint256 vertex = queue[queueFront++];
            result[resultIndex++] = vertex;
            
            uint256[] memory neighbors = graph.adjacencyList[vertex];
            for (uint256 i = 0; i < neighbors.length; i++) {
                inDegree[neighbors[i]]--;
                if (inDegree[neighbors[i]] == 0) {
                    queue[queueRear++] = neighbors[i];
                }
            }
        }
        
        require(resultIndex == graph.vertexCount, "Graph has cycle");
        
        return result;
    }
    
    // âœ… æœ€å°ç”Ÿæˆæ ‘ï¼ˆPrimç®—æ³•ï¼‰
    function minimumSpanningTree() external view returns (Edge[] memory) {
        require(!graph.isDirected, "MST only for undirected graphs");
        require(graph.vertexCount > 0, "Empty graph");
        
        Edge[] memory mst = new Edge[](graph.vertexCount - 1);
        mapping(uint256 => bool) inMST;
        mapping(uint256 => uint256) key;
        mapping(uint256 => uint256) parent;
        
        // åˆå§‹åŒ–
        for (uint256 i = 0; i < graph.vertices.length; i++) {
            key[graph.vertices[i]] = type(uint256).max;
        }
        
        uint256 startVertex = graph.vertices[0];
        key[startVertex] = 0;
        parent[startVertex] = type(uint256).max;
        
        uint256 mstIndex = 0;
        
        for (uint256 count = 0; count < graph.vertexCount; count++) {
            uint256 u = _extractMin(key, inMST);
            inMST[u] = true;
            
            if (parent[u] != type(uint256).max) {
                mst[mstIndex++] = Edge({
                    from: parent[u],
                    to: u,
                    weight: graph.weights[parent[u]][u]
                });
            }
            
            uint256[] memory neighbors = graph.adjacencyList[u];
            for (uint256 i = 0; i < neighbors.length; i++) {
                uint256 v = neighbors[i];
                uint256 weight = graph.weights[u][v];
                
                if (!inMST[v] && weight < key[v]) {
                    parent[v] = u;
                    key[v] = weight;
                }
            }
        }
        
        return mst;
    }
    
    function _extractMin(
        mapping(uint256 => uint256) storage key,
        mapping(uint256 => bool) storage inMST
    ) private view returns (uint256) {
        uint256 min = type(uint256).max;
        uint256 minVertex = 0;
        
        for (uint256 i = 0; i < graph.vertices.length; i++) {
            uint256 vertex = graph.vertices[i];
            if (!inMST[vertex] && key[vertex] < min) {
                min = key[vertex];
                minVertex = vertex;
            }
        }
        
        return minVertex;
    }
    
    // âœ… å¼ºè¿é€šåˆ†é‡ï¼ˆKosarajuç®—æ³•ï¼‰
    function stronglyConnectedComponents() external view returns (uint256[][] memory) {
        require(graph.isDirected, "SCC only for directed graphs");
        
        // ç¬¬ä¸€æ¬¡DFSè·å–å®Œæˆæ—¶é—´é¡ºåº
        uint256[] memory finishOrder = new uint256[](graph.vertexCount);
        mapping(uint256 => bool) visited;
        uint256 finishIndex = 0;
        
        for (uint256 i = 0; i < graph.vertices.length; i++) {
            if (!visited[graph.vertices[i]]) {
                _dfsForFinishTime(graph.vertices[i], visited, finishOrder, finishIndex);
            }
        }
        
        // åˆ›å»ºè½¬ç½®å›¾
        Graph memory transposeGraph = _createTransposeGraph();
        
        // ç¬¬äºŒæ¬¡DFSæŒ‰å®Œæˆæ—¶é—´é€†åº
        uint256[][] memory sccs = new uint256[][](graph.vertexCount);
        mapping(uint256 => bool) visited2;
        uint256 sccCount = 0;
        
        for (uint256 i = graph.vertexCount; i > 0; i--) {
            uint256 vertex = finishOrder[i - 1];
            if (!visited2[vertex]) {
                uint256[] memory component = new uint256[](graph.vertexCount);
                uint256 componentSize = 0;
                _dfsForSCC(vertex, visited2, transposeGraph, component, componentSize);
                
                // åˆ›å»ºæ­£ç¡®å¤§å°çš„ç»„ä»¶æ•°ç»„
                uint256[] memory finalComponent = new uint256[](componentSize);
                for (uint256 j = 0; j < componentSize; j++) {
                    finalComponent[j] = component[j];
                }
                sccs[sccCount++] = finalComponent;
            }
        }
        
        // åˆ›å»ºæ­£ç¡®å¤§å°çš„ç»“æœæ•°ç»„
        uint256[][] memory result = new uint256[][](sccCount);
        for (uint256 i = 0; i < sccCount; i++) {
            result[i] = sccs[i];
        }
        
        return result;
    }
    
    function _dfsForFinishTime(
        uint256 vertex,
        mapping(uint256 => bool) storage visited,
        uint256[] memory finishOrder,
        uint256 finishIndex
    ) private view returns (uint256) {
        visited[vertex] = true;
        
        uint256[] memory neighbors = graph.adjacencyList[vertex];
        for (uint256 i = 0; i < neighbors.length; i++) {
            if (!visited[neighbors[i]]) {
                finishIndex = _dfsForFinishTime(neighbors[i], visited, finishOrder, finishIndex);
            }
        }
        
        finishOrder[finishIndex++] = vertex;
        return finishIndex;
    }
    
    function _createTransposeGraph() private view returns (Graph memory) {
        Graph memory transposeGraph;
        transposeGraph.isDirected = true;
        transposeGraph.vertexCount = graph.vertexCount;
        
        for (uint256 i = 0; i < graph.vertices.length; i++) {
            uint256 vertex = graph.vertices[i];
            uint256[] memory neighbors = graph.adjacencyList[vertex];
            
            for (uint256 j = 0; j < neighbors.length; j++) {
                uint256 neighbor = neighbors[j];
                transposeGraph.adjacencyList[neighbor].push(vertex);
            }
        }
        
        return transposeGraph;
    }
    
    function _dfsForSCC(
        uint256 vertex,
        mapping(uint256 => bool) storage visited,
        Graph memory transposeGraph,
        uint256[] memory component,
        uint256 componentSize
    ) private pure returns (uint256) {
        visited[vertex] = true;
        component[componentSize++] = vertex;
        
        uint256[] memory neighbors = transposeGraph.adjacencyList[vertex];
        for (uint256 i = 0; i < neighbors.length; i++) {
            if (!visited[neighbors[i]]) {
                componentSize = _dfsForSCC(neighbors[i], visited, transposeGraph, component, componentSize);
            }
        }
        
        return componentSize;
    }
    
    // âœ… æŸ¥è¯¢å‡½æ•°
    function getVertices() external view returns (uint256[] memory) {
        return graph.vertices;
    }
    
    function getNeighbors(uint256 vertex) external view returns (uint256[] memory) {
        return graph.adjacencyList[vertex];
    }
    
    function getEdgeWeight(uint256 from, uint256 to) external view returns (uint256) {
        return graph.weights[from][to];
    }
    
    function getVertexCount() external view returns (uint256) {
        return graph.vertexCount;
    }
    
    function isDirectedGraph() external view returns (bool) {
        return graph.isDirected;
    }
}
```

**ç½‘ç»œåˆ†æ**: å›¾ç®—æ³•åœ¨åŒºå—é“¾ç½‘ç»œåˆ†æã€äº¤æ˜“è·¯å¾„ä¼˜åŒ–ä¸­çš„åº”ç”¨

---

## ğŸ“š ç¬¬å››å‘¨ï¼šåŠ¨æ€è§„åˆ’ä¸ä¼˜åŒ–

### è¯¾å ‚ä¸»é¢˜ï¼šæ™ºèƒ½åˆçº¦ä¸­çš„åŠ¨æ€è§„åˆ’ç®—æ³•
**æ—¶é—´**: 2024å¹´3æœˆ25æ—¥  
**é‡ç‚¹å†…å®¹**:

#### 1. ç»å…¸åŠ¨æ€è§„åˆ’é—®é¢˜
```solidity
// DynamicProgramming.sol - åŠ¨æ€è§„åˆ’ç®—æ³•åº“
contract DynamicProgramming {
    // âœ… äº‹ä»¶å®šä¹‰
    event DPAlgorithmExecuted(
        string algorithmName,
        uint256 inputSize,
        uint256 result,
        uint256 gasUsed
    );
    
    // âœ… æ–æ³¢é‚£å¥‘æ•°åˆ—ï¼ˆè®°å¿†åŒ–æœç´¢ï¼‰
    mapping(uint256 => uint256) private fibMemo;
    
    function fibonacci(uint256 n) external returns (uint256) {
        uint256 gasBefore = gasleft();
        uint256 result = _fibonacciMemo(n);
        uint256 gasUsed = gasBefore - gasleft();
        
        emit DPAlgorithmExecuted("Fibonacci", n, result, gasUsed);
        return result;
    }
    
    function _fibonacciMemo(uint256 n) private returns (uint256) {
        if (n <= 1) return n;
        
        if (fibMemo[n] != 0) {
            return fibMemo[n];
        }
        
        fibMemo[n] = _fibonacciMemo(n - 1) + _fibonacciMemo(n - 2);
        return fibMemo[n];
    }
    
    // âœ… 0-1èƒŒåŒ…é—®é¢˜
    function knapsack(
        uint256[] calldata weights,
        uint256[] calldata values,
        uint256 capacity
    ) external pure returns (uint256) {
        uint256 n = weights.length;
        require(n == values.length, "Arrays length mismatch");
        
        // åˆ›å»ºDPè¡¨
        uint256[][] memory dp = new uint256[][](n + 1);
        for (uint256 i = 0; i <= n; i++) {
            dp[i] = new uint256[](capacity + 1);
        }
        
        // å¡«å……DPè¡¨
        for (uint256 i = 1; i <= n; i++) {
            for (uint256 w = 0; w <= capacity; w++) {
                if (weights[i - 1] <= w) {
                    dp[i][w] = _max(
                        values[i - 1] + dp[i - 1][w - weights[i - 1]],
                        dp[i - 1][w]
                    );
                } else {
                    dp[i][w] = dp[i - 1][w];
                }
            }
        }
        
        return dp[n][capacity];
    }
    
    // âœ… æœ€é•¿é€’å¢å­åºåˆ—
    function longestIncreasingSubsequence(uint256[] calldata arr) external pure returns (uint256) {
        if (arr.length == 0) return 0;
        
        uint256[] memory dp = new uint256[](arr.length);
        
        // åˆå§‹åŒ–
        for (uint256 i = 0; i < arr.length; i++) {
            dp[i] = 1;
        }
        
        // å¡«å……DPæ•°ç»„
        for (uint256 i = 1; i < arr.length; i++) {
            for (uint256 j = 0; j < i; j++) {
                if (arr[j] < arr[i]) {
                    dp[i] = _max(dp[i], dp[j] + 1);
                }
            }
        }
        
        // æ‰¾åˆ°æœ€å¤§å€¼
        uint256 maxLength = dp[0];
        for (uint256 i = 1; i < dp.length; i++) {
            maxLength = _max(maxLength, dp[i]);
        }
        
        return maxLength;
    }
    
    // âœ… ç¼–è¾‘è·ç¦»ï¼ˆLevenshteinè·ç¦»ï¼‰
    function editDistance(
        string calldata str1,
        string calldata str2
    ) external pure returns (uint256) {
        bytes memory s1 = bytes(str1);
        bytes memory s2 = bytes(str2);
        
        uint256 m = s1.length;
        uint256 n = s2.length;
        
        // åˆ›å»ºDPè¡¨
        uint256[][] memory dp = new uint256[][](m + 1);