# 课堂重点记录

> **学习者**: 杨程喆  
> **学号**: 2023111423  
> **学习特色**: 注重算法优化和数据结构  
> **代码风格**: 高效算法实现  
> **笔记重点**: 高效算法库设计与复杂度分析  
> **项目代码**: EfficientAlgorithms.sol - 高效算法库  
> **记录时间**: 2024年春季学期

---

## 📚 第一周：智能合约算法基础

### 课堂主题：区块链中的算法设计原则
**时间**: 2024年3月4日  
**重点内容**:

#### 1. Gas优化算法设计
- **循环优化**: 减少不必要的迭代
- **存储优化**: 合理使用storage和memory
- **计算复杂度**: 时间与空间的权衡
- **批处理算法**: 减少交易次数

#### 2. 高效数据结构实现
```solidity
// EfficientDataStructures.sol - 高效数据结构库
library EfficientDataStructures {
    // ✅ 动态数组结构
    struct DynamicArray {
        mapping(uint256 => uint256) data;
        uint256 length;
        uint256 capacity;
    }
    
    // ✅ 哈希表结构
    struct HashTable {
        mapping(bytes32 => uint256) indices;
        mapping(uint256 => bytes32) keys;
        mapping(uint256 => uint256) values;
        uint256 size;
        uint256 capacity;
    }
    
    // ✅ 优先队列（最小堆）
    struct PriorityQueue {
        mapping(uint256 => uint256) heap;
        uint256 size;
    }
    
    // ✅ 并查集结构
    struct UnionFind {
        mapping(uint256 => uint256) parent;
        mapping(uint256 => uint256) rank;
        uint256 components;
    }
    
    // ✅ 动态数组操作
    function push(DynamicArray storage arr, uint256 value) internal {
        if (arr.length >= arr.capacity) {
            _resize(arr);
        }
        arr.data[arr.length] = value;
        arr.length++;
    }
    
    function pop(DynamicArray storage arr) internal returns (uint256) {
        require(arr.length > 0, "Array is empty");
        arr.length--;
        uint256 value = arr.data[arr.length];
        delete arr.data[arr.length];
        return value;
    }
    
    function get(DynamicArray storage arr, uint256 index) internal view returns (uint256) {
        require(index < arr.length, "Index out of bounds");
        return arr.data[index];
    }
    
    function set(DynamicArray storage arr, uint256 index, uint256 value) internal {
        require(index < arr.length, "Index out of bounds");
        arr.data[index] = value;
    }
    
    function _resize(DynamicArray storage arr) private {
        arr.capacity = arr.capacity == 0 ? 1 : arr.capacity * 2;
    }
    
    // ✅ 哈希表操作
    function put(HashTable storage table, bytes32 key, uint256 value) internal {
        bytes32 hash = keccak256(abi.encodePacked(key, block.timestamp));
        uint256 index = uint256(hash) % (table.capacity == 0 ? 16 : table.capacity);
        
        // 线性探测解决冲突
        while (table.keys[index] != bytes32(0) && table.keys[index] != key) {
            index = (index + 1) % table.capacity;
        }
        
        if (table.keys[index] == bytes32(0)) {
            table.size++;
        }
        
        table.keys[index] = key;
        table.values[index] = value;
        table.indices[key] = index;
        
        // 负载因子过高时扩容
        if (table.size * 4 > table.capacity * 3) {
            _rehash(table);
        }
    }
    
    function get(HashTable storage table, bytes32 key) internal view returns (uint256) {
        uint256 index = table.indices[key];
        require(table.keys[index] == key, "Key not found");
        return table.values[index];
    }
    
    function remove(HashTable storage table, bytes32 key) internal {
        uint256 index = table.indices[key];
        require(table.keys[index] == key, "Key not found");
        
        delete table.keys[index];
        delete table.values[index];
        delete table.indices[key];
        table.size--;
    }
    
    function _rehash(HashTable storage table) private {
        // 简化实现，实际需要重新分配所有元素
        table.capacity = table.capacity * 2;
    }
    
    // ✅ 优先队列操作（最小堆）
    function insert(PriorityQueue storage pq, uint256 value) internal {
        pq.size++;
        pq.heap[pq.size] = value;
        _heapifyUp(pq, pq.size);
    }
    
    function extractMin(PriorityQueue storage pq) internal returns (uint256) {
        require(pq.size > 0, "Priority queue is empty");
        
        uint256 min = pq.heap[1];
        pq.heap[1] = pq.heap[pq.size];
        delete pq.heap[pq.size];
        pq.size--;
        
        if (pq.size > 0) {
            _heapifyDown(pq, 1);
        }
        
        return min;
    }
    
    function peek(PriorityQueue storage pq) internal view returns (uint256) {
        require(pq.size > 0, "Priority queue is empty");
        return pq.heap[1];
    }
    
    function _heapifyUp(PriorityQueue storage pq, uint256 index) private {
        while (index > 1) {
            uint256 parent = index / 2;
            if (pq.heap[index] >= pq.heap[parent]) break;
            
            // 交换
            uint256 temp = pq.heap[index];
            pq.heap[index] = pq.heap[parent];
            pq.heap[parent] = temp;
            
            index = parent;
        }
    }
    
    function _heapifyDown(PriorityQueue storage pq, uint256 index) private {
        while (index * 2 <= pq.size) {
            uint256 leftChild = index * 2;
            uint256 rightChild = index * 2 + 1;
            uint256 smallest = index;
            
            if (pq.heap[leftChild] < pq.heap[smallest]) {
                smallest = leftChild;
            }
            
            if (rightChild <= pq.size && pq.heap[rightChild] < pq.heap[smallest]) {
                smallest = rightChild;
            }
            
            if (smallest == index) break;
            
            // 交换
            uint256 temp = pq.heap[index];
            pq.heap[index] = pq.heap[smallest];
            pq.heap[smallest] = temp;
            
            index = smallest;
        }
    }
    
    // ✅ 并查集操作
    function makeSet(UnionFind storage uf, uint256 x) internal {
        if (uf.parent[x] == 0) {
            uf.parent[x] = x;
            uf.rank[x] = 0;
            uf.components++;
        }
    }
    
    function find(UnionFind storage uf, uint256 x) internal returns (uint256) {
        if (uf.parent[x] != x) {
            uf.parent[x] = find(uf, uf.parent[x]); // 路径压缩
        }
        return uf.parent[x];
    }
    
    function union(UnionFind storage uf, uint256 x, uint256 y) internal {
        uint256 rootX = find(uf, x);
        uint256 rootY = find(uf, y);
        
        if (rootX != rootY) {
            // 按秩合并
            if (uf.rank[rootX] < uf.rank[rootY]) {
                uf.parent[rootX] = rootY;
            } else if (uf.rank[rootX] > uf.rank[rootY]) {
                uf.parent[rootY] = rootX;
            } else {
                uf.parent[rootY] = rootX;
                uf.rank[rootX]++;
            }
            uf.components--;
        }
    }
    
    function connected(UnionFind storage uf, uint256 x, uint256 y) internal returns (bool) {
        return find(uf, x) == find(uf, y);
    }
}

// ✅ 高效算法合约
contract EfficientAlgorithms {
    using EfficientDataStructures for EfficientDataStructures.DynamicArray;
    using EfficientDataStructures for EfficientDataStructures.HashTable;
    using EfficientDataStructures for EfficientDataStructures.PriorityQueue;
    using EfficientDataStructures for EfficientDataStructures.UnionFind;
    
    // ✅ 数据结构实例
    EfficientDataStructures.DynamicArray private dynamicArray;
    EfficientDataStructures.HashTable private hashTable;
    EfficientDataStructures.PriorityQueue private priorityQueue;
    EfficientDataStructures.UnionFind private unionFind;
    
    // ✅ 事件定义
    event AlgorithmExecuted(string algorithmName, uint256 gasUsed, uint256 result);
    event DataStructureOperation(string operation, uint256 gasUsed);
    
    // ✅ 二分查找算法
    function binarySearch(
        uint256[] calldata sortedArray,
        uint256 target
    ) external pure returns (int256) {
        int256 left = 0;
        int256 right = int256(sortedArray.length) - 1;
        
        while (left <= right) {
            int256 mid = left + (right - left) / 2;
            
            if (sortedArray[uint256(mid)] == target) {
                return mid;
            } else if (sortedArray[uint256(mid)] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        
        return -1; // 未找到
    }
    
    // ✅ 快速排序算法（Gas优化版本）
    function quickSort(uint256[] memory arr) public pure returns (uint256[] memory) {
        if (arr.length <= 1) return arr;
        
        _quickSortRecursive(arr, 0, int256(arr.length) - 1);
        return arr;
    }
    
    function _quickSortRecursive(
        uint256[] memory arr,
        int256 low,
        int256 high
    ) private pure {
        if (low < high) {
            int256 pivotIndex = _partition(arr, low, high);
            _quickSortRecursive(arr, low, pivotIndex - 1);
            _quickSortRecursive(arr, pivotIndex + 1, high);
        }
    }
    
    function _partition(
        uint256[] memory arr,
        int256 low,
        int256 high
    ) private pure returns (int256) {
        uint256 pivot = arr[uint256(high)];
        int256 i = low - 1;
        
        for (int256 j = low; j < high; j++) {
            if (arr[uint256(j)] <= pivot) {
                i++;
                // 交换元素
                uint256 temp = arr[uint256(i)];
                arr[uint256(i)] = arr[uint256(j)];
                arr[uint256(j)] = temp;
            }
        }
        
        // 将pivot放到正确位置
        uint256 temp = arr[uint256(i + 1)];
        arr[uint256(i + 1)] = arr[uint256(high)];
        arr[uint256(high)] = temp;
        
        return i + 1;
    }
    
    // ✅ 归并排序算法
    function mergeSort(uint256[] memory arr) public pure returns (uint256[] memory) {
        if (arr.length <= 1) return arr;
        
        uint256[] memory temp = new uint256[](arr.length);
        _mergeSortRecursive(arr, temp, 0, arr.length - 1);
        return arr;
    }
    
    function _mergeSortRecursive(
        uint256[] memory arr,
        uint256[] memory temp,
        uint256 left,
        uint256 right
    ) private pure {
        if (left < right) {
            uint256 mid = left + (right - left) / 2;
            _mergeSortRecursive(arr, temp, left, mid);
            _mergeSortRecursive(arr, temp, mid + 1, right);
            _merge(arr, temp, left, mid, right);
        }
    }
    
    function _merge(
        uint256[] memory arr,
        uint256[] memory temp,
        uint256 left,
        uint256 mid,
        uint256 right
    ) private pure {
        // 复制到临时数组
        for (uint256 i = left; i <= right; i++) {
            temp[i] = arr[i];
        }
        
        uint256 i = left;
        uint256 j = mid + 1;
        uint256 k = left;
        
        // 合并两个有序数组
        while (i <= mid && j <= right) {
            if (temp[i] <= temp[j]) {
                arr[k] = temp[i];
                i++;
            } else {
                arr[k] = temp[j];
                j++;
            }
            k++;
        }
        
        // 复制剩余元素
        while (i <= mid) {
            arr[k] = temp[i];
            i++;
            k++;
        }
        
        while (j <= right) {
            arr[k] = temp[j];
            j++;
            k++;
        }
    }
    
    // ✅ 最大子数组和（Kadane算法）
    function maxSubarraySum(int256[] calldata arr) external pure returns (int256) {
        if (arr.length == 0) return 0;
        
        int256 maxSoFar = arr[0];
        int256 maxEndingHere = arr[0];
        
        for (uint256 i = 1; i < arr.length; i++) {
            maxEndingHere = _max(arr[i], maxEndingHere + arr[i]);
            maxSoFar = _max(maxSoFar, maxEndingHere);
        }
        
        return maxSoFar;
    }
    
    // ✅ 最长公共子序列
    function longestCommonSubsequence(
        string calldata text1,
        string calldata text2
    ) external pure returns (uint256) {
        bytes memory s1 = bytes(text1);
        bytes memory s2 = bytes(text2);
        
        uint256 m = s1.length;
        uint256 n = s2.length;
        
        // 创建DP表
        uint256[][] memory dp = new uint256[][](m + 1);
        for (uint256 i = 0; i <= m; i++) {
            dp[i] = new uint256[](n + 1);
        }
        
        // 初始化边界条件
        for (uint256 i = 0; i <= m; i++) {
            dp[i][0] = i;
        }
        for (uint256 j = 0; j <= n; j++) {
            dp[0][j] = j;
        }
        
        // 填充DP表
        for (uint256 i = 1; i <= m; i++) {
            for (uint256 j = 1; j <= n; j++) {
                if (s1[i - 1] == s2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1];
                } else {
                    dp[i][j] = 1 + _min3(
                        dp[i - 1][j],     // 删除
                        dp[i][j - 1],     // 插入
                        dp[i - 1][j - 1]  // 替换
                    );
                }
            }
        }
        
        return dp[m][n];
    }
    
    // ✅ 最大子矩阵和
    function maxSubmatrixSum(int256[][] calldata matrix) external pure returns (int256) {
        if (matrix.length == 0 || matrix[0].length == 0) return 0;
        
        uint256 rows = matrix.length;
        uint256 cols = matrix[0].length;
        int256 maxSum = type(int256).min;
        
        // 枚举所有可能的上下边界
        for (uint256 top = 0; top < rows; top++) {
            int256[] memory temp = new int256[](cols);
            
            for (uint256 bottom = top; bottom < rows; bottom++) {
                // 将当前行加到临时数组
                for (uint256 j = 0; j < cols; j++) {
                    temp[j] += matrix[bottom][j];
                }
                
                // 对临时数组应用Kadane算法
                int256 currentMax = _kadaneAlgorithm(temp);
                maxSum = _maxInt(maxSum, currentMax);
            }
        }
        
        return maxSum;
    }
    
    function _kadaneAlgorithm(int256[] memory arr) private pure returns (int256) {
        int256 maxSoFar = arr[0];
        int256 maxEndingHere = arr[0];
        
        for (uint256 i = 1; i < arr.length; i++) {
            maxEndingHere = _maxInt(arr[i], maxEndingHere + arr[i]);
            maxSoFar = _maxInt(maxSoFar, maxEndingHere);
        }
        
        return maxSoFar;
    }
    
    // ✅ 硬币找零问题
    function coinChange(
        uint256[] calldata coins,
        uint256 amount
    ) external pure returns (uint256) {
        uint256[] memory dp = new uint256[](amount + 1);
        
        // 初始化为最大值（表示不可能）
        for (uint256 i = 1; i <= amount; i++) {
            dp[i] = type(uint256).max;
        }
        
        dp[0] = 0; // 0元需要0个硬币
        
        // 填充DP数组
        for (uint256 i = 1; i <= amount; i++) {
            for (uint256 j = 0; j < coins.length; j++) {
                if (coins[j] <= i && dp[i - coins[j]] != type(uint256).max) {
                    dp[i] = _min(dp[i], dp[i - coins[j]] + 1);
                }
            }
        }
        
        return dp[amount] == type(uint256).max ? 0 : dp[amount];
    }
    
    // ✅ 最长回文子序列
    function longestPalindromicSubsequence(string calldata s) external pure returns (uint256) {
        bytes memory str = bytes(s);
        uint256 n = str.length;
        
        if (n == 0) return 0;
        
        // 创建DP表
        uint256[][] memory dp = new uint256[][](n);
        for (uint256 i = 0; i < n; i++) {
            dp[i] = new uint256[](n);
            dp[i][i] = 1; // 单个字符的回文长度为1
        }
        
        // 填充DP表
        for (uint256 len = 2; len <= n; len++) {
            for (uint256 i = 0; i <= n - len; i++) {
                uint256 j = i + len - 1;
                
                if (str[i] == str[j]) {
                    dp[i][j] = dp[i + 1][j - 1] + 2;
                } else {
                    dp[i][j] = _max(dp[i + 1][j], dp[i][j - 1]);
                }
            }
        }
        
        return dp[0][n - 1];
    }
    
    // ✅ 工具函数
    function _max(uint256 a, uint256 b) private pure returns (uint256) {
        return a > b ? a : b;
    }
    
    function _min(uint256 a, uint256 b) private pure returns (uint256) {
        return a < b ? a : b;
    }
    
    function _min3(uint256 a, uint256 b, uint256 c) private pure returns (uint256) {
        return _min(_min(a, b), c);
    }
    
    function _maxInt(int256 a, int256 b) private pure returns (int256) {
        return a > b ? a : b;
    }
    
    // ✅ 清除记忆化缓存
    function clearFibonacciMemo() external {
        // 注意：在实际应用中，可能需要更高效的清除方法
        for (uint256 i = 0; i < 100; i++) {
            delete fibMemo[i];
        }
    }
}
```

**优化策略**: 记忆化搜索减少重复计算，空间优化降低存储成本

---

## 📚 第五周：字符串算法与模式匹配

### 课堂主题：高效字符串处理算法
**时间**: 2024年4月1日  
**重点内容**:

#### 1. 字符串匹配算法
```solidity
// StringAlgorithms.sol - 字符串算法库
contract StringAlgorithms {
    // ✅ 事件定义
    event StringAlgorithmExecuted(
        string algorithmName,
        uint256 textLength,
        uint256 patternLength,
        int256 result,
        uint256 gasUsed
    );
    
    // ✅ KMP算法
    function kmpSearch(
        string calldata text,
        string calldata pattern
    ) external returns (int256) {
        uint256 gasBefore = gasleft();
        
        bytes memory textBytes = bytes(text);
        bytes memory patternBytes = bytes(pattern);
        
        if (patternBytes.length == 0) return 0;
        if (textBytes.length < patternBytes.length) return -1;
        
        // 构建失效函数（部分匹配表）
        uint256[] memory lps = _computeLPSArray(patternBytes);
        
        uint256 i = 0; // text的索引
        uint256 j = 0; // pattern的索引
        
        while (i < textBytes.length) {
            if (patternBytes[j] == textBytes[i]) {
                i++;
                j++;
            }
            
            if (j == patternBytes.length) {
                uint256 gasUsed = gasBefore - gasleft();
                emit StringAlgorithmExecuted(
                    "KMP",
                    textBytes.length,
                    patternBytes.length,
                    int256(i - j),
                    gasUsed
                );
                return int256(i - j);
            } else if (i < textBytes.length && patternBytes[j] != textBytes[i]) {
                if (j != 0) {
                    j = lps[j - 1];
                } else {
                    i++;
                }
            }
        }
        
        uint256 gasUsed = gasBefore - gasleft();
        emit StringAlgorithmExecuted(
            "KMP",
            textBytes.length,
            patternBytes.length,
            -1,
            gasUsed
        );
        return -1;
    }
    
    function _computeLPSArray(bytes memory pattern) private pure returns (uint256[] memory) {
        uint256[] memory lps = new uint256[](pattern.length);
        uint256 len = 0;
        uint256 i = 1;
        
        lps[0] = 0;
        
        while (i < pattern.length) {
            if (pattern[i] == pattern[len]) {
                len++;
                lps[i] = len;
                i++;
            } else {
                if (len != 0) {
                    len = lps[len - 1];
                } else {
                    lps[i] = 0;
                    i++;
                }
            }
        }
        
        return lps;
    }
    
    // ✅ Rabin-Karp算法（滚动哈希）
    function rabinKarpSearch(
        string calldata text,
        string calldata pattern
    ) external pure returns (int256) {
        bytes memory textBytes = bytes(text);
        bytes memory patternBytes = bytes(pattern);
        
        uint256 n = textBytes.length;
        uint256 m = patternBytes.length;
        
        if (m > n) return -1;
        
        uint256 prime = 101; // 质数
        uint256 base = 256;  // 字符集大小
        
        uint256 patternHash = 0;
        uint256 textHash = 0;
        uint256 h = 1;
        
        // 计算h = base^(m-1) % prime
        for (uint256 i = 0; i < m - 1; i++) {
            h = (h * base) % prime;
        }
        
        // 计算模式和文本第一个窗口的哈希值
        for (uint256 i = 0; i < m; i++) {
            patternHash = (base * patternHash + uint256(uint8(patternBytes[i]))) % prime;
            textHash = (base * textHash + uint256(uint8(textBytes[i]))) % prime;
        }
        
        // 滑动窗口
        for (uint256 i = 0; i <= n - m; i++) {
            if (patternHash == textHash) {
                // 哈希值匹配，进行字符比较
                bool match = true;
                for (uint256 j = 0; j < m; j++) {
                    if (textBytes[i + j] != patternBytes[j]) {
                        match = false;
                        break;
                    }
                }
                if (match) {
                    return int256(i);
                }
            }
            
            // 计算下一个窗口的哈希值
            if (i < n - m) {
                textHash = (base * (textHash - uint256(uint8(textBytes[i])) * h) + 
                           uint256(uint8(textBytes[i + m]))) % prime;
                
                // 处理负数情况
                if (textHash < 0) {
                    textHash = textHash + prime;
                }
            }
        }
        
        return -1;
    }
    
    // ✅ Boyer-Moore算法（简化版）
    function boyerMooreSearch(
        string calldata text,
        string calldata pattern
    ) external pure returns (int256) {
        bytes memory textBytes = bytes(text);
        bytes memory patternBytes = bytes(pattern);
        
        uint256 n = textBytes.length;
        uint256 m = patternBytes.length;
        
        if (m > n) return -1;
        
        // 构建坏字符表
        mapping(bytes1 => int256) badChar;
        for (uint256 i = 0; i < m; i++) {
            badChar[patternBytes[i]] = int256(i);
        }
        
        uint256 s = 0; // 文本中的偏移
        
        while (s <= n - m) {
            int256 j = int256(m) - 1;
            
            // 从右到左匹配
            while (j >= 0 && patternBytes[uint256(j)] == textBytes[s + uint256(j)]) {
                j--;
            }
            
            if (j < 0) {
                return int256(s);
            } else {
                // 使用坏字符规则计算偏移
                int256 badCharShift = j - badChar[textBytes[s + uint256(j)]];
                s += uint256(_maxInt(1, badCharShift));
            }
        }
        
        return -1;
    }
    
    // ✅ Z算法（线性时间字符串匹配）
    function zAlgorithm(string calldata s) external pure returns (uint256[] memory) {
        bytes memory str = bytes(s);
        uint256 n = str.length;
        
        if (n == 0) {
            return new uint256[](0);
        }
        
        uint256[] memory z = new uint256[](n);
        uint256 l = 0;
        uint256 r = 0;
        
        for (uint256 i = 1; i < n; i++) {
            if (i <= r) {
                z[i] = _min(r - i + 1, z[i - l]);
            }
            
            while (i + z[i] < n && str[z[i]] == str[i + z[i]]) {
                z[i]++;
            }
            
            if (i + z[i] - 1 > r) {
                l = i;
                r = i + z[i] - 1;
            }
        }
        
        return z;
    }
    
    // ✅ 最长公共前缀
    function longestCommonPrefix(string[] calldata strs) external pure returns (string memory) {
        if (strs.length == 0) return "";
        
        bytes memory first = bytes(strs[0]);
        uint256 minLen = first.length;
        
        // 找到最短字符串长度
        for (uint256 i = 1; i < strs.length; i++) {
            bytes memory current = bytes(strs[i]);
            if (current.length < minLen) {
                minLen = current.length;
            }
        }
        
        // 逐字符比较
        for (uint256 i = 0; i < minLen; i++) {
            bytes1 char = first[i];
            for (uint256 j = 1; j < strs.length; j++) {
                if (bytes(strs[j])[i] != char) {
                    return string(_substring(first, 0, i));
                }
            }
        }
        
        return string(_substring(first, 0, minLen));
    }
    
    // ✅ 字符串反转
    function reverseString(string calldata s) external pure returns (string memory) {
        bytes memory str = bytes(s);
        bytes memory reversed = new bytes(str.length);
        
        for (uint256 i = 0; i < str.length; i++) {
            reversed[i] = str[str.length - 1 - i];
        }
        
        return string(reversed);
    }
    
    // ✅ 回文检测
    function isPalindrome(string calldata s) external pure returns (bool) {
        bytes memory str = bytes(s);
        uint256 left = 0;
        uint256 right = str.length - 1;
        
        while (left < right) {
            if (str[left] != str[right]) {
                return false;
            }
            left++;
            right--;
        }
        
        return true;
    }
    
    // ✅ 字符串压缩（简单版本）
    function compressString(string calldata s) external pure returns (string memory) {
        bytes memory str = bytes(s);
        if (str.length == 0) return s;
        
        bytes memory compressed = new bytes(str.length * 2); // 最坏情况
        uint256 compressedIndex = 0;
        
        uint256 count = 1;
        bytes1 currentChar = str[0];
        
        for (uint256 i = 1; i < str.length; i++) {
            if (str[i] == currentChar) {
                count++;
            } else {
                // 添加字符和计数
                compressed[compressedIndex++] = currentChar;
                
                // 将计数转换为字符串
                bytes memory countStr = _uintToBytes(count);
                for (uint256 j = 0; j < countStr.length; j++) {
                    compressed[compressedIndex++] = countStr[j];
                }
                
                currentChar = str[i];
                count = 1;
            }
        }
        
        // 处理最后一个字符
        compressed[compressedIndex++] = currentChar;
        bytes memory countStr = _uintToBytes(count);
        for (uint256 j = 0; j < countStr.length; j++) {
            compressed[compressedIndex++] = countStr[j];
        }
        
        // 创建正确大小的结果
        bytes memory result = new bytes(compressedIndex);
        for (uint256 i = 0; i < compressedIndex; i++) {
            result[i] = compressed[i];
        }
        
        return string(result);
    }
    
    // ✅ 工具函数
    function _substring(
        bytes memory str,
        uint256 start,
        uint256 end
    ) private pure returns (bytes memory) {
        bytes memory result = new bytes(end - start);
        for (uint256 i = start; i < end; i++) {
            result[i - start] = str[i];
        }
        return result;
    }
    
    function _uintToBytes(uint256 value) private pure returns (bytes memory) {
        if (value == 0) {
            return "0";
        }
        
        uint256 temp = value;
        uint256 digits = 0;
        
        while (temp != 0) {
            digits++;
            temp /= 10;
        }
        
        bytes memory buffer = new bytes(digits);
        
        while (value != 0) {
            digits -= 1;
            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));
            value /= 10;
        }
        
        return buffer;
    }
    
    function _min(uint256 a, uint256 b) private pure returns (uint256) {
        return a < b ? a : b;
    }
    
    function _maxInt(int256 a, int256 b) private pure returns (int256) {
        return a > b ? a : b;
    }
}
```

**模式匹配**: KMP算法O(n+m)时间复杂度，Rabin-Karp平均O(n+m)

---

## 📚 第六周：高级算法优化与Gas分析

### 课堂主题：智能合约算法的Gas优化策略
**时间**: 2024年4月8日  
**重点内容**:

#### 1. Gas优化技术
```solidity
// GasOptimizedAlgorithms.sol - Gas优化算法库
contract GasOptimizedAlgorithms {
    // ✅ 优化的数据结构
    struct OptimizedArray {
        mapping(uint256 => uint256) data;
        uint256 length;
    }
    
    // ✅ 位运算优化
    function fastPowerOfTwo(uint256 n) external pure returns (bool) {
        return n > 0 && (n & (n - 1)) == 0;
    }
    
    function fastMultiplyByPowerOfTwo(uint256 x, uint256 n) external pure returns (uint256) {
        return x << n; // 相当于 x * (2^n)
    }
    
    function fastDivideByPowerOfTwo(uint256 x, uint256 n) external pure returns (uint256) {
        return x >> n; // 相当于 x / (2^n)
    }
    
    // ✅ 循环优化
    function optimizedSum(uint256[] calldata arr) external pure returns (uint256) {
        uint256 sum = 0;
        uint256 len = arr.length;
        
        // 循环展开优化
        uint256 i = 0;
        for (; i + 3 < len; i += 4) {
            sum += arr[i] + arr[i + 1] + arr[i + 2] + arr[i + 3];
        }
        
        // 处理剩余元素
        for (; i < len; i++) {
            sum += arr[i];
        }
        
        return sum;
    }
    
    // ✅ 内存优化的排序
    function optimizedQuickSort(uint256[] memory arr) external pure returns (uint256[] memory) {
        if (arr.length <= 1) return arr;
        
        _optimizedQuickSortInPlace(arr, 0, int256(arr.length) - 1);
        return arr;
    }
    
    function _optimizedQuickSortInPlace(
        uint256[] memory arr,
        int256 low,
        int256 high
    ) private pure {
        while (low < high) {
            // 小数组使用插入排序
            if (high - low < 10) {
                _insertionSort(arr, uint256(low), uint256(high));
                break;
            }
            
            int256 pivotIndex = _optimizedPartition(arr, low, high);
            
            // 尾递归优化：总是递归较小的部分
            if (pivotIndex - low < high - pivotIndex) {
                _optimizedQuickSortInPlace(arr, low, pivotIndex - 1);
                low = pivotIndex + 1;
            } else {
                _optimizedQuickSortInPlace(arr, pivotIndex + 1, high);
                high = pivotIndex - 1;
            }
        }
    }
    
    function _optimizedPartition(
        uint256[] memory arr,
        int256 low,
        int256 high
    ) private pure returns (int256) {
        // 三数取中法选择pivot
        int256 mid = low + (high - low) / 2;
        
        if (arr[uint256(mid)] < arr[uint256(low)]) {
            _swap(arr, uint256(low), uint256(mid));
        }
        if (arr[uint256(high)] < arr[uint256(low)]) {
            _swap(arr, uint256(low), uint256(high));
        }
        if (arr[uint256(high)] < arr[uint256(mid)]) {
            _swap(arr, uint256(mid), uint256(high));
        }
        
        _swap(arr, uint256(mid), uint256(high));
        
        uint256 pivot = arr[uint256(high)];
        int256 i = low - 1;
        
        for (int256 j = low; j < high; j++) {
            if (arr[uint256(j)] <= pivot) {
                i++;
                _swap(arr, uint256(i), uint256(j));
            }
        }
        
        _swap(arr, uint256(i + 1), uint256(high));
        return i + 1;
    }
    
    function _insertionSort(
        uint256[] memory arr,
        uint256 start,
        uint256 end
    ) private pure {
        for (uint256 i = start + 1; i <= end; i++) {
            uint256 key = arr[i];
            uint256 j = i;
            
            while (j > start && arr[j - 1] > key) {
                arr[j] = arr[j - 1];
                j--;
            }
            
            arr[j] = key;
        }
    }
    
    function _swap(uint256[] memory arr, uint256 i, uint256 j) private pure {
        uint256 temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
    
    // ✅ 批量操作优化
    function batchProcess(
        uint256[] calldata inputs,
        uint256 operation // 0: square, 1: double, 2: increment
    ) external pure returns (uint256[] memory) {
        uint256[] memory results = new uint256[](inputs.length);
        
        if (operation == 0) {
            // 平方操作
            for (uint256 i = 0; i < inputs.length; i++) {
                results[i] = inputs[i] * inputs[i];
            }
        } else if (operation == 1) {
            // 双倍操作
            for (uint256 i = 0; i < inputs.length; i++) {
                results[i] = inputs[i] << 1; // 位运算优化
            }
        } else if (operation == 2) {
            // 递增操作
            for (uint256 i = 0; i < inputs.length; i++) {
                results[i] = inputs[i] + 1;
            }
        }
        
        return results;
    }
}
```

**Gas分析**: 位运算比乘除法节省Gas，循环展开减少跳转开销

---

## 🎯 学习心得与总结

### 核心算法掌握
1. **数据结构精通**: 动态数组、哈希表、优先队列、并查集
2. **排序算法优化**: 快速排序、归并排序的Gas优化版本
3. **图算法应用**: DFS、BFS、最短路径、最小生成树
4. **动态规划**: 背包问题、最长子序列、编辑距离
5. **字符串算法**: KMP、Rabin-Karp、Boyer-Moore模式匹配

### 算法复杂度分析
- **时间复杂度**: 从O(n²)优化到O(n log n)或O(n)
- **空间复杂度**: 合理使用memory和storage
- **Gas复杂度**: 位运算、循环展开、批量处理优化

### 实践项目成果
- **高效算法库**: 15+核心算法的Solidity实现
- **性能基准测试**: Gas消耗对比分析
- **优化策略总结**: 10+种Gas优化技术

### 未来发展方向
1. **量子算法**: 研究量子计算在区块链中的应用
2. **并行算法**: 多线程优化策略
3. **机器学习算法**: 链上AI算法实现
4. **密码学算法**: 零知识证明、同态加密

---

## 📚 参考资源

### 算法书籍
- 《算法导论》- Cormen, Leiserson, Rivest, Stein
- 《算法》第4版 - Robert Sedgewick
- 《编程珠玑》- Jon Bentley

### 在线资源
- [LeetCode算法题库](https://leetcode.com/)
- [GeeksforGeeks算法教程](https://www.geeksforgeeks.org/)
- [Solidity Gas优化指南](https://docs.soliditylang.org/)

### 开源项目
- [OpenZeppelin算法库](https://github.com/OpenZeppelin/openzeppelin-contracts)
- [Solidity算法实现](https://github.com/ethereum/solidity-examples)

---

*"算法是程序的灵魂，优化是智能合约的生命。"* - 杨程喆
        for (uint256 i = 0; i <= m; i++) {
            dp[i] = new uint256[](n + 1);
        }
        
        // 填充DP表
        for (uint256 i = 1; i <= m; i++) {
            for (uint256 j = 1; j <= n; j++) {
                if (s1[i - 1] == s2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = _max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        
        return dp[m][n];
    }
    
    // ✅ 图算法：Dijkstra最短路径
    function dijkstra(
        uint256[][] calldata graph,
        uint256 source
    ) external pure returns (uint256[] memory) {
        uint256 n = graph.length;
        uint256[] memory dist = new uint256[](n);
        bool[] memory visited = new bool[](n);
        
        // 初始化距离
        for (uint256 i = 0; i < n; i++) {
            dist[i] = type(uint256).max;
        }
        dist[source] = 0;
        
        // 主循环
        for (uint256 count = 0; count < n - 1; count++) {
            uint256 u = _minDistance(dist, visited);
            visited[u] = true;
            
            // 更新相邻节点的距离
            for (uint256 v = 0; v < n; v++) {
                if (!visited[v] && graph[u][v] != 0 && 
                    dist[u] != type(uint256).max && 
                    dist[u] + graph[u][v] < dist[v]) {
                    dist[v] = dist[u] + graph[u][v];
                }
            }
        }
        
        return dist;
    }
    
    function _minDistance(
        uint256[] memory dist,
        bool[] memory visited
    ) private pure returns (uint256) {
        uint256 min = type(uint256).max;
        uint256 minIndex = 0;
        
        for (uint256 v = 0; v < dist.length; v++) {
            if (!visited[v] && dist[v] <= min) {
                min = dist[v];
                minIndex = v;
            }
        }
        
        return minIndex;
    }
    
    // ✅ 工具函数
    function _max(int256 a, int256 b) private pure returns (int256) {
        return a > b ? a : b;
    }
    
    function _max(uint256 a, uint256 b) private pure returns (uint256) {
        return a > b ? a : b;
    }
    
    // ✅ 数据结构操作接口
    function pushToArray(uint256 value) external {
        uint256 gasBefore = gasleft();
        dynamicArray.push(value);
        uint256 gasUsed = gasBefore - gasleft();
        emit DataStructureOperation("push", gasUsed);
    }
    
    function popFromArray() external returns (uint256) {
        uint256 gasBefore = gasleft();
        uint256 value = dynamicArray.pop();
        uint256 gasUsed = gasBefore - gasleft();
        emit DataStructureOperation("pop", gasUsed);
        return value;
    }
    
    function insertToPriorityQueue(uint256 value) external {
        uint256 gasBefore = gasleft();
        priorityQueue.insert(value);
        uint256 gasUsed = gasBefore - gasleft();
        emit DataStructureOperation("priorityQueue_insert", gasUsed);
    }
    
    function extractMinFromPriorityQueue() external returns (uint256) {
        uint256 gasBefore = gasleft();
        uint256 value = priorityQueue.extractMin();
        uint256 gasUsed = gasBefore - gasleft();
        emit DataStructureOperation("priorityQueue_extractMin", gasUsed);
        return value;
    }
    
    function putToHashTable(bytes32 key, uint256 value) external {
        uint256 gasBefore = gasleft();
        hashTable.put(key, value);
        uint256 gasUsed = gasBefore - gasleft();
        emit DataStructureOperation("hashTable_put", gasUsed);
    }
    
    function getFromHashTable(bytes32 key) external view returns (uint256) {
        return hashTable.get(key);
    }
    
    function unionFindMakeSet(uint256 x) external {
        unionFind.makeSet(x);
    }
    
    function unionFindUnion(uint256 x, uint256 y) external {
        unionFind.union(x, y);
    }
    
    function unionFindConnected(uint256 x, uint256 y) external returns (bool) {
        return unionFind.connected(x, y);
    }
}
```

**算法分析**: 时间复杂度O(log n)的二分查找，O(n log n)的排序算法

---

## 📚 第二周：高级数据结构

### 课堂主题：区块链中的高级数据结构
**时间**: 2024年3月11日  
**重点内容**:

#### 1. 树形数据结构
```solidity
// AdvancedTrees.sol - 高级树结构
contract AdvancedTrees {
    // ✅ 二叉搜索树节点
    struct BSTNode {
        uint256 value;
        uint256 left;
        uint256 right;
        bool exists;
    }
    
    // ✅ AVL树节点
    struct AVLNode {
        uint256 value;
        uint256 left;
        uint256 right;
        uint256 height;
        bool exists;
    }
    
    // ✅ 字典树节点
    struct TrieNode {
        mapping(bytes1 => uint256) children;
        bool isEndOfWord;
        bool exists;
    }
    
    mapping(uint256 => BSTNode) private bstNodes;
    mapping(uint256 => AVLNode) private avlNodes;
    mapping(uint256 => TrieNode) private trieNodes;
    
    uint256 private nextNodeId = 1;
    uint256 public bstRoot;
    uint256 public avlRoot;
    uint256 public trieRoot;
    
    event TreeOperation(string treeType, string operation, uint256 value, uint256 gasUsed);
    
    constructor() {
        // 初始化字典树根节点
        trieRoot = nextNodeId++;
        trieNodes[trieRoot].exists = true;
    }
    
    // ✅ 二叉搜索树操作
    function bstInsert(uint256 value) external {
        uint256 gasBefore = gasleft();
        bstRoot = _bstInsertRecursive(bstRoot, value);
        uint256 gasUsed = gasBefore - gasleft();
        emit TreeOperation("BST", "insert", value, gasUsed);
    }
    
    function _bstInsertRecursive(uint256 nodeId, uint256 value) private returns (uint256) {
        if (nodeId == 0 || !bstNodes[nodeId].exists) {
            uint256 newNodeId = nextNodeId++;
            bstNodes[newNodeId] = BSTNode({
                value: value,
                left: 0,
                right: 0,
                exists: true
            });
            return newNodeId;
        }
        
        if (value < bstNodes[nodeId].value) {
            bstNodes[nodeId].left = _bstInsertRecursive(bstNodes[nodeId].left, value);
        } else if (value > bstNodes[nodeId].value) {
            bstNodes[nodeId].right = _bstInsertRecursive(bstNodes[nodeId].right, value);
        }
        
        return nodeId;
    }
    
    function bstSearch(uint256 value) external view returns (bool) {
        return _bstSearchRecursive(bstRoot, value);
    }
    
    function _bstSearchRecursive(uint256 nodeId, uint256 value) private view returns (bool) {
        if (nodeId == 0 || !bstNodes[nodeId].exists) {
            return false;
        }
        
        if (bstNodes[nodeId].value == value) {
            return true;
        } else if (value < bstNodes[nodeId].value) {
            return _bstSearchRecursive(bstNodes[nodeId].left, value);
        } else {
            return _bstSearchRecursive(bstNodes[nodeId].right, value);
        }
    }
    
    function bstInorderTraversal() external view returns (uint256[] memory) {
        uint256[] memory result = new uint256[](100); // 假设最多100个节点
        uint256 index = 0;
        _bstInorderRecursive(bstRoot, result, index);
        
        // 创建正确大小的数组
        uint256[] memory finalResult = new uint256[](index);
        for (uint256 i = 0; i < index; i++) {
            finalResult[i] = result[i];
        }
        return finalResult;
    }
    
    function _bstInorderRecursive(
        uint256 nodeId,
        uint256[] memory result,
        uint256 index
    ) private view returns (uint256) {
        if (nodeId == 0 || !bstNodes[nodeId].exists) {
            return index;
        }
        
        index = _bstInorderRecursive(bstNodes[nodeId].left, result, index);
        result[index++] = bstNodes[nodeId].value;
        index = _bstInorderRecursive(bstNodes[nodeId].right, result, index);
        
        return index;
    }
    
    // ✅ AVL树操作
    function avlInsert(uint256 value) external {
        uint256 gasBefore = gasleft();
        avlRoot = _avlInsertRecursive(avlRoot, value);
        uint256 gasUsed = gasBefore - gasleft();
        emit TreeOperation("AVL", "insert", value, gasUsed);
    }
    
    function _avlInsertRecursive(uint256 nodeId, uint256 value) private returns (uint256) {
        // 标准BST插入
        if (nodeId == 0 || !avlNodes[nodeId].exists) {
            uint256 newNodeId = nextNodeId++;
            avlNodes[newNodeId] = AVLNode({
                value: value,
                left: 0,
                right: 0,
                height: 1,
                exists: true
            });
            return newNodeId;
        }
        
        if (value < avlNodes[nodeId].value) {
            avlNodes[nodeId].left = _avlInsertRecursive(avlNodes[nodeId].left, value);
        } else if (value > avlNodes[nodeId].value) {
            avlNodes[nodeId].right = _avlInsertRecursive(avlNodes[nodeId].right, value);
        } else {
            return nodeId; // 重复值
        }
        
        // 更新高度
        avlNodes[nodeId].height = 1 + _max(
            _getHeight(avlNodes[nodeId].left),
            _getHeight(avlNodes[nodeId].right)
        );
        
        // 获取平衡因子
        int256 balance = _getBalance(nodeId);
        
        // 左左情况
        if (balance > 1 && value < avlNodes[avlNodes[nodeId].left].value) {
            return _rightRotate(nodeId);
        }
        
        // 右右情况
        if (balance < -1 && value > avlNodes[avlNodes[nodeId].right].value) {
            return _leftRotate(nodeId);
        }
        
        // 左右情况
        if (balance > 1 && value > avlNodes[avlNodes[nodeId].left].value) {
            avlNodes[nodeId].left = _leftRotate(avlNodes[nodeId].left);
            return _rightRotate(nodeId);
        }
        
        // 右左情况
        if (balance < -1 && value < avlNodes[avlNodes[nodeId].right].value) {
            avlNodes[nodeId].right = _rightRotate(avlNodes[nodeId].right);
            return _leftRotate(nodeId);
        }
        
        return nodeId;
    }
    
    function _getHeight(uint256 nodeId) private view returns (uint256) {
        if (nodeId == 0 || !avlNodes[nodeId].exists) {
            return 0;
        }
        return avlNodes[nodeId].height;
    }
    
    function _getBalance(uint256 nodeId) private view returns (int256) {
        if (nodeId == 0 || !avlNodes[nodeId].exists) {
            return 0;
        }
        return int256(_getHeight(avlNodes[nodeId].left)) - int256(_getHeight(avlNodes[nodeId].right));
    }
    
    function _rightRotate(uint256 y) private returns (uint256) {
        uint256 x = avlNodes[y].left;
        uint256 T2 = avlNodes[x].right;
        
        // 执行旋转
        avlNodes[x].right = y;
        avlNodes[y].left = T2;
        
        // 更新高度
        avlNodes[y].height = 1 + _max(_getHeight(avlNodes[y].left), _getHeight(avlNodes[y].right));
        avlNodes[x].height = 1 + _max(_getHeight(avlNodes[x].left), _getHeight(avlNodes[x].right));
        
        return x;
    }
    
    function _leftRotate(uint256 x) private returns (uint256) {
        uint256 y = avlNodes[x].right;
        uint256 T2 = avlNodes[y].left;
        
        // 执行旋转
        avlNodes[y].left = x;
        avlNodes[x].right = T2;
        
        // 更新高度
        avlNodes[x].height = 1 + _max(_getHeight(avlNodes[x].left), _getHeight(avlNodes[x].right));
        avlNodes[y].height = 1 + _max(_getHeight(avlNodes[y].left), _getHeight(avlNodes[y].right));
        
        return y;
    }
    
    // ✅ 字典树操作
    function trieInsert(string calldata word) external {
        uint256 gasBefore = gasleft();
        bytes memory wordBytes = bytes(word);
        uint256 currentNode = trieRoot;
        
        for (uint256 i = 0; i < wordBytes.length; i++) {
            bytes1 char = wordBytes[i];
            
            if (trieNodes[currentNode].children[char] == 0) {
                uint256 newNodeId = nextNodeId++;
                trieNodes[newNodeId].exists = true;
                trieNodes[currentNode].children[char] = newNodeId;
            }
            
            currentNode = trieNodes[currentNode].children[char];
        }
        
        trieNodes[currentNode].isEndOfWord = true;
        
        uint256 gasUsed = gasBefore - gasleft();
        emit TreeOperation("Trie", "insert", wordBytes.length, gasUsed);
    }
    
    function trieSearch(string calldata word) external view returns (bool) {
        bytes memory wordBytes = bytes(word);
        uint256 currentNode = trieRoot;
        
        for (uint256 i = 0; i < wordBytes.length; i++) {
            bytes1 char = wordBytes[i];
            
            if (trieNodes[currentNode].children[char] == 0) {
                return false;
            }
            
            currentNode = trieNodes[currentNode].children[char];
        }
        
        return trieNodes[currentNode].isEndOfWord;
    }
    
    function trieStartsWith(string calldata prefix) external view returns (bool) {
        bytes memory prefixBytes = bytes(prefix);
        uint256 currentNode = trieRoot;
        
        for (uint256 i = 0; i < prefixBytes.length; i++) {
            bytes1 char = prefixBytes[i];
            
            if (trieNodes[currentNode].children[char] == 0) {
                return false;
            }
            
            currentNode = trieNodes[currentNode].children[char];
        }
        
        return true;
    }
    
    // ✅ 工具函数
    function _max(uint256 a, uint256 b) private pure returns (uint256) {
        return a > b ? a : b;
    }
    
    // ✅ 查询函数
    function getBSTNodeValue(uint256 nodeId) external view returns (uint256) {
        require(bstNodes[nodeId].exists, "Node does not exist");
        return bstNodes[nodeId].value;
    }
    
    function getAVLNodeHeight(uint256 nodeId) external view returns (uint256) {
        require(avlNodes[nodeId].exists, "Node does not exist");
        return avlNodes[nodeId].height;
    }
    
    function getNextNodeId() external view returns (uint256) {
        return nextNodeId;
    }
}
```

**复杂度分析**: AVL树保证O(log n)的查找、插入、删除时间复杂度

---

## 📚 第三周：图算法与网络分析

### 课堂主题：区块链网络中的图算法应用
**时间**: 2024年3月18日  
**重点内容**:

#### 1. 图算法实现
```solidity
// GraphAlgorithms.sol - 图算法库
contract GraphAlgorithms {
    // ✅ 图的邻接表表示
    struct Graph {
        mapping(uint256 => uint256[]) adjacencyList;
        mapping(uint256 => mapping(uint256 => uint256)) weights; // 边权重
        uint256[] vertices;
        bool isDirected;
        uint256 vertexCount;
    }
    
    // ✅ 边结构
    struct Edge {
        uint256 from;
        uint256 to;
        uint256 weight;
    }
    
    Graph private graph;
    
    event GraphOperation(string operation, uint256 gasUsed, string result);
    
    constructor(bool _isDirected) {
        graph.isDirected = _isDirected;
    }
    
    // ✅ 添加顶点
    function addVertex(uint256 vertex) external {
        bool exists = false;
        for (uint256 i = 0; i < graph.vertices.length; i++) {
            if (graph.vertices[i] == vertex) {
                exists = true;
                break;
            }
        }
        
        if (!exists) {
            graph.vertices.push(vertex);
            graph.vertexCount++;
        }
    }
    
    // ✅ 添加边
    function addEdge(uint256 from, uint256 to, uint256 weight) external {
        // 确保顶点存在
        addVertex(from);
        addVertex(to);
        
        graph.adjacencyList[from].push(to);
        graph.weights[from][to] = weight;
        
        if (!graph.isDirected) {
            graph.adjacencyList[to].push(from);
            graph.weights[to][from] = weight;
        }
    }
    
    // ✅ 深度优先搜索
    function dfs(uint256 startVertex) external returns (uint256[] memory) {
        uint256 gasBefore = gasleft();
        
        uint256[] memory visited = new uint256[](graph.vertexCount);
        uint256[] memory result = new uint256[](graph.vertexCount);
        mapping(uint256 => bool) visitedMap;
        
        uint256 resultIndex = 0;
        _dfsRecursive(startVertex, visitedMap, result, resultIndex);
        
        // 创建正确大小的结果数组
        uint256[] memory finalResult = new uint256[](resultIndex);
        for (uint256 i = 0; i < resultIndex; i++) {
            finalResult[i] = result[i];
        }
        
        uint256 gasUsed = gasBefore - gasleft();
        emit GraphOperation("DFS", gasUsed, "completed");
        
        return finalResult;
    }
    
    function _dfsRecursive(
        uint256 vertex,
        mapping(uint256 => bool) storage visited,
        uint256[] memory result,
        uint256 resultIndex
    ) private returns (uint256) {
        visited[vertex] = true;
        result[resultIndex++] = vertex;
        
        uint256[] memory neighbors = graph.adjacencyList[vertex];
        for (uint256 i = 0; i < neighbors.length; i++) {
            if (!visited[neighbors[i]]) {
                resultIndex = _dfsRecursive(neighbors[i], visited, result, resultIndex);
            }
        }
        
        return resultIndex;
    }
    
    // ✅ 广度优先搜索
    function bfs(uint256 startVertex) external view returns (uint256[] memory) {
        uint256[] memory queue = new uint256[](graph.vertexCount);
        uint256[] memory result = new uint256[](graph.vertexCount);
        mapping(uint256 => bool) visited;
        
        uint256 queueFront = 0;
        uint256 queueRear = 0;
        uint256 resultIndex = 0;
        
        // 将起始顶点加入队列
        queue[queueRear++] = startVertex;
        visited[startVertex] = true;
        
        while (queueFront < queueRear) {
            uint256 currentVertex = queue[queueFront++];
            result[resultIndex++] = currentVertex;
            
            uint256[] memory neighbors = graph.adjacencyList[currentVertex];
            for (uint256 i = 0; i < neighbors.length; i++) {
                if (!visited[neighbors[i]]) {
                    visited[neighbors[i]] = true;
                    queue[queueRear++] = neighbors[i];
                }
            }
        }
        
        // 创建正确大小的结果数组
        uint256[] memory finalResult = new uint256[](resultIndex);
        for (uint256 i = 0; i < resultIndex; i++) {
            finalResult[i] = result[i];
        }
        
        return finalResult;
    }
    
    // ✅ 检测环（有向图）
    function hasCycle() external view returns (bool) {
        if (!graph.isDirected) {
            return _hasCycleUndirected();
        }
        
        mapping(uint256 => uint8) color; // 0: white, 1: gray, 2: black
        
        for (uint256 i = 0; i < graph.vertices.length; i++) {
            if (color[graph.vertices[i]] == 0) {
                if (_hasCycleDirectedDFS(graph.vertices[i], color)) {
                    return true;
                }
            }
        }
        
        return false;
    }
    
    function _hasCycleDirectedDFS(
        uint256 vertex,
        mapping(uint256 => uint8) storage color
    ) private view returns (bool) {
        color[vertex] = 1; // 标记为灰色
        
        uint256[] memory neighbors = graph.adjacencyList[vertex];
        for (uint256 i = 0; i < neighbors.length; i++) {
            uint256 neighbor = neighbors[i];
            
            if (color[neighbor] == 1) {
                return true; // 发现后向边，存在环
            }
            
            if (color[neighbor] == 0 && _hasCycleDirectedDFS(neighbor, color)) {
                return true;
            }
        }
        
        color[vertex] = 2; // 标记为黑色
        return false;
    }
    
    function _hasCycleUndirected() private view returns (bool) {
        mapping(uint256 => bool) visited;
        
        for (uint256 i = 0; i < graph.vertices.length; i++) {
            if (!visited[graph.vertices[i]]) {
                if (_hasCycleUndirectedDFS(graph.vertices[i], type(uint256).max, visited)) {
                    return true;
                }
            }
        }
        
        return false;
    }
    
    function _hasCycleUndirectedDFS(
        uint256 vertex,
        uint256 parent,
        mapping(uint256 => bool) storage visited
    ) private view returns (bool) {
        visited[vertex] = true;
        
        uint256[] memory neighbors = graph.adjacencyList[vertex];
        for (uint256 i = 0; i < neighbors.length; i++) {
            uint256 neighbor = neighbors[i];
            
            if (!visited[neighbor]) {
                if (_hasCycleUndirectedDFS(neighbor, vertex, visited)) {
                    return true;
                }
            } else if (neighbor != parent) {
                return true; // 发现环
            }
        }
        
        return false;
    }
    
    // ✅ 拓扑排序（Kahn算法）
    function topologicalSort() external view returns (uint256[] memory) {
        require(graph.isDirected, "Topological sort only for directed graphs");
        
        // 计算入度
        mapping(uint256 => uint256) inDegree;
        for (uint256 i = 0; i < graph.vertices.length; i++) {
            uint256 vertex = graph.vertices[i];
            uint256[] memory neighbors = graph.adjacencyList[vertex];
            for (uint256 j = 0; j < neighbors.length; j++) {
                inDegree[neighbors[j]]++;
            }
        }
        
        // 找到所有入度为0的顶点
        uint256[] memory queue = new uint256[](graph.vertexCount);
        uint256 queueRear = 0;
        
        for (uint256 i = 0; i < graph.vertices.length; i++) {
            if (inDegree[graph.vertices[i]] == 0) {
                queue[queueRear++] = graph.vertices[i];
            }
        }
        
        uint256[] memory result = new uint256[](graph.vertexCount);
        uint256 resultIndex = 0;
        uint256 queueFront = 0;
        
        while (queueFront < queueRear) {
            uint256 vertex = queue[queueFront++];
            result[resultIndex++] = vertex;
            
            uint256[] memory neighbors = graph.adjacencyList[vertex];
            for (uint256 i = 0; i < neighbors.length; i++) {
                inDegree[neighbors[i]]--;
                if (inDegree[neighbors[i]] == 0) {
                    queue[queueRear++] = neighbors[i];
                }
            }
        }
        
        require(resultIndex == graph.vertexCount, "Graph has cycle");
        
        return result;
    }
    
    // ✅ 最小生成树（Prim算法）
    function minimumSpanningTree() external view returns (Edge[] memory) {
        require(!graph.isDirected, "MST only for undirected graphs");
        require(graph.vertexCount > 0, "Empty graph");
        
        Edge[] memory mst = new Edge[](graph.vertexCount - 1);
        mapping(uint256 => bool) inMST;
        mapping(uint256 => uint256) key;
        mapping(uint256 => uint256) parent;
        
        // 初始化
        for (uint256 i = 0; i < graph.vertices.length; i++) {
            key[graph.vertices[i]] = type(uint256).max;
        }
        
        uint256 startVertex = graph.vertices[0];
        key[startVertex] = 0;
        parent[startVertex] = type(uint256).max;
        
        uint256 mstIndex = 0;
        
        for (uint256 count = 0; count < graph.vertexCount; count++) {
            uint256 u = _extractMin(key, inMST);
            inMST[u] = true;
            
            if (parent[u] != type(uint256).max) {
                mst[mstIndex++] = Edge({
                    from: parent[u],
                    to: u,
                    weight: graph.weights[parent[u]][u]
                });
            }
            
            uint256[] memory neighbors = graph.adjacencyList[u];
            for (uint256 i = 0; i < neighbors.length; i++) {
                uint256 v = neighbors[i];
                uint256 weight = graph.weights[u][v];
                
                if (!inMST[v] && weight < key[v]) {
                    parent[v] = u;
                    key[v] = weight;
                }
            }
        }
        
        return mst;
    }
    
    function _extractMin(
        mapping(uint256 => uint256) storage key,
        mapping(uint256 => bool) storage inMST
    ) private view returns (uint256) {
        uint256 min = type(uint256).max;
        uint256 minVertex = 0;
        
        for (uint256 i = 0; i < graph.vertices.length; i++) {
            uint256 vertex = graph.vertices[i];
            if (!inMST[vertex] && key[vertex] < min) {
                min = key[vertex];
                minVertex = vertex;
            }
        }
        
        return minVertex;
    }
    
    // ✅ 强连通分量（Kosaraju算法）
    function stronglyConnectedComponents() external view returns (uint256[][] memory) {
        require(graph.isDirected, "SCC only for directed graphs");
        
        // 第一次DFS获取完成时间顺序
        uint256[] memory finishOrder = new uint256[](graph.vertexCount);
        mapping(uint256 => bool) visited;
        uint256 finishIndex = 0;
        
        for (uint256 i = 0; i < graph.vertices.length; i++) {
            if (!visited[graph.vertices[i]]) {
                _dfsForFinishTime(graph.vertices[i], visited, finishOrder, finishIndex);
            }
        }
        
        // 创建转置图
        Graph memory transposeGraph = _createTransposeGraph();
        
        // 第二次DFS按完成时间逆序
        uint256[][] memory sccs = new uint256[][](graph.vertexCount);
        mapping(uint256 => bool) visited2;
        uint256 sccCount = 0;
        
        for (uint256 i = graph.vertexCount; i > 0; i--) {
            uint256 vertex = finishOrder[i - 1];
            if (!visited2[vertex]) {
                uint256[] memory component = new uint256[](graph.vertexCount);
                uint256 componentSize = 0;
                _dfsForSCC(vertex, visited2, transposeGraph, component, componentSize);
                
                // 创建正确大小的组件数组
                uint256[] memory finalComponent = new uint256[](componentSize);
                for (uint256 j = 0; j < componentSize; j++) {
                    finalComponent[j] = component[j];
                }
                sccs[sccCount++] = finalComponent;
            }
        }
        
        // 创建正确大小的结果数组
        uint256[][] memory result = new uint256[][](sccCount);
        for (uint256 i = 0; i < sccCount; i++) {
            result[i] = sccs[i];
        }
        
        return result;
    }
    
    function _dfsForFinishTime(
        uint256 vertex,
        mapping(uint256 => bool) storage visited,
        uint256[] memory finishOrder,
        uint256 finishIndex
    ) private view returns (uint256) {
        visited[vertex] = true;
        
        uint256[] memory neighbors = graph.adjacencyList[vertex];
        for (uint256 i = 0; i < neighbors.length; i++) {
            if (!visited[neighbors[i]]) {
                finishIndex = _dfsForFinishTime(neighbors[i], visited, finishOrder, finishIndex);
            }
        }
        
        finishOrder[finishIndex++] = vertex;
        return finishIndex;
    }
    
    function _createTransposeGraph() private view returns (Graph memory) {
        Graph memory transposeGraph;
        transposeGraph.isDirected = true;
        transposeGraph.vertexCount = graph.vertexCount;
        
        for (uint256 i = 0; i < graph.vertices.length; i++) {
            uint256 vertex = graph.vertices[i];
            uint256[] memory neighbors = graph.adjacencyList[vertex];
            
            for (uint256 j = 0; j < neighbors.length; j++) {
                uint256 neighbor = neighbors[j];
                transposeGraph.adjacencyList[neighbor].push(vertex);
            }
        }
        
        return transposeGraph;
    }
    
    function _dfsForSCC(
        uint256 vertex,
        mapping(uint256 => bool) storage visited,
        Graph memory transposeGraph,
        uint256[] memory component,
        uint256 componentSize
    ) private pure returns (uint256) {
        visited[vertex] = true;
        component[componentSize++] = vertex;
        
        uint256[] memory neighbors = transposeGraph.adjacencyList[vertex];
        for (uint256 i = 0; i < neighbors.length; i++) {
            if (!visited[neighbors[i]]) {
                componentSize = _dfsForSCC(neighbors[i], visited, transposeGraph, component, componentSize);
            }
        }
        
        return componentSize;
    }
    
    // ✅ 查询函数
    function getVertices() external view returns (uint256[] memory) {
        return graph.vertices;
    }
    
    function getNeighbors(uint256 vertex) external view returns (uint256[] memory) {
        return graph.adjacencyList[vertex];
    }
    
    function getEdgeWeight(uint256 from, uint256 to) external view returns (uint256) {
        return graph.weights[from][to];
    }
    
    function getVertexCount() external view returns (uint256) {
        return graph.vertexCount;
    }
    
    function isDirectedGraph() external view returns (bool) {
        return graph.isDirected;
    }
}
```

**网络分析**: 图算法在区块链网络分析、交易路径优化中的应用

---

## 📚 第四周：动态规划与优化

### 课堂主题：智能合约中的动态规划算法
**时间**: 2024年3月25日  
**重点内容**:

#### 1. 经典动态规划问题
```solidity
// DynamicProgramming.sol - 动态规划算法库
contract DynamicProgramming {
    // ✅ 事件定义
    event DPAlgorithmExecuted(
        string algorithmName,
        uint256 inputSize,
        uint256 result,
        uint256 gasUsed
    );
    
    // ✅ 斐波那契数列（记忆化搜索）
    mapping(uint256 => uint256) private fibMemo;
    
    function fibonacci(uint256 n) external returns (uint256) {
        uint256 gasBefore = gasleft();
        uint256 result = _fibonacciMemo(n);
        uint256 gasUsed = gasBefore - gasleft();
        
        emit DPAlgorithmExecuted("Fibonacci", n, result, gasUsed);
        return result;
    }
    
    function _fibonacciMemo(uint256 n) private returns (uint256) {
        if (n <= 1) return n;
        
        if (fibMemo[n] != 0) {
            return fibMemo[n];
        }
        
        fibMemo[n] = _fibonacciMemo(n - 1) + _fibonacciMemo(n - 2);
        return fibMemo[n];
    }
    
    // ✅ 0-1背包问题
    function knapsack(
        uint256[] calldata weights,
        uint256[] calldata values,
        uint256 capacity
    ) external pure returns (uint256) {
        uint256 n = weights.length;
        require(n == values.length, "Arrays length mismatch");
        
        // 创建DP表
        uint256[][] memory dp = new uint256[][](n + 1);
        for (uint256 i = 0; i <= n; i++) {
            dp[i] = new uint256[](capacity + 1);
        }
        
        // 填充DP表
        for (uint256 i = 1; i <= n; i++) {
            for (uint256 w = 0; w <= capacity; w++) {
                if (weights[i - 1] <= w) {
                    dp[i][w] = _max(
                        values[i - 1] + dp[i - 1][w - weights[i - 1]],
                        dp[i - 1][w]
                    );
                } else {
                    dp[i][w] = dp[i - 1][w];
                }
            }
        }
        
        return dp[n][capacity];
    }
    
    // ✅ 最长递增子序列
    function longestIncreasingSubsequence(uint256[] calldata arr) external pure returns (uint256) {
        if (arr.length == 0) return 0;
        
        uint256[] memory dp = new uint256[](arr.length);
        
        // 初始化
        for (uint256 i = 0; i < arr.length; i++) {
            dp[i] = 1;
        }
        
        // 填充DP数组
        for (uint256 i = 1; i < arr.length; i++) {
            for (uint256 j = 0; j < i; j++) {
                if (arr[j] < arr[i]) {
                    dp[i] = _max(dp[i], dp[j] + 1);
                }
            }
        }
        
        // 找到最大值
        uint256 maxLength = dp[0];
        for (uint256 i = 1; i < dp.length; i++) {
            maxLength = _max(maxLength, dp[i]);
        }
        
        return maxLength;
    }
    
    // ✅ 编辑距离（Levenshtein距离）
    function editDistance(
        string calldata str1,
        string calldata str2
    ) external pure returns (uint256) {
        bytes memory s1 = bytes(str1);
        bytes memory s2 = bytes(str2);
        
        uint256 m = s1.length;
        uint256 n = s2.length;
        
        // 创建DP表
        uint256[][] memory dp = new uint256[][](m + 1);