# æ™ºèƒ½åˆçº¦å¼€å‘è¦ç‚¹

> **å­¦ä¹ è€…**: æ›¾æœˆ  
> **å­¦ä¹ ç‰¹è‰²**: æ³¨é‡ç”¨æˆ·ä½“éªŒå’Œç•Œé¢è®¾è®¡  
> **ä»£ç é£æ ¼**: ç”¨æˆ·ä½“éªŒä¼˜å…ˆï¼Œç•Œé¢å‹å¥½  
> **ç¬”è®°é‡ç‚¹**: ç”¨æˆ·ä½“éªŒè®¾è®¡ä¸å‰ç«¯äº¤äº’  
> **é¡¹ç›®ä»£ç **: UXOptimizedDApp.sol  
> **åˆ›å»ºæ—¶é—´**: 2024å¹´

---

## ğŸ¨ ç”¨æˆ·ä½“éªŒä¼˜åŒ–çš„æ™ºèƒ½åˆçº¦è®¾è®¡

### ç”¨æˆ·å‹å¥½çš„åˆçº¦æ¥å£

ç”¨æˆ·ä½“éªŒçš„æ ¸å¿ƒåœ¨äºç®€åŒ–å¤æ‚æ€§ï¼Œè®©ç”¨æˆ·èƒ½å¤Ÿç›´è§‚åœ°ä¸æ™ºèƒ½åˆçº¦äº¤äº’ã€‚

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

// ç”¨æˆ·ä½“éªŒä¼˜åŒ–çš„DAppåˆçº¦
contract UXOptimizedDApp {
    struct UserProfile {
        string displayName;
        string avatar; // IPFS hash
        uint256 joinDate;
        uint256 reputation;
        bool isVerified;
        mapping(string => string) preferences; // key-value pairs for user settings
    }
    
    struct Transaction {
        uint256 id;
        address from;
        address to;
        uint256 amount;
        string description;
        uint256 timestamp;
        TransactionStatus status;
        string category;
        bytes32 txHash;
    }
    
    struct NotificationSettings {
        bool emailEnabled;
        bool pushEnabled;
        bool smsEnabled;
        uint256 frequency; // 0: immediate, 1: daily, 2: weekly
        string[] subscribedEvents;
    }
    
    enum TransactionStatus { PENDING, CONFIRMED, FAILED, CANCELLED }
    
    mapping(address => UserProfile) public userProfiles;
    mapping(address => NotificationSettings) public notificationSettings;
    mapping(uint256 => Transaction) public transactions;
    mapping(address => uint256[]) public userTransactions;
    mapping(address => mapping(string => bool)) public userPermissions;
    
    uint256 public transactionCounter;
    
    // ç”¨æˆ·ä½“éªŒäº‹ä»¶
    event UserRegistered(address indexed user, string displayName);
    event ProfileUpdated(address indexed user, string field, string newValue);
    event TransactionInitiated(uint256 indexed txId, address indexed from, address indexed to, uint256 amount);
    event TransactionCompleted(uint256 indexed txId, TransactionStatus status);
    event NotificationSent(address indexed user, string eventType, string message);
    event PreferenceUpdated(address indexed user, string key, string value);
    
    // é”™è¯¯å®šä¹‰ï¼ˆç”¨æˆ·å‹å¥½çš„é”™è¯¯æ¶ˆæ¯ï¼‰
    error UserNotRegistered(address user);
    error InsufficientBalance(uint256 available, uint256 required);
    error InvalidDisplayName(string name);
    error TransactionNotFound(uint256 txId);
    error UnauthorizedAccess(address user, string action);
    error InvalidPreference(string key, string value);
    
    modifier onlyRegisteredUser() {
        if (bytes(userProfiles[msg.sender].displayName).length == 0) {
            revert UserNotRegistered(msg.sender);
        }
        _;
    }
    
    modifier validDisplayName(string memory name) {
        if (bytes(name).length == 0 || bytes(name).length > 50) {
            revert InvalidDisplayName(name);
        }
        _;
    }
    
    // ç”¨æˆ·æ³¨å†Œï¼ˆç®€åŒ–æµç¨‹ï¼‰
    function registerUser(
        string memory displayName,
        string memory avatar
    ) external validDisplayName(displayName) {
        require(bytes(userProfiles[msg.sender].displayName).length == 0, "User already registered");
        
        UserProfile storage profile = userProfiles[msg.sender];
        profile.displayName = displayName;
        profile.avatar = avatar;
        profile.joinDate = block.timestamp;
        profile.reputation = 100; // åˆå§‹å£°èª‰å€¼
        profile.isVerified = false;
        
        // è®¾ç½®é»˜è®¤é€šçŸ¥åå¥½
        notificationSettings[msg.sender] = NotificationSettings({
            emailEnabled: true,
            pushEnabled: true,
            smsEnabled: false,
            frequency: 0, // ç«‹å³é€šçŸ¥
            subscribedEvents: new string[](0)
        });
        
        emit UserRegistered(msg.sender, displayName);
        emit NotificationSent(msg.sender, "WELCOME", "Welcome to our platform!");
    }
    
    // æ›´æ–°ç”¨æˆ·èµ„æ–™
    function updateProfile(
        string memory displayName,
        string memory avatar
    ) external onlyRegisteredUser validDisplayName(displayName) {
        UserProfile storage profile = userProfiles[msg.sender];
        
        if (bytes(displayName).length > 0 && 
            keccak256(bytes(profile.displayName)) != keccak256(bytes(displayName))) {
            profile.displayName = displayName;
            emit ProfileUpdated(msg.sender, "displayName", displayName);
        }
        
        if (bytes(avatar).length > 0 && 
            keccak256(bytes(profile.avatar)) != keccak256(bytes(avatar))) {
            profile.avatar = avatar;
            emit ProfileUpdated(msg.sender, "avatar", avatar);
        }
    }
    
    // è®¾ç½®ç”¨æˆ·åå¥½
    function setUserPreference(
        string memory key,
        string memory value
    ) external onlyRegisteredUser {
        // éªŒè¯åå¥½è®¾ç½®
        if (!_isValidPreference(key, value)) {
            revert InvalidPreference(key, value);
        }
        
        userProfiles[msg.sender].preferences[key] = value;
        emit PreferenceUpdated(msg.sender, key, value);
    }
    
    // æ‰¹é‡è®¾ç½®ç”¨æˆ·åå¥½
    function setBatchPreferences(
        string[] memory keys,
        string[] memory values
    ) external onlyRegisteredUser {
        require(keys.length == values.length, "Arrays length mismatch");
        
        for (uint256 i = 0; i < keys.length; i++) {
            if (_isValidPreference(keys[i], values[i])) {
                userProfiles[msg.sender].preferences[keys[i]] = values[i];
                emit PreferenceUpdated(msg.sender, keys[i], values[i]);
            }
        }
    }
    
    // æ›´æ–°é€šçŸ¥è®¾ç½®
    function updateNotificationSettings(
        bool emailEnabled,
        bool pushEnabled,
        bool smsEnabled,
        uint256 frequency,
        string[] memory subscribedEvents
    ) external onlyRegisteredUser {
        require(frequency <= 2, "Invalid frequency");
        
        NotificationSettings storage settings = notificationSettings[msg.sender];
        settings.emailEnabled = emailEnabled;
        settings.pushEnabled = pushEnabled;
        settings.smsEnabled = smsEnabled;
        settings.frequency = frequency;
        settings.subscribedEvents = subscribedEvents;
        
        emit NotificationSent(msg.sender, "SETTINGS_UPDATED", "Notification settings updated");
    }
    
    // å‘èµ·äº¤æ˜“ï¼ˆç”¨æˆ·å‹å¥½çš„æ¥å£ï¼‰
    function initiateTransaction(
        address to,
        uint256 amount,
        string memory description,
        string memory category
    ) external onlyRegisteredUser returns (uint256) {
        require(to != address(0), "Invalid recipient");
        require(to != msg.sender, "Cannot send to yourself");
        require(amount > 0, "Amount must be positive");
        require(bytes(userProfiles[to].displayName).length > 0, "Recipient not registered");
        
        // æ£€æŸ¥ä½™é¢ï¼ˆå‡è®¾æœ‰ä½™é¢ç³»ç»Ÿï¼‰
        uint256 senderBalance = _getBalance(msg.sender);
        if (senderBalance < amount) {
            revert InsufficientBalance(senderBalance, amount);
        }
        
        uint256 txId = transactionCounter++;
        
        transactions[txId] = Transaction({
            id: txId,
            from: msg.sender,
            to: to,
            amount: amount,
            description: description,
            timestamp: block.timestamp,
            status: TransactionStatus.PENDING,
            category: category,
            txHash: bytes32(0) // å°†åœ¨ç¡®è®¤æ—¶è®¾ç½®
        });
        
        userTransactions[msg.sender].push(txId);
        userTransactions[to].push(txId);
        
        emit TransactionInitiated(txId, msg.sender, to, amount);
        
        // å‘é€é€šçŸ¥
        _sendNotification(msg.sender, "TRANSACTION_SENT", 
            string(abi.encodePacked("Transaction sent to ", userProfiles[to].displayName)));
        _sendNotification(to, "TRANSACTION_RECEIVED", 
            string(abi.encodePacked("Transaction received from ", userProfiles[msg.sender].displayName)));
        
        return txId;
    }
    
    // ç¡®è®¤äº¤æ˜“
    function confirmTransaction(uint256 txId, bytes32 txHash) external {
        if (txId >= transactionCounter) {
            revert TransactionNotFound(txId);
        }
        
        Transaction storage txn = transactions[txId];
        require(txn.status == TransactionStatus.PENDING, "Transaction not pending");
        require(msg.sender == txn.from || msg.sender == txn.to, "Unauthorized");
        
        txn.status = TransactionStatus.CONFIRMED;
        txn.txHash = txHash;
        
        // æ›´æ–°å£°èª‰å€¼
        userProfiles[txn.from].reputation += 1;
        userProfiles[txn.to].reputation += 1;
        
        emit TransactionCompleted(txId, TransactionStatus.CONFIRMED);
        
        // å‘é€ç¡®è®¤é€šçŸ¥
        _sendNotification(txn.from, "TRANSACTION_CONFIRMED", "Your transaction has been confirmed");
        _sendNotification(txn.to, "TRANSACTION_CONFIRMED", "Transaction confirmed");
    }
    
    // å–æ¶ˆäº¤æ˜“
    function cancelTransaction(uint256 txId) external {
        if (txId >= transactionCounter) {
            revert TransactionNotFound(txId);
        }
        
        Transaction storage txn = transactions[txId];
        require(txn.status == TransactionStatus.PENDING, "Transaction not pending");
        require(msg.sender == txn.from, "Only sender can cancel");
        
        txn.status = TransactionStatus.CANCELLED;
        
        emit TransactionCompleted(txId, TransactionStatus.CANCELLED);
        
        // å‘é€å–æ¶ˆé€šçŸ¥
        _sendNotification(txn.from, "TRANSACTION_CANCELLED", "Your transaction has been cancelled");
        _sendNotification(txn.to, "TRANSACTION_CANCELLED", "Transaction was cancelled");
    }
    
    // è·å–ç”¨æˆ·äº¤æ˜“å†å²ï¼ˆåˆ†é¡µï¼‰
    function getUserTransactions(
        address user,
        uint256 offset,
        uint256 limit
    ) external view returns (Transaction[] memory) {
        uint256[] storage txIds = userTransactions[user];
        
        if (offset >= txIds.length) {
            return new Transaction[](0);
        }
        
        uint256 end = offset + limit;
        if (end > txIds.length) {
            end = txIds.length;
        }
        
        Transaction[] memory result = new Transaction[](end - offset);
        
        for (uint256 i = offset; i < end; i++) {
            result[i - offset] = transactions[txIds[i]];
        }
        
        return result;
    }
    
    // æœç´¢äº¤æ˜“
    function searchTransactions(
        address user,
        string memory category,
        uint256 fromDate,
        uint256 toDate
    ) external view returns (uint256[] memory) {
        uint256[] storage txIds = userTransactions[user];
        uint256[] memory matchingIds = new uint256[](txIds.length);
        uint256 count = 0;
        
        for (uint256 i = 0; i < txIds.length; i++) {
            Transaction storage txn = transactions[txIds[i]];
            
            bool matches = true;
            
            // ç±»åˆ«è¿‡æ»¤
            if (bytes(category).length > 0) {
                matches = matches && (keccak256(bytes(txn.category)) == keccak256(bytes(category)));
            }
            
            // æ—¥æœŸèŒƒå›´è¿‡æ»¤
            if (fromDate > 0) {
                matches = matches && (txn.timestamp >= fromDate);
            }
            if (toDate > 0) {
                matches = matches && (txn.timestamp <= toDate);
            }
            
            if (matches) {
                matchingIds[count] = txIds[i];
                count++;
            }
        }
        
        // è°ƒæ•´æ•°ç»„å¤§å°
        uint256[] memory result = new uint256[](count);
        for (uint256 i = 0; i < count; i++) {
            result[i] = matchingIds[i];
        }
        
        return result;
    }
    
    // è·å–ç”¨æˆ·ç»Ÿè®¡ä¿¡æ¯
    function getUserStats(address user) 
        external 
        view 
        returns (
            uint256 totalTransactions,
            uint256 totalSent,
            uint256 totalReceived,
            uint256 reputation,
            uint256 joinDate,
            bool isVerified
        ) 
    {
        UserProfile storage profile = userProfiles[user];
        uint256[] storage txIds = userTransactions[user];
        
        totalTransactions = txIds.length;
        totalSent = 0;
        totalReceived = 0;
        
        for (uint256 i = 0; i < txIds.length; i++) {
            Transaction storage txn = transactions[txIds[i]];
            if (txn.from == user) {
                totalSent += txn.amount;
            } else {
                totalReceived += txn.amount;
            }
        }
        
        reputation = profile.reputation;
        joinDate = profile.joinDate;
        isVerified = profile.isVerified;
    }
    
    // è·å–ç”¨æˆ·åå¥½
    function getUserPreference(address user, string memory key) 
        external 
        view 
        returns (string memory) 
    {
        return userProfiles[user].preferences[key];
    }
    
    // è·å–ç”¨æˆ·æ˜¾ç¤ºä¿¡æ¯
    function getUserDisplayInfo(address user) 
        external 
        view 
        returns (
            string memory displayName,
            string memory avatar,
            uint256 reputation,
            bool isVerified
        ) 
    {
        UserProfile storage profile = userProfiles[user];
        return (
            profile.displayName,
            profile.avatar,
            profile.reputation,
            profile.isVerified
        );
    }
    
    // å†…éƒ¨å‡½æ•°ï¼šéªŒè¯åå¥½è®¾ç½®
    function _isValidPreference(string memory key, string memory value) 
        internal 
        pure 
        returns (bool) 
    {
        // ä¸»é¢˜è®¾ç½®
        if (keccak256(bytes(key)) == keccak256(bytes("theme"))) {
            return (keccak256(bytes(value)) == keccak256(bytes("light")) ||
                    keccak256(bytes(value)) == keccak256(bytes("dark")) ||
                    keccak256(bytes(value)) == keccak256(bytes("auto")));
        }
        
        // è¯­è¨€è®¾ç½®
        if (keccak256(bytes(key)) == keccak256(bytes("language"))) {
            return (keccak256(bytes(value)) == keccak256(bytes("en")) ||
                    keccak256(bytes(value)) == keccak256(bytes("zh")) ||
                    keccak256(bytes(value)) == keccak256(bytes("es")) ||
                    keccak256(bytes(value)) == keccak256(bytes("fr")));
        }
        
        // è´§å¸æ˜¾ç¤º
        if (keccak256(bytes(key)) == keccak256(bytes("currency"))) {
            return (keccak256(bytes(value)) == keccak256(bytes("USD")) ||
                    keccak256(bytes(value)) == keccak256(bytes("EUR")) ||
                    keccak256(bytes(value)) == keccak256(bytes("CNY")) ||
                    keccak256(bytes(value)) == keccak256(bytes("ETH")));
        }
        
        // æ—¶åŒºè®¾ç½®
        if (keccak256(bytes(key)) == keccak256(bytes("timezone"))) {
            return bytes(value).length > 0 && bytes(value).length <= 50;
        }
        
        // é»˜è®¤å…è®¸å…¶ä»–è®¾ç½®
        return bytes(value).length <= 200;
    }
    
    // å†…éƒ¨å‡½æ•°ï¼šå‘é€é€šçŸ¥
    function _sendNotification(
        address user,
        string memory eventType,
        string memory message
    ) internal {
        NotificationSettings storage settings = notificationSettings[user];
        
        // æ£€æŸ¥ç”¨æˆ·æ˜¯å¦è®¢é˜…äº†æ­¤ç±»äº‹ä»¶
        bool subscribed = false;
        for (uint256 i = 0; i < settings.subscribedEvents.length; i++) {
            if (keccak256(bytes(settings.subscribedEvents[i])) == keccak256(bytes(eventType))) {
                subscribed = true;
                break;
            }
        }
        
        // å¦‚æœæ²¡æœ‰ç‰¹å®šè®¢é˜…ï¼Œæ£€æŸ¥å…¨å±€è®¾ç½®
        if (!subscribed && (settings.emailEnabled || settings.pushEnabled)) {
            subscribed = true;
        }
        
        if (subscribed) {
            emit NotificationSent(user, eventType, message);
        }
    }
    
    // å†…éƒ¨å‡½æ•°ï¼šè·å–ä½™é¢ï¼ˆç¤ºä¾‹å®ç°ï¼‰
    function _getBalance(address user) internal pure returns (uint256) {
        // è¿™é‡Œåº”è¯¥è¿æ¥åˆ°å®é™…çš„ä½™é¢ç³»ç»Ÿ
        // ä¸ºäº†æ¼”ç¤ºï¼Œè¿”å›ä¸€ä¸ªå›ºå®šå€¼
        return 1000 ether;
    }
    
    // éªŒè¯ç”¨æˆ·
    function verifyUser(address user) external {
        // è¿™é‡Œåº”è¯¥æœ‰é€‚å½“çš„æƒé™æ£€æŸ¥
        require(bytes(userProfiles[user].displayName).length > 0, "User not registered");
        
        userProfiles[user].isVerified = true;
        userProfiles[user].reputation += 50; // éªŒè¯å¥–åŠ±
        
        _sendNotification(user, "ACCOUNT_VERIFIED", "Your account has been verified!");
    }
    
    // è·å–å¹³å°ç»Ÿè®¡ä¿¡æ¯
    function getPlatformStats() 
        external 
        view 
        returns (
            uint256 totalUsers,
            uint256 totalTransactions,
            uint256 totalVolume
        ) 
    {
        // è¿™é‡Œåº”è¯¥æœ‰æ›´é«˜æ•ˆçš„ç»Ÿè®¡æ–¹æ³•
        // ä¸ºäº†æ¼”ç¤ºï¼Œè¿”å›åŸºæœ¬ä¿¡æ¯
        totalTransactions = transactionCounter;
        
        // åœ¨å®é™…å®ç°ä¸­ï¼Œè¿™äº›ç»Ÿè®¡ä¿¡æ¯åº”è¯¥è¢«ç¼“å­˜
        totalUsers = 0; // éœ€è¦éå†æ‰€æœ‰ç”¨æˆ·æ¥è®¡ç®—
        totalVolume = 0; // éœ€è¦éå†æ‰€æœ‰äº¤æ˜“æ¥è®¡ç®—
    }
}
```

### å‰ç«¯äº¤äº’ä¼˜åŒ–åˆçº¦

```solidity
// å‰ç«¯å‹å¥½çš„æ•°æ®æŸ¥è¯¢å’Œæ‰¹é‡æ“ä½œåˆçº¦
contract FrontendOptimizedContract {
    struct BatchResponse {
        bool success;
        bytes data;
        string error;
    }
    
    struct PaginatedResult {
        uint256 total;
        uint256 page;
        uint256 pageSize;
        bytes[] items;
        bool hasNext;
        bool hasPrevious;
    }
    
    struct FilterOptions {
        string[] categories;
        uint256 minAmount;
        uint256 maxAmount;
        uint256 fromDate;
        uint256 toDate;
        address[] users;
        string searchTerm;
    }
    
    // æ‰¹é‡æŸ¥è¯¢æ¥å£
    function batchQuery(bytes[] calldata queries) 
        external 
        view 
        returns (BatchResponse[] memory responses) 
    {
        responses = new BatchResponse[](queries.length);
        
        for (uint256 i = 0; i < queries.length; i++) {
            try this.executeQuery(queries[i]) returns (bytes memory result) {
                responses[i] = BatchResponse({
                    success: true,
                    data: result,
                    error: ""
                });
            } catch Error(string memory reason) {
                responses[i] = BatchResponse({
                    success: false,
                    data: "",
                    error: reason
                });
            } catch (bytes memory lowLevelData) {
                responses[i] = BatchResponse({
                    success: false,
                    data: lowLevelData,
                    error: "Low-level error"
                });
            }
        }
    }
    
    // æŸ¥è¯¢æ‰§è¡Œå™¨
    function executeQuery(bytes calldata query) external view returns (bytes memory) {
        // è§£ææŸ¥è¯¢ç±»å‹å¹¶æ‰§è¡Œç›¸åº”æ“ä½œ
        // è¿™é‡Œéœ€è¦æ ¹æ®å®é™…éœ€æ±‚å®ç°æŸ¥è¯¢è·¯ç”±
        return query; // ç®€åŒ–å®ç°
    }
    
    // åˆ†é¡µæŸ¥è¯¢
    function paginatedQuery(
        string memory queryType,
        FilterOptions memory filters,
        uint256 page,
        uint256 pageSize
    ) external view returns (PaginatedResult memory) {
        require(pageSize > 0 && pageSize <= 100, "Invalid page size");
        require(page > 0, "Invalid page number");
        
        // æ ¹æ®æŸ¥è¯¢ç±»å‹å’Œè¿‡æ»¤æ¡ä»¶è·å–æ•°æ®
        bytes[] memory allItems = _getFilteredData(queryType, filters);
        
        uint256 total = allItems.length;
        uint256 offset = (page - 1) * pageSize;
        
        if (offset >= total) {
            return PaginatedResult({
                total: total,
                page: page,
                pageSize: pageSize,
                items: new bytes[](0),
                hasNext: false,
                hasPrevious: page > 1
            });
        }
        
        uint256 end = offset + pageSize;
        if (end > total) {
            end = total;
        }
        
        bytes[] memory pageItems = new bytes[](end - offset);
        for (uint256 i = offset; i < end; i++) {
            pageItems[i - offset] = allItems[i];
        }
        
        return PaginatedResult({
            total: total,
            page: page,
            pageSize: pageSize,
            items: pageItems,
            hasNext: end < total,
            hasPrevious: page > 1
        });
    }
    
    // å®æ—¶æ•°æ®è®¢é˜…
    event DataUpdated(string indexed dataType, bytes32 indexed key, bytes data);
    event BulkDataUpdated(string indexed dataType, bytes32[] keys, bytes[] data);
    
    mapping(string => mapping(bytes32 => bytes)) public subscribableData;
    mapping(address => mapping(string => bool)) public subscriptions;
    
    // è®¢é˜…æ•°æ®æ›´æ–°
    function subscribe(string memory dataType) external {
        subscriptions[msg.sender][dataType] = true;
    }
    
    // å–æ¶ˆè®¢é˜…
    function unsubscribe(string memory dataType) external {
        subscriptions[msg.sender][dataType] = false;
    }
    
    // æ›´æ–°æ•°æ®å¹¶é€šçŸ¥è®¢é˜…è€…
    function updateData(
        string memory dataType,
        bytes32 key,
        bytes memory data
    ) external {
        subscribableData[dataType][key] = data;
        emit DataUpdated(dataType, key, data);
    }
    
    // æ‰¹é‡æ›´æ–°æ•°æ®
    function bulkUpdateData(
        string memory dataType,
        bytes32[] memory keys,
        bytes[] memory data
    ) external {
        require(keys.length == data.length, "Arrays length mismatch");
        
        for (uint256 i = 0; i < keys.length; i++) {
            subscribableData[dataType][keys[i]] = data[i];
        }
        
        emit BulkDataUpdated(dataType, keys, data);
    }
    
    // è·å–ç”¨æˆ·å‹å¥½çš„é”™è¯¯ä¿¡æ¯
    function getErrorMessage(bytes memory errorData) 
        external 
        pure 
        returns (string memory) 
    {
        if (errorData.length == 0) {
            return "Unknown error occurred";
        }
        
        // å°è¯•è§£æè‡ªå®šä¹‰é”™è¯¯
        if (errorData.length >= 4) {
            bytes4 selector = bytes4(errorData);
            
            // è¿™é‡Œå¯ä»¥æ·»åŠ æ›´å¤šé”™è¯¯ç±»å‹çš„è§£æ
            if (selector == bytes4(keccak256("InsufficientBalance(uint256,uint256)"))) {
                return "Insufficient balance for this transaction";
            }
            
            if (selector == bytes4(keccak256("UserNotRegistered(address)"))) {
                return "User account not found. Please register first";
            }
            
            if (selector == bytes4(keccak256("UnauthorizedAccess(address,string)"))) {
                return "You don't have permission to perform this action";
            }
        }
        
        // å°è¯•è§£æå­—ç¬¦ä¸²é”™è¯¯
        if (errorData.length > 68) {
            return string(abi.decode(errorData[4:], (string)));
        }
        
        return "Transaction failed. Please try again";
    }
    
    // è·å–æ“ä½œå»ºè®®
    function getActionSuggestions(address user, string memory context) 
        external 
        view 
        returns (string[] memory suggestions) 
    {
        // æ ¹æ®ç”¨æˆ·çŠ¶æ€å’Œä¸Šä¸‹æ–‡æä¾›æ“ä½œå»ºè®®
        suggestions = new string[](3);
        
        if (keccak256(bytes(context)) == keccak256(bytes("low_balance"))) {
            suggestions[0] = "Add funds to your account";
            suggestions[1] = "Reduce transaction amount";
            suggestions[2] = "Check for pending transactions";
        } else if (keccak256(bytes(context)) == keccak256(bytes("failed_transaction"))) {
            suggestions[0] = "Check network status";
            suggestions[1] = "Increase gas limit";
            suggestions[2] = "Try again later";
        } else {
            suggestions[0] = "Explore available features";
            suggestions[1] = "Update your profile";
            suggestions[2] = "Check transaction history";
        }
    }
    
    // å†…éƒ¨å‡½æ•°ï¼šæ ¹æ®è¿‡æ»¤æ¡ä»¶è·å–æ•°æ®
    function _getFilteredData(
        string memory queryType,
        FilterOptions memory filters
    ) internal view returns (bytes[] memory) {
        // è¿™é‡Œåº”è¯¥æ ¹æ®å®é™…çš„æ•°æ®ç»“æ„å®ç°è¿‡æ»¤é€»è¾‘
        // ä¸ºäº†æ¼”ç¤ºï¼Œè¿”å›ç©ºæ•°ç»„
        return new bytes[](0);
    }
    
    // è·å–ç”¨æˆ·æ“ä½œå†å²
    function getUserActionHistory(
        address user,
        uint256 limit
    ) external view returns (bytes[] memory actions) {
        // å®ç°ç”¨æˆ·æ“ä½œå†å²æŸ¥è¯¢
        actions = new bytes[](limit);
        // å¡«å……å®é™…æ•°æ®...
    }
    
    // é¢„åŠ è½½ç”¨æˆ·æ•°æ®
    function preloadUserData(address user) 
        external 
        view 
        returns (
            bytes memory profileData,
            bytes memory preferencesData,
            bytes memory recentTransactions,
            bytes memory notifications
        ) 
    {
        // ä¸€æ¬¡æ€§åŠ è½½ç”¨æˆ·éœ€è¦çš„æ‰€æœ‰æ•°æ®ï¼Œå‡å°‘å‰ç«¯è¯·æ±‚æ¬¡æ•°
        // å®é™…å®ç°éœ€è¦æ ¹æ®å…·ä½“çš„æ•°æ®ç»“æ„æ¥ç¼–å†™
        profileData = abi.encode(user); // ç®€åŒ–å®ç°
        preferencesData = abi.encode(user);
        recentTransactions = abi.encode(user);
        notifications = abi.encode(user);
    }
}
```

### å“åº”å¼è®¾è®¡æ”¯æŒåˆçº¦

```solidity
// æ”¯æŒå“åº”å¼è®¾è®¡çš„é…ç½®ç®¡ç†åˆçº¦
contract ResponsiveDesignSupport {
    struct LayoutConfig {
        string deviceType; // mobile, tablet, desktop
        uint256 maxWidth;
        uint256 columns;
        uint256 itemsPerPage;
        bool showSidebar;
        bool compactMode;
        string[] hiddenElements;
    }
    
    struct ThemeConfig {
        string name;
        mapping(string => string) colors;
        mapping(string => string) fonts;
        mapping(string => uint256) sizes;
        bool darkMode;
        uint256 borderRadius;
        uint256 spacing;
    }
    
    struct AccessibilityConfig {
        bool highContrast;
        uint256 fontSize; // percentage: 100 = normal, 150 = 150%
        bool screenReader;
        bool keyboardNavigation;
        bool reducedMotion;
        string language;
        bool rightToLeft;
    }
    
    mapping(address => mapping(string => LayoutConfig)) public userLayouts;
    mapping(string => ThemeConfig) public themes;
    mapping(address => AccessibilityConfig) public accessibilitySettings;
    mapping(address => string) public userSelectedTheme;
    
    string[] public availableThemes;
    
    event LayoutConfigUpdated(address indexed user, string deviceType);
    event ThemeChanged(address indexed user, string themeName);
    event AccessibilityUpdated(address indexed user, string setting, string value);
    
    constructor() {
        // åˆå§‹åŒ–é»˜è®¤ä¸»é¢˜
        _initializeDefaultThemes();
    }
    
    // è®¾ç½®å¸ƒå±€é…ç½®
    function setLayoutConfig(
        string memory deviceType,
        uint256 maxWidth,
        uint256 columns,
        uint256 itemsPerPage,
        bool showSidebar,
        bool compactMode,
        string[] memory hiddenElements
    ) external {
        userLayouts[msg.sender][deviceType] = LayoutConfig({
            deviceType: deviceType,
            maxWidth: maxWidth,
            columns: columns,
            itemsPerPage: itemsPerPage,
            showSidebar: showSidebar,
            compactMode: compactMode,
            hiddenElements: hiddenElements
        });
        
        emit LayoutConfigUpdated(msg.sender, deviceType);
    }
    
    // è·å–å¸ƒå±€é…ç½®
    function getLayoutConfig(address user, string memory deviceType)
        external
        view
        returns (
            uint256 maxWidth,
            uint256 columns,
            uint256 itemsPerPage,
            bool showSidebar,
            bool compactMode,
            string[] memory hiddenElements
        )
    {
        LayoutConfig storage config = userLayouts[user][deviceType];
        
        // å¦‚æœç”¨æˆ·æ²¡æœ‰è®¾ç½®ï¼Œè¿”å›é»˜è®¤é…ç½®
        if (bytes(config.deviceType).length == 0) {
            return _getDefaultLayoutConfig(deviceType);
        }
        
        return (
            config.maxWidth,
            config.columns,
            config.itemsPerPage,
            config.showSidebar,
            config.compactMode,
            config.hiddenElements
        );
    }
    
    // è®¾ç½®ä¸»é¢˜
    function setUserTheme(string memory themeName) external {
        require(_themeExists(themeName), "Theme does not exist");
        
        userSelectedTheme[msg.sender] = themeName;
        emit ThemeChanged(msg.sender, themeName);
    }
    
    // åˆ›å»ºè‡ªå®šä¹‰ä¸»é¢˜
    function createCustomTheme(
        string memory name,
        string[] memory colorKeys,
        string[] memory colorValues,
        string[] memory fontKeys,
        string[] memory fontValues,
        string[] memory sizeKeys,
        uint256[] memory sizeValues,
        bool darkMode,
        uint256 borderRadius,
        uint256 spacing
    ) external {
        require(bytes(name).length > 0, "Theme name cannot be empty");
        require(colorKeys.length == colorValues.length, "Color arrays length mismatch");
        require(fontKeys.length == fontValues.length, "Font arrays length mismatch");
        require(sizeKeys.length == sizeValues.length, "Size arrays length mismatch");
        
        ThemeConfig storage theme = themes[name];
        theme.name = name;
        theme.darkMode = darkMode;
        theme.borderRadius = borderRadius;
        theme.spacing = spacing;
        
        // è®¾ç½®é¢œè‰²
        for (uint256 i = 0; i < colorKeys.length; i++) {
            theme.colors[colorKeys[i]] = colorValues[i];
        }
        
        // è®¾ç½®å­—ä½“
        for (uint256 i = 0; i < fontKeys.length; i++) {
            theme.fonts[fontKeys[i]] = fontValues[i];
        }
        
        // è®¾ç½®å°ºå¯¸
        for (uint256 i = 0; i < sizeKeys.length; i++) {
            theme.sizes[sizeKeys[i]] = sizeValues[i];
        }
        
        // æ·»åŠ åˆ°å¯ç”¨ä¸»é¢˜åˆ—è¡¨
        if (!_themeExists(name)) {
            availableThemes.push(name);
        }
    }
    
    // è®¾ç½®æ— éšœç¢é…ç½®
    function setAccessibilityConfig(
        bool highContrast,
        uint256 fontSize,
        bool screenReader,
        bool keyboardNavigation,
        bool reducedMotion,
        string memory language,
        bool rightToLeft
    ) external {
        require(fontSize >= 50 && fontSize <= 300, "Font size must be between 50% and 300%");
        
        accessibilitySettings[msg.sender] = AccessibilityConfig({
            highContrast: highContrast,
            fontSize: fontSize,
            screenReader: screenReader,
            keyboardNavigation: keyboardNavigation,
            reducedMotion: reducedMotion,
            language: language,
            rightToLeft: rightToLeft
        });
        
        emit AccessibilityUpdated(msg.sender, "all", "updated");
    }
    
    // è·å–ç”¨æˆ·å®Œæ•´çš„UIé…ç½®
    function getUserUIConfig(address user, string memory deviceType)
        external
        view
        returns (
            bytes memory layoutConfig,
            bytes memory themeConfig,
            bytes memory accessibilityConfig
        )
    {
        // è·å–å¸ƒå±€é…ç½®
        (
            uint256 maxWidth,
            uint256 columns,
            uint256 itemsPerPage,
            bool showSidebar,
            bool compactMode,
            string[] memory hiddenElements
        ) = this.getLayoutConfig(user, deviceType);
        
        layoutConfig = abi.encode(
            maxWidth,
            columns,
            itemsPerPage,
            showSidebar,
            compactMode,
            hiddenElements
        );
        
        // è·å–ä¸»é¢˜é…ç½®
        string memory themeName = userSelectedTheme[user];
        if (bytes(themeName).length == 0) {
            themeName = "default";
        }
        
        themeConfig = abi.encode(
            themeName,
            themes[themeName].darkMode,
            themes[themeName].borderRadius,
            themes[themeName].spacing
        );
        
        // è·å–æ— éšœç¢é…ç½®
        AccessibilityConfig storage accessibility = accessibilitySettings[user];
        accessibilityConfig = abi.encode(
            accessibility.highContrast,
            accessibility.fontSize,
            accessibility.screenReader,
            accessibility.keyboardNavigation,
            accessibility.reducedMotion,
            accessibility.language,
            accessibility.rightToLeft
        );
    }
    
    // è·å–ä¸»é¢˜é¢œè‰²
    function getThemeColor(string memory themeName, string memory colorKey)
        external
        view
        returns (string memory)
    {
        return themes[themeName].colors[colorKey];
    }
    
    // è·å–å¯ç”¨ä¸»é¢˜åˆ—è¡¨
    function getAvailableThemes() external view returns (string[] memory) {
        return availableThemes;
    }
    
    // æ£€æµ‹è®¾å¤‡ç±»å‹ï¼ˆåŸºäºå±å¹•å®½åº¦ï¼‰
    function detectDeviceType(uint256 screenWidth) external pure returns (string memory) {
        if (screenWidth < 768) {
            return "mobile";
        } else if (screenWidth < 1024) {
            return "tablet";
        } else {
            return "desktop";
        }
    }
    
    // å†…éƒ¨å‡½æ•°ï¼šåˆå§‹åŒ–é»˜è®¤ä¸»é¢˜
    function _initializeDefaultThemes() internal {
        // é»˜è®¤æµ…è‰²ä¸»é¢˜
        availableThemes.push("default");
        ThemeConfig storage defaultTheme = themes["default"];
        defaultTheme.name = "default";
        defaultTheme.darkMode = false;
        defaultTheme.borderRadius = 8;
        defaultTheme.spacing = 16;
        
        // é»˜è®¤æ·±è‰²ä¸»é¢˜
        availableThemes.push("dark");
        ThemeConfig storage darkTheme = themes["dark"];
        darkTheme.name = "dark";
        darkTheme.darkMode = true;
        darkTheme.borderRadius = 8;
        darkTheme.spacing = 16;
    }
    
    // å†…éƒ¨å‡½æ•°ï¼šè·å–é»˜è®¤å¸ƒå±€é…ç½®
    function _getDefaultLayoutConfig(string memory deviceType)
        internal
        pure
        returns (
            uint256 maxWidth,
            uint256 columns,
            uint256 itemsPerPage,
            bool showSidebar,
            bool compactMode,
            string[] memory hiddenElements
        )
    {
        hiddenElements = new string[](0);
        
        if (keccak256(bytes(deviceType)) == keccak256(bytes("mobile"))) {
            return (768, 1, 10, false, true, hiddenElements);
        } else if (keccak256(bytes(deviceType)) == keccak256(bytes("tablet"))) {
            return (1024, 2, 20, false, false, hiddenElements);
        } else {
            return (1920, 3, 30, true, false, hiddenElements);
        }
    }
    
    // å†…éƒ¨å‡½æ•°ï¼šæ£€æŸ¥ä¸»é¢˜æ˜¯å¦å­˜åœ¨
    function _themeExists(string memory themeName) internal view returns (bool) {
        for (uint256 i = 0; i < availableThemes.length; i++) {
            if (keccak256(bytes(availableThemes[i])) == keccak256(bytes(themeName))) {
                return true;
            }
        }
        return false;
    }
}
```

---

## ğŸ¯ ç”¨æˆ·ä½“éªŒè®¾è®¡åŸåˆ™

### ç®€åŒ–å¤æ‚æ€§

1. **æ¸è¿›å¼æŠ«éœ²**
   - åªæ˜¾ç¤ºç”¨æˆ·å½“å‰éœ€è¦çš„ä¿¡æ¯
   - é«˜çº§åŠŸèƒ½é€šè¿‡å±•å¼€æˆ–äºŒçº§èœå•æä¾›
   - é¿å…ä¿¡æ¯è¿‡è½½

2. **æ™ºèƒ½é»˜è®¤å€¼**
   - ä¸ºç”¨æˆ·æä¾›åˆç†çš„é»˜è®¤è®¾ç½®
   - å‡å°‘ç”¨æˆ·éœ€è¦åšçš„å†³ç­–
   - åŸºäºç”¨æˆ·è¡Œä¸ºå­¦ä¹ å’Œä¼˜åŒ–é»˜è®¤å€¼

3. **ä¸€è‡´æ€§è®¾è®¡**
   - ç»Ÿä¸€çš„äº¤äº’æ¨¡å¼
   - ä¸€è‡´çš„è§†è§‰è¯­è¨€
   - å¯é¢„æµ‹çš„è¡Œä¸ºæ¨¡å¼

### é”™è¯¯é¢„é˜²ä¸å¤„ç†

1. **è¾“å…¥éªŒè¯**
   - å®æ—¶éªŒè¯ç”¨æˆ·è¾“å…¥
   - æä¾›æ¸…æ™°çš„é”™è¯¯æç¤º
   - å»ºè®®æ­£ç¡®çš„è¾“å…¥æ ¼å¼

2. **ç¡®è®¤æœºåˆ¶**
   - é‡è¦æ“ä½œéœ€è¦ç¡®è®¤
   - æä¾›æ“ä½œé¢„è§ˆ
   - æ”¯æŒæ’¤é”€åŠŸèƒ½

3. **ä¼˜é›…é™çº§**
   - ç½‘ç»œé—®é¢˜æ—¶çš„ç¦»çº¿åŠŸèƒ½
   - éƒ¨åˆ†åŠŸèƒ½å¤±æ•ˆæ—¶çš„æ›¿ä»£æ–¹æ¡ˆ
   - æ¸…æ™°çš„çŠ¶æ€æŒ‡ç¤º

### æ€§èƒ½ä¼˜åŒ–

1. **åŠ è½½ä¼˜åŒ–**
   - å…³é”®å†…å®¹ä¼˜å…ˆåŠ è½½
   - æ‡’åŠ è½½éå…³é”®èµ„æº
   - é¢„åŠ è½½ç”¨æˆ·å¯èƒ½éœ€è¦çš„æ•°æ®

2. **å“åº”é€Ÿåº¦**
   - å³æ—¶åé¦ˆç”¨æˆ·æ“ä½œ
   - å¼‚æ­¥å¤„ç†é•¿æ—¶é—´æ“ä½œ
   - è¿›åº¦æŒ‡ç¤ºå™¨

3. **ç¼“å­˜ç­–ç•¥**
   - æ™ºèƒ½ç¼“å­˜å¸¸ç”¨æ•°æ®
   - ç¦»çº¿æ•°æ®è®¿é—®
   - å¢é‡æ›´æ–°

---

## ğŸ“š å­¦ä¹ å¿ƒå¾—ä¸æ€»ç»“

### ç”¨æˆ·ä½“éªŒçš„æ ¸å¿ƒä»·å€¼

1. **ä»¥ç”¨æˆ·ä¸ºä¸­å¿ƒ**
   - æ·±å…¥ç†è§£ç”¨æˆ·éœ€æ±‚å’Œç—›ç‚¹
   - è®¾è®¡ç¬¦åˆç”¨æˆ·å¿ƒç†æ¨¡å‹çš„ç•Œé¢
   - æŒç»­æ”¶é›†å’Œåˆ†æç”¨æˆ·åé¦ˆ
   - è¿­ä»£ä¼˜åŒ–ç”¨æˆ·ä½“éªŒ

2. **ç®€å•æ˜“ç”¨**
   - å¤æ‚çš„æŠ€æœ¯åº”è¯¥éšè—åœ¨ç®€å•çš„ç•Œé¢åé¢
   - ç”¨æˆ·ä¸éœ€è¦ç†è§£åŒºå—é“¾æŠ€æœ¯ç»†èŠ‚
   - æ“ä½œæµç¨‹åº”è¯¥ç›´è§‚è‡ªç„¶
   - å‡å°‘ç”¨æˆ·çš„è®¤çŸ¥è´Ÿæ‹…

3. **å¯è®¿é—®æ€§**
   - æ”¯æŒä¸åŒèƒ½åŠ›çš„ç”¨æˆ·
   - å¤šè¯­è¨€å’Œæ–‡åŒ–é€‚åº”
   - å“åº”å¼è®¾è®¡é€‚é…ä¸åŒè®¾å¤‡
   - æ— éšœç¢åŠŸèƒ½æ”¯æŒ

### å‰ç«¯äº¤äº’è®¾è®¡è¦ç‚¹

1. **çŠ¶æ€ç®¡ç†**
   - æ¸…æ™°çš„åŠ è½½çŠ¶æ€æŒ‡ç¤º
   - é”™è¯¯çŠ¶æ€çš„å‹å¥½æç¤º
   - æˆåŠŸçŠ¶æ€çš„åŠæ—¶åé¦ˆ
   - ç©ºçŠ¶æ€çš„å¼•å¯¼è®¾è®¡

2. **æ•°æ®å±•ç¤º**
   - åˆ†é¡µå’Œè™šæ‹Ÿæ»šåŠ¨å¤„ç†å¤§é‡æ•°æ®
   - æœç´¢å’Œè¿‡æ»¤åŠŸèƒ½
   - æ’åºå’Œåˆ†ç»„é€‰é¡¹
   - æ•°æ®å¯è§†åŒ–

3. **äº¤äº’åé¦ˆ**
   - å¾®äº¤äº’å¢å¼ºç”¨æˆ·ä½“éªŒ
   - åŠ¨ç”»è¿‡æ¸¡è‡ªç„¶æµç•…
   - è§¦è§‰åé¦ˆï¼ˆç§»åŠ¨ç«¯ï¼‰
   - éŸ³æ•ˆæç¤ºï¼ˆå¯é€‰ï¼‰

### æ™ºèƒ½åˆçº¦ä¸å‰ç«¯çš„åä½œ

1. **æ•°æ®ç»“æ„è®¾è®¡**
   - è€ƒè™‘å‰ç«¯å±•ç¤ºéœ€æ±‚
   - æ”¯æŒæ‰¹é‡æŸ¥è¯¢å‡å°‘è¯·æ±‚æ¬¡æ•°
   - æä¾›åˆ†é¡µå’Œè¿‡æ»¤æ¥å£
   - ä¼˜åŒ–Gasæ¶ˆè€—

2. **äº‹ä»¶è®¾è®¡**
   - æä¾›ä¸°å¯Œçš„äº‹ä»¶ä¿¡æ¯
   - æ”¯æŒå®æ—¶æ•°æ®æ›´æ–°
   - ä¾¿äºå‰ç«¯çŠ¶æ€åŒæ­¥
   - æ”¯æŒç¦»çº¿æ•°æ®æ¢å¤

3. **é”™è¯¯å¤„ç†**
   - æä¾›ç”¨æˆ·å‹å¥½çš„é”™è¯¯ä¿¡æ¯
   - åŒºåˆ†ä¸åŒç±»å‹çš„é”™è¯¯
   - æä¾›è§£å†³å»ºè®®
   - æ”¯æŒé”™è¯¯æ¢å¤

### å®è·µå»ºè®®

1. **ç”¨æˆ·ç ”ç©¶**
   - å®šæœŸè¿›è¡Œç”¨æˆ·è®¿è°ˆ
   - åˆ†æç”¨æˆ·è¡Œä¸ºæ•°æ®
   - A/Bæµ‹è¯•ä¸åŒè®¾è®¡æ–¹æ¡ˆ
   - å»ºç«‹ç”¨æˆ·åé¦ˆæ¸ é“

2. **è®¾è®¡ç³»ç»Ÿ**
   - å»ºç«‹ç»Ÿä¸€çš„è®¾è®¡è¯­è¨€
   - ç»„ä»¶åŒ–è®¾è®¡å’Œå¼€å‘
   - è®¾è®¡è§„èŒƒæ–‡æ¡£åŒ–
   - è·¨å¹³å°ä¸€è‡´æ€§

3. **æ€§èƒ½ç›‘æ§**
   - ç›‘æ§é¡µé¢åŠ è½½æ—¶é—´
   - è·Ÿè¸ªç”¨æˆ·æ“ä½œè·¯å¾„
   - åˆ†æç”¨æˆ·æµå¤±ç‚¹
   - ä¼˜åŒ–å…³é”®ç”¨æˆ·è·¯å¾„

### æœªæ¥å‘å±•è¶‹åŠ¿

1. **æ™ºèƒ½åŒ–ä½“éªŒ**
   - AIé©±åŠ¨çš„ä¸ªæ€§åŒ–æ¨è
   - æ™ºèƒ½åŠ©æ‰‹å’ŒèŠå¤©æœºå™¨äºº
   - é¢„æµ‹æ€§ç”¨æˆ·ç•Œé¢
   - è‡ªé€‚åº”ç•Œé¢å¸ƒå±€

2. **æ²‰æµ¸å¼ä½“éªŒ**
   - VR/ARç•Œé¢è®¾è®¡
   - 3Däº¤äº’æ¨¡å¼
   - æ‰‹åŠ¿å’Œè¯­éŸ³æ§åˆ¶
   - å¤šæ„Ÿå®˜ä½“éªŒè®¾è®¡

3. **è·¨å¹³å°ä½“éªŒ**
   - ç»Ÿä¸€çš„å¤šè®¾å¤‡ä½“éªŒ
   - äº‘ç«¯çŠ¶æ€åŒæ­¥
   - è·¨åº”ç”¨æ•°æ®å…±äº«
   - æ— ç¼åˆ‡æ¢ä½“éªŒ

é€šè¿‡ä¸“æ³¨äºç”¨æˆ·ä½“éªŒå’Œç•Œé¢è®¾è®¡ï¼Œæˆ‘ä»¬å¯ä»¥è®©å¤æ‚çš„åŒºå—é“¾æŠ€æœ¯å˜å¾—æ›´åŠ äº²æ°‘å’Œæ˜“ç”¨ã€‚å¥½çš„ç”¨æˆ·ä½“éªŒä¸ä»…èƒ½æé«˜ç”¨æˆ·æ»¡æ„åº¦ï¼Œè¿˜èƒ½æ¨åŠ¨åŒºå—é“¾æŠ€æœ¯çš„æ™®åŠå’Œåº”ç”¨ã€‚åœ¨è®¾è®¡è¿‡ç¨‹ä¸­ï¼Œæˆ‘ä»¬è¦å§‹ç»ˆç«™åœ¨ç”¨æˆ·çš„è§’åº¦æ€è€ƒé—®é¢˜ï¼Œç”¨åŒç†å¿ƒå»ç†è§£ç”¨æˆ·çš„éœ€æ±‚å’Œå›°éš¾ï¼Œåˆ›é€ å‡ºçœŸæ­£æœ‰ä»·å€¼çš„äº§å“ä½“éªŒã€‚