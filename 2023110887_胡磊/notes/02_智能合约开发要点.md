# æ™ºèƒ½åˆçº¦å¼€å‘è¦ç‚¹ - GameFiä¸NFTç”Ÿæ€

> **å­¦ä¹ è€…**: èƒ¡ç£Š  
> **å­¦ä¹ ç‰¹è‰²**: æ³¨é‡æ¸¸æˆåŒ–å’ŒNFTåº”ç”¨  
> **ä»£ç é£æ ¼**: åˆ›æ–°çš„æ¸¸æˆæœºåˆ¶å®ç°  
> **ç¬”è®°é‡ç‚¹**: GameFiä¸NFTç”Ÿæ€  
> **åˆ›å»ºæ—¶é—´**: 2024å¹´

---

## ğŸ® GameFiåŸºç¡€æ¶æ„

### æ¸¸æˆèµ„äº§ä»£å¸åŒ–

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/utils/Counters.sol";

// æ¸¸æˆNFTåˆçº¦
contract GameAssetNFT is ERC721, ERC721Enumerable, ERC721URIStorage, Ownable, ReentrancyGuard {
    using Counters for Counters.Counter;
    
    Counters.Counter private _tokenIdCounter;
    
    // èµ„äº§ç±»å‹æšä¸¾
    enum AssetType { Character, Weapon, Armor, Consumable, Land, Building }
    
    // ç¨€æœ‰åº¦æšä¸¾
    enum Rarity { Common, Uncommon, Rare, Epic, Legendary, Mythic }
    
    // æ¸¸æˆèµ„äº§å±æ€§
    struct GameAsset {
        uint256 tokenId;
        AssetType assetType;
        Rarity rarity;
        uint256 level;
        uint256 experience;
        uint256 attack;
        uint256 defense;
        uint256 speed;
        uint256 durability;
        uint256 maxDurability;
        bool isEquipped;
        address currentOwner;
        uint256 createdAt;
        uint256 lastUsed;
        string metadata;
    }
    
    // å‡çº§é…ç½®
    struct UpgradeConfig {
        uint256 baseExpRequired;
        uint256 expMultiplier;
        uint256 maxLevel;
        uint256 upgradeCost;
    }
    
    mapping(uint256 => GameAsset) public gameAssets;
    mapping(AssetType => UpgradeConfig) public upgradeConfigs;
    mapping(address => uint256[]) public playerAssets;
    mapping(uint256 => bool) public isMarketplaceListed;
    
    // æ¸¸æˆä»£å¸æ¥å£
    IERC20 public gameToken;
    
    event AssetMinted(
        uint256 indexed tokenId,
        address indexed to,
        AssetType assetType,
        Rarity rarity
    );
    
    event AssetUpgraded(
        uint256 indexed tokenId,
        uint256 newLevel,
        uint256 newAttack,
        uint256 newDefense
    );
    
    event AssetUsed(
        uint256 indexed tokenId,
        address indexed user,
        uint256 durabilityLoss
    );
    
    event AssetRepaired(
        uint256 indexed tokenId,
        uint256 newDurability,
        uint256 repairCost
    );
    
    constructor(
        string memory name,
        string memory symbol,
        address _gameToken
    ) ERC721(name, symbol) {
        gameToken = IERC20(_gameToken);
        
        // åˆå§‹åŒ–å‡çº§é…ç½®
        _initializeUpgradeConfigs();
    }
    
    // åˆå§‹åŒ–å‡çº§é…ç½®
    function _initializeUpgradeConfigs() internal {
        upgradeConfigs[AssetType.Character] = UpgradeConfig(100, 150, 100, 50);
        upgradeConfigs[AssetType.Weapon] = UpgradeConfig(80, 120, 50, 30);
        upgradeConfigs[AssetType.Armor] = UpgradeConfig(80, 120, 50, 30);
        upgradeConfigs[AssetType.Consumable] = UpgradeConfig(0, 0, 1, 0);
        upgradeConfigs[AssetType.Land] = UpgradeConfig(200, 200, 20, 100);
        upgradeConfigs[AssetType.Building] = UpgradeConfig(150, 180, 30, 80);
    }
    
    // é“¸é€ æ¸¸æˆèµ„äº§
    function mintGameAsset(
        address to,
        AssetType assetType,
        Rarity rarity,
        string memory tokenURI,
        string memory metadata
    ) external onlyOwner returns (uint256) {
        uint256 tokenId = _tokenIdCounter.current();
        _tokenIdCounter.increment();
        
        _safeMint(to, tokenId);
        _setTokenURI(tokenId, tokenURI);
        
        // æ ¹æ®ç¨€æœ‰åº¦è®¾ç½®åŸºç¡€å±æ€§
        (uint256 baseAttack, uint256 baseDefense, uint256 baseSpeed, uint256 baseDurability) = 
            _getBaseStats(assetType, rarity);
        
        gameAssets[tokenId] = GameAsset({
            tokenId: tokenId,
            assetType: assetType,
            rarity: rarity,
            level: 1,
            experience: 0,
            attack: baseAttack,
            defense: baseDefense,
            speed: baseSpeed,
            durability: baseDurability,
            maxDurability: baseDurability,
            isEquipped: false,
            currentOwner: to,
            createdAt: block.timestamp,
            lastUsed: 0,
            metadata: metadata
        });
        
        playerAssets[to].push(tokenId);
        
        emit AssetMinted(tokenId, to, assetType, rarity);
        return tokenId;
    }
    
    // è·å–åŸºç¡€å±æ€§
    function _getBaseStats(AssetType assetType, Rarity rarity) 
        internal pure returns (uint256, uint256, uint256, uint256) {
        uint256 rarityMultiplier = uint256(rarity) + 1;
        
        if (assetType == AssetType.Character) {
            return (
                50 * rarityMultiplier,  // attack
                50 * rarityMultiplier,  // defense
                30 * rarityMultiplier,  // speed
                100 * rarityMultiplier  // durability
            );
        } else if (assetType == AssetType.Weapon) {
            return (
                80 * rarityMultiplier,  // attack
                20 * rarityMultiplier,  // defense
                10 * rarityMultiplier,  // speed
                50 * rarityMultiplier   // durability
            );
        } else if (assetType == AssetType.Armor) {
            return (
                10 * rarityMultiplier,  // attack
                80 * rarityMultiplier,  // defense
                5 * rarityMultiplier,   // speed
                60 * rarityMultiplier   // durability
            );
        }
        
        return (10, 10, 10, 20);
    }
    
    // å‡çº§èµ„äº§
    function upgradeAsset(uint256 tokenId) external nonReentrant {
        require(_exists(tokenId), "Asset does not exist");
        require(ownerOf(tokenId) == msg.sender, "Not asset owner");
        
        GameAsset storage asset = gameAssets[tokenId];
        UpgradeConfig memory config = upgradeConfigs[asset.assetType];
        
        require(asset.level < config.maxLevel, "Asset at max level");
        
        uint256 expRequired = config.baseExpRequired * 
            (config.expMultiplier ** (asset.level - 1)) / (100 ** (asset.level - 1));
        
        require(asset.experience >= expRequired, "Insufficient experience");
        
        // æ¶ˆè€—æ¸¸æˆä»£å¸
        uint256 upgradeCost = config.upgradeCost * asset.level;
        gameToken.transferFrom(msg.sender, address(this), upgradeCost);
        
        // å‡çº§å±æ€§
        asset.level++;
        asset.experience -= expRequired;
        
        // å±æ€§æå‡
        uint256 statIncrease = asset.level * uint256(asset.rarity + 1);
        asset.attack += statIncrease;
        asset.defense += statIncrease;
        asset.speed += statIncrease / 2;
        asset.maxDurability += statIncrease;
        asset.durability = asset.maxDurability; // å‡çº§æ—¶ä¿®å¤è€ä¹…åº¦
        
        emit AssetUpgraded(tokenId, asset.level, asset.attack, asset.defense);
    }
    
    // ä½¿ç”¨èµ„äº§ï¼ˆæ¶ˆè€—è€ä¹…åº¦ï¼‰
    function useAsset(uint256 tokenId, uint256 durabilityLoss) external {
        require(_exists(tokenId), "Asset does not exist");
        require(ownerOf(tokenId) == msg.sender, "Not asset owner");
        
        GameAsset storage asset = gameAssets[tokenId];
        require(asset.durability > 0, "Asset is broken");
        
        if (asset.durability > durabilityLoss) {
            asset.durability -= durabilityLoss;
        } else {
            asset.durability = 0;
        }
        
        asset.lastUsed = block.timestamp;
        
        emit AssetUsed(tokenId, msg.sender, durabilityLoss);
    }
    
    // ä¿®å¤èµ„äº§
    function repairAsset(uint256 tokenId) external nonReentrant {
        require(_exists(tokenId), "Asset does not exist");
        require(ownerOf(tokenId) == msg.sender, "Not asset owner");
        
        GameAsset storage asset = gameAssets[tokenId];
        require(asset.durability < asset.maxDurability, "Asset at full durability");
        
        uint256 repairAmount = asset.maxDurability - asset.durability;
        uint256 repairCost = repairAmount * 10; // æ¯ç‚¹è€ä¹…åº¦10ä»£å¸
        
        gameToken.transferFrom(msg.sender, address(this), repairCost);
        
        asset.durability = asset.maxDurability;
        
        emit AssetRepaired(tokenId, asset.durability, repairCost);
    }
    
    // è·å–ç©å®¶èµ„äº§åˆ—è¡¨
    function getPlayerAssets(address player) external view returns (uint256[] memory) {
        return playerAssets[player];
    }
    
    // è·å–èµ„äº§è¯¦ç»†ä¿¡æ¯
    function getAssetDetails(uint256 tokenId) 
        external view returns (GameAsset memory) {
        require(_exists(tokenId), "Asset does not exist");
        return gameAssets[tokenId];
    }
    
    // æ‰¹é‡è·å–èµ„äº§ä¿¡æ¯
    function getAssetsDetails(uint256[] calldata tokenIds) 
        external view returns (GameAsset[] memory) {
        GameAsset[] memory assets = new GameAsset[](tokenIds.length);
        for (uint256 i = 0; i < tokenIds.length; i++) {
            if (_exists(tokenIds[i])) {
                assets[i] = gameAssets[tokenIds[i]];
            }
        }
        return assets;
    }
    
    // è½¬ç§»æ—¶æ›´æ–°æ‰€æœ‰è€…
    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 tokenId,
        uint256 batchSize
    ) internal override(ERC721, ERC721Enumerable) {
        super._beforeTokenTransfer(from, to, tokenId, batchSize);
        
        if (from != address(0) && to != address(0)) {
            gameAssets[tokenId].currentOwner = to;
            
            // æ›´æ–°ç©å®¶èµ„äº§åˆ—è¡¨
            _removeFromPlayerAssets(from, tokenId);
            playerAssets[to].push(tokenId);
        }
    }
    
    // ä»ç©å®¶èµ„äº§åˆ—è¡¨ä¸­ç§»é™¤
    function _removeFromPlayerAssets(address player, uint256 tokenId) internal {
        uint256[] storage assets = playerAssets[player];
        for (uint256 i = 0; i < assets.length; i++) {
            if (assets[i] == tokenId) {
                assets[i] = assets[assets.length - 1];
                assets.pop();
                break;
            }
        }
    }
    
    // é‡å†™å¿…è¦çš„å‡½æ•°
    function _burn(uint256 tokenId) 
        internal override(ERC721, ERC721URIStorage) {
        super._burn(tokenId);
    }
    
    function tokenURI(uint256 tokenId)
        public view override(ERC721, ERC721URIStorage) returns (string memory) {
        return super.tokenURI(tokenId);
    }
    
    function supportsInterface(bytes4 interfaceId)
        public view override(ERC721, ERC721Enumerable) returns (bool) {
        return super.supportsInterface(interfaceId);
    }
}
```

---

## ğŸ† æ¸¸æˆç»æµç³»ç»Ÿ

### ä»£å¸ç»æµæ¨¡å‹

```solidity
// æ¸¸æˆä»£å¸åˆçº¦
contract GameToken is ERC20, Ownable, ReentrancyGuard {
    // ä»£å¸åˆ†é…
    struct TokenAllocation {
        uint256 gameRewards;      // æ¸¸æˆå¥–åŠ±æ± 
        uint256 stakingRewards;   // è´¨æŠ¼å¥–åŠ±æ± 
        uint256 development;      // å¼€å‘å›¢é˜Ÿ
        uint256 marketing;        // å¸‚åœºè¥é”€
        uint256 liquidity;        // æµåŠ¨æ€§æä¾›
        uint256 treasury;         // å›½åº“å‚¨å¤‡
    }
    
    // æŒ–çŸ¿é…ç½®
    struct MiningConfig {
        uint256 baseReward;       // åŸºç¡€å¥–åŠ±
        uint256 difficultyFactor; // éš¾åº¦ç³»æ•°
        uint256 halvingInterval;  // å‡åŠé—´éš”
        uint256 maxSupply;        // æœ€å¤§ä¾›åº”é‡
    }
    
    // ç©å®¶æŒ–çŸ¿ä¿¡æ¯
    struct PlayerMining {
        uint256 totalMined;       // æ€»æŒ–çŸ¿é‡
        uint256 lastMiningTime;   // æœ€åæŒ–çŸ¿æ—¶é—´
        uint256 miningPower;      // æŒ–çŸ¿ç®—åŠ›
        uint256 consecutiveDays;  // è¿ç»­æŒ–çŸ¿å¤©æ•°
        bool isActive;            // æ˜¯å¦æ´»è·ƒ
    }
    
    TokenAllocation public allocation;
    MiningConfig public miningConfig;
    
    mapping(address => PlayerMining) public playerMining;
    mapping(address => bool) public authorizedMinters;
    
    uint256 public totalMined;
    uint256 public currentEpoch;
    uint256 public epochStartTime;
    
    // æ¸¸æˆåˆçº¦åœ°å€
    address public gameContract;
    address public stakingContract;
    address public marketplaceContract;
    
    event TokensMined(address indexed player, uint256 amount, uint256 miningPower);
    event MiningPowerUpdated(address indexed player, uint256 newPower);
    event EpochChanged(uint256 newEpoch, uint256 newBaseReward);
    
    constructor(
        string memory name,
        string memory symbol,
        uint256 initialSupply
    ) ERC20(name, symbol) {
        // åˆå§‹åŒ–ä»£å¸åˆ†é…
        allocation = TokenAllocation({
            gameRewards: initialSupply * 40 / 100,    // 40%
            stakingRewards: initialSupply * 20 / 100, // 20%
            development: initialSupply * 15 / 100,    // 15%
            marketing: initialSupply * 10 / 100,      // 10%
            liquidity: initialSupply * 10 / 100,      // 10%
            treasury: initialSupply * 5 / 100         // 5%
        });
        
        // åˆå§‹åŒ–æŒ–çŸ¿é…ç½®
        miningConfig = MiningConfig({
            baseReward: 100 * 10**decimals(),
            difficultyFactor: 110, // æ¯æ¬¡å¢åŠ 10%
            halvingInterval: 365 days,
            maxSupply: initialSupply * 2
        });
        
        // é“¸é€ åˆå§‹ä¾›åº”é‡
        _mint(msg.sender, initialSupply);
        
        epochStartTime = block.timestamp;
    }
    
    // è®¾ç½®æˆæƒé“¸å¸è€…
    function setAuthorizedMinter(address minter, bool authorized) external onlyOwner {
        authorizedMinters[minter] = authorized;
    }
    
    // è®¾ç½®æ¸¸æˆåˆçº¦
    function setGameContract(address _gameContract) external onlyOwner {
        gameContract = _gameContract;
        authorizedMinters[_gameContract] = true;
    }
    
    // ç©å®¶æŒ–çŸ¿
    function mine() external nonReentrant {
        PlayerMining storage player = playerMining[msg.sender];
        
        require(
            block.timestamp >= player.lastMiningTime + 1 days,
            "Can only mine once per day"
        );
        
        // æ£€æŸ¥æ˜¯å¦éœ€è¦æ›´æ–°çºªå…ƒ
        _updateEpochIfNeeded();
        
        // è®¡ç®—æŒ–çŸ¿å¥–åŠ±
        uint256 reward = _calculateMiningReward(msg.sender);
        require(totalMined + reward <= miningConfig.maxSupply, "Max supply reached");
        
        // æ›´æ–°ç©å®¶æŒ–çŸ¿ä¿¡æ¯
        if (block.timestamp <= player.lastMiningTime + 2 days) {
            player.consecutiveDays++;
        } else {
            player.consecutiveDays = 1;
        }
        
        player.totalMined += reward;
        player.lastMiningTime = block.timestamp;
        player.isActive = true;
        
        totalMined += reward;
        
        // é“¸é€ ä»£å¸
        _mint(msg.sender, reward);
        
        emit TokensMined(msg.sender, reward, player.miningPower);
    }
    
    // è®¡ç®—æŒ–çŸ¿å¥–åŠ±
    function _calculateMiningReward(address player) internal view returns (uint256) {
        PlayerMining memory playerInfo = playerMining[player];
        
        uint256 baseReward = miningConfig.baseReward;
        
        // æ ¹æ®çºªå…ƒè°ƒæ•´åŸºç¡€å¥–åŠ±ï¼ˆå‡åŠæœºåˆ¶ï¼‰
        uint256 adjustedReward = baseReward / (2 ** currentEpoch);
        
        // æŒ–çŸ¿ç®—åŠ›åŠ æˆ
        uint256 powerBonus = adjustedReward * playerInfo.miningPower / 100;
        
        // è¿ç»­æŒ–çŸ¿åŠ æˆï¼ˆæœ€å¤š50%ï¼‰
        uint256 consecutiveBonus = adjustedReward * 
            (playerInfo.consecutiveDays > 50 ? 50 : playerInfo.consecutiveDays) / 100;
        
        return adjustedReward + powerBonus + consecutiveBonus;
    }
    
    // æ›´æ–°çºªå…ƒ
    function _updateEpochIfNeeded() internal {
        if (block.timestamp >= epochStartTime + miningConfig.halvingInterval) {
            currentEpoch++;
            epochStartTime = block.timestamp;
            
            emit EpochChanged(currentEpoch, miningConfig.baseReward / (2 ** currentEpoch));
        }
    }
    
    // æ›´æ–°æŒ–çŸ¿ç®—åŠ›
    function updateMiningPower(address player, uint256 newPower) external {
        require(
            msg.sender == gameContract || authorizedMinters[msg.sender],
            "Not authorized"
        );
        
        playerMining[player].miningPower = newPower;
        
        emit MiningPowerUpdated(player, newPower);
    }
    
    // æ¸¸æˆå¥–åŠ±é“¸é€ 
    function mintGameReward(address to, uint256 amount) external {
        require(authorizedMinters[msg.sender], "Not authorized minter");
        require(totalSupply() + amount <= miningConfig.maxSupply, "Exceeds max supply");
        
        _mint(to, amount);
    }
    
    // æ‰¹é‡è½¬è´¦ï¼ˆç”¨äºæ‰¹é‡å¥–åŠ±å‘æ”¾ï¼‰
    function batchTransfer(
        address[] calldata recipients,
        uint256[] calldata amounts
    ) external {
        require(recipients.length == amounts.length, "Arrays length mismatch");
        
        for (uint256 i = 0; i < recipients.length; i++) {
            transfer(recipients[i], amounts[i]);
        }
    }
    
    // è·å–ç©å®¶æŒ–çŸ¿ä¿¡æ¯
    function getPlayerMiningInfo(address player) 
        external view returns (PlayerMining memory) {
        return playerMining[player];
    }
    
    // è·å–å½“å‰æŒ–çŸ¿å¥–åŠ±é¢„è§ˆ
    function getMiningRewardPreview(address player) 
        external view returns (uint256) {
        return _calculateMiningReward(player);
    }
    
    // è·å–ä»£å¸åˆ†é…ä¿¡æ¯
    function getTokenAllocation() 
        external view returns (TokenAllocation memory) {
        return allocation;
    }
}
```

---

## ğŸ¯ æ¸¸æˆæœºåˆ¶è®¾è®¡

### æˆ˜æ–—ç³»ç»Ÿ

```solidity
// æˆ˜æ–—ç³»ç»Ÿåˆçº¦
contract BattleSystem is Ownable, ReentrancyGuard {
    // æˆ˜æ–—ç±»å‹
    enum BattleType { PvE, PvP, Raid, Tournament }
    
    // æˆ˜æ–—çŠ¶æ€
    enum BattleStatus { Pending, InProgress, Completed, Cancelled }
    
    // æˆ˜æ–—ç»“æœ
    enum BattleResult { Victory, Defeat, Draw }
    
    // æˆ˜æ–—ä¿¡æ¯
    struct Battle {
        uint256 battleId;
        BattleType battleType;
        BattleStatus status;
        address player1;
        address player2;
        uint256[] player1Assets;
        uint256[] player2Assets;
        uint256 startTime;
        uint256 endTime;
        BattleResult result;
        uint256 rewardAmount;
        uint256 experienceGained;
        string battleLog;
    }
    
    // æˆ˜æ–—é…ç½®
    struct BattleConfig {
        uint256 maxAssetsPerBattle;
        uint256 battleDuration;
        uint256 baseReward;
        uint256 experienceMultiplier;
        uint256 entryFee;
    }
    
    // ç©å®¶æˆ˜æ–—ç»Ÿè®¡
    struct PlayerStats {
        uint256 totalBattles;
        uint256 victories;
        uint256 defeats;
        uint256 draws;
        uint256 totalRewards;
        uint256 totalExperience;
        uint256 currentStreak;
        uint256 maxStreak;
        uint256 rating;
    }
    
    mapping(uint256 => Battle) public battles;
    mapping(BattleType => BattleConfig) public battleConfigs;
    mapping(address => PlayerStats) public playerStats;
    mapping(address => uint256[]) public playerBattleHistory;
    
    uint256 public battleCounter;
    
    GameAssetNFT public gameAssetNFT;
    GameToken public gameToken;
    
    event BattleCreated(
        uint256 indexed battleId,
        BattleType battleType,
        address indexed player1,
        address indexed player2
    );
    
    event BattleCompleted(
        uint256 indexed battleId,
        address indexed winner,
        BattleResult result,
        uint256 rewardAmount
    );
    
    event PlayerStatsUpdated(
        address indexed player,
        uint256 newRating,
        uint256 newStreak
    );
    
    constructor(
        address _gameAssetNFT,
        address _gameToken
    ) {
        gameAssetNFT = GameAssetNFT(_gameAssetNFT);
        gameToken = GameToken(_gameToken);
        
        // åˆå§‹åŒ–æˆ˜æ–—é…ç½®
        _initializeBattleConfigs();
    }
    
    // åˆå§‹åŒ–æˆ˜æ–—é…ç½®
    function _initializeBattleConfigs() internal {
        battleConfigs[BattleType.PvE] = BattleConfig({
            maxAssetsPerBattle: 3,
            battleDuration: 300, // 5åˆ†é’Ÿ
            baseReward: 50 * 10**18,
            experienceMultiplier: 100,
            entryFee: 10 * 10**18
        });
        
        battleConfigs[BattleType.PvP] = BattleConfig({
            maxAssetsPerBattle: 5,
            battleDuration: 600, // 10åˆ†é’Ÿ
            baseReward: 100 * 10**18,
            experienceMultiplier: 150,
            entryFee: 25 * 10**18
        });
        
        battleConfigs[BattleType.Raid] = BattleConfig({
            maxAssetsPerBattle: 10,
            battleDuration: 1800, // 30åˆ†é’Ÿ
            baseReward: 500 * 10**18,
            experienceMultiplier: 300,
            entryFee: 100 * 10**18
        });
        
        battleConfigs[BattleType.Tournament] = BattleConfig({
            maxAssetsPerBattle: 5,
            battleDuration: 900, // 15åˆ†é’Ÿ
            baseReward: 1000 * 10**18,
            experienceMultiplier: 500,
            entryFee: 200 * 10**18
        });
    }
    
    // åˆ›å»ºPvEæˆ˜æ–—
    function createPvEBattle(
        uint256[] calldata assetIds
    ) external nonReentrant returns (uint256) {
        BattleConfig memory config = battleConfigs[BattleType.PvE];
        require(assetIds.length <= config.maxAssetsPerBattle, "Too many assets");
        
        // éªŒè¯èµ„äº§æ‰€æœ‰æƒ
        for (uint256 i = 0; i < assetIds.length; i++) {
            require(
                gameAssetNFT.ownerOf(assetIds[i]) == msg.sender,
                "Not asset owner"
            );
        }
        
        // æ”¶å–å…¥åœºè´¹
        gameToken.transferFrom(msg.sender, address(this), config.entryFee);
        
        uint256 battleId = ++battleCounter;
        
        battles[battleId] = Battle({
            battleId: battleId,
            battleType: BattleType.PvE,
            status: BattleStatus.InProgress,
            player1: msg.sender,
            player2: address(0), // PvEæ²¡æœ‰ç¬¬äºŒä¸ªç©å®¶
            player1Assets: assetIds,
            player2Assets: new uint256[](0),
            startTime: block.timestamp,
            endTime: 0,
            result: BattleResult.Victory, // ä¸´æ—¶è®¾ç½®
            rewardAmount: 0,
            experienceGained: 0,
            battleLog: ""
        });
        
        playerBattleHistory[msg.sender].push(battleId);
        
        emit BattleCreated(battleId, BattleType.PvE, msg.sender, address(0));
        
        // è‡ªåŠ¨å®ŒæˆPvEæˆ˜æ–—
        _completePvEBattle(battleId);
        
        return battleId;
    }
    
    // å®ŒæˆPvEæˆ˜æ–—
    function _completePvEBattle(uint256 battleId) internal {
        Battle storage battle = battles[battleId];
        BattleConfig memory config = battleConfigs[BattleType.PvE];
        
        // è®¡ç®—æˆ˜æ–—åŠ›
        uint256 playerPower = _calculateBattlePower(battle.player1Assets);
        uint256 enemyPower = _generateEnemyPower(playerPower);
        
        // ç¡®å®šæˆ˜æ–—ç»“æœ
        BattleResult result;
        if (playerPower > enemyPower) {
            result = BattleResult.Victory;
        } else if (playerPower < enemyPower) {
            result = BattleResult.Defeat;
        } else {
            result = BattleResult.Draw;
        }
        
        // è®¡ç®—å¥–åŠ±
        uint256 rewardAmount = _calculateReward(config.baseReward, result, playerPower);
        uint256 experienceGained = _calculateExperience(config.experienceMultiplier, result);
        
        // æ›´æ–°æˆ˜æ–—ä¿¡æ¯
        battle.status = BattleStatus.Completed;
        battle.endTime = block.timestamp;
        battle.result = result;
        battle.rewardAmount = rewardAmount;
        battle.experienceGained = experienceGained;
        battle.battleLog = _generateBattleLog(playerPower, enemyPower, result);
        
        // å‘æ”¾å¥–åŠ±
        if (rewardAmount > 0) {
            gameToken.mintGameReward(battle.player1, rewardAmount);
        }
        
        // æ›´æ–°ç©å®¶ç»Ÿè®¡
        _updatePlayerStats(battle.player1, result, rewardAmount, experienceGained);
        
        // ç»™èµ„äº§å¢åŠ ç»éªŒ
        _addExperienceToAssets(battle.player1Assets, experienceGained / battle.player1Assets.length);
        
        emit BattleCompleted(battleId, battle.player1, result, rewardAmount);
    }
    
    // è®¡ç®—æˆ˜æ–—åŠ›
    function _calculateBattlePower(uint256[] memory assetIds) 
        internal view returns (uint256) {
        uint256 totalPower = 0;
        
        for (uint256 i = 0; i < assetIds.length; i++) {
            GameAssetNFT.GameAsset memory asset = gameAssetNFT.getAssetDetails(assetIds[i]);
            
            // åŸºç¡€æˆ˜æ–—åŠ› = (æ”»å‡»åŠ› + é˜²å¾¡åŠ› + é€Ÿåº¦) * ç­‰çº§ * ç¨€æœ‰åº¦åŠ æˆ
            uint256 basePower = asset.attack + asset.defense + asset.speed;
            uint256 levelMultiplier = asset.level;
            uint256 rarityMultiplier = uint256(asset.rarity) + 1;
            
            // è€ä¹…åº¦å½±å“
            uint256 durabilityFactor = asset.durability * 100 / asset.maxDurability;
            
            uint256 assetPower = basePower * levelMultiplier * rarityMultiplier * durabilityFactor / 100;
            totalPower += assetPower;
        }
        
        return totalPower;
    }
    
    // ç”Ÿæˆæ•Œäººæˆ˜æ–—åŠ›
    function _generateEnemyPower(uint256 playerPower) 
        internal view returns (uint256) {
        // æ•Œäººæˆ˜æ–—åŠ›åœ¨ç©å®¶æˆ˜æ–—åŠ›çš„80%-120%ä¹‹é—´éšæœº
        uint256 randomFactor = 80 + (uint256(keccak256(abi.encodePacked(
            block.timestamp, block.difficulty, msg.sender
        ))) % 41); // 0-40çš„éšæœºæ•°ï¼ŒåŠ ä¸Š80å¾—åˆ°80-120
        
        return playerPower * randomFactor / 100;
    }
    
    // è®¡ç®—å¥–åŠ±
    function _calculateReward(
        uint256 baseReward,
        BattleResult result,
        uint256 playerPower
    ) internal pure returns (uint256) {
        if (result == BattleResult.Victory) {
            return baseReward + (playerPower / 1000); // æˆ˜æ–—åŠ›åŠ æˆ
        } else if (result == BattleResult.Draw) {
            return baseReward / 2;
        }
        return 0; // å¤±è´¥æ— å¥–åŠ±
    }
    
    // è®¡ç®—ç»éªŒå€¼
    function _calculateExperience(
        uint256 baseExperience,
        BattleResult result
    ) internal pure returns (uint256) {
        if (result == BattleResult.Victory) {
            return baseExperience;
        } else if (result == BattleResult.Draw) {
            return baseExperience / 2;
        }
        return baseExperience / 4; // å¤±è´¥ä¹Ÿæœ‰å°‘é‡ç»éªŒ
    }
    
    // æ›´æ–°ç©å®¶ç»Ÿè®¡
    function _updatePlayerStats(
        address player,
        BattleResult result,
        uint256 rewardAmount,
        uint256 experienceGained
    ) internal {
        PlayerStats storage stats = playerStats[player];
        
        stats.totalBattles++;
        stats.totalRewards += rewardAmount;
        stats.totalExperience += experienceGained;
        
        if (result == BattleResult.Victory) {
            stats.victories++;
            stats.currentStreak++;
            if (stats.currentStreak > stats.maxStreak) {
                stats.maxStreak = stats.currentStreak;
            }
        } else if (result == BattleResult.Defeat) {
            stats.defeats++;
            stats.currentStreak = 0;
        } else {
            stats.draws++;
        }
        
        // æ›´æ–°è¯„çº§
        stats.rating = _calculateRating(stats);
        
        emit PlayerStatsUpdated(player, stats.rating, stats.currentStreak);
    }
    
    // è®¡ç®—ç©å®¶è¯„çº§
    function _calculateRating(PlayerStats memory stats) 
        internal pure returns (uint256) {
        if (stats.totalBattles == 0) return 1000;
        
        uint256 winRate = stats.victories * 100 / stats.totalBattles;
        uint256 baseRating = 1000 + winRate * 10;
        uint256 streakBonus = stats.maxStreak * 5;
        
        return baseRating + streakBonus;
    }
    
    // ç»™èµ„äº§å¢åŠ ç»éªŒ
    function _addExperienceToAssets(uint256[] memory assetIds, uint256 expPerAsset) internal {
        for (uint256 i = 0; i < assetIds.length; i++) {
            // è¿™é‡Œéœ€è¦è°ƒç”¨GameAssetNFTåˆçº¦çš„æ–¹æ³•æ¥å¢åŠ ç»éªŒ
            // ç®€åŒ–å®ç°ï¼Œå®é™…éœ€è¦åœ¨GameAssetNFTä¸­æ·»åŠ ç›¸åº”æ–¹æ³•
        }
    }
    
    // ç”Ÿæˆæˆ˜æ–—æ—¥å¿—
    function _generateBattleLog(
        uint256 playerPower,
        uint256 enemyPower,
        BattleResult result
    ) internal pure returns (string memory) {
        if (result == BattleResult.Victory) {
            return string(abi.encodePacked(
                "Victory! Player Power: ", 
                Strings.toString(playerPower),
                ", Enemy Power: ",
                Strings.toString(enemyPower)
            ));
        } else if (result == BattleResult.Defeat) {
            return string(abi.encodePacked(
                "Defeat! Player Power: ", 
                Strings.toString(playerPower),
                ", Enemy Power: ",
                Strings.toString(enemyPower)
            ));
        } else {
            return "Draw! Powers were equal.";
        }
    }
    
    // è·å–æˆ˜æ–—ä¿¡æ¯
    function getBattle(uint256 battleId) 
        external view returns (Battle memory) {
        return battles[battleId];
    }
    
    // è·å–ç©å®¶ç»Ÿè®¡
    function getPlayerStats(address player) 
        external view returns (PlayerStats memory) {
        return playerStats[player];
    }
    
    // è·å–ç©å®¶æˆ˜æ–—å†å²
    function getPlayerBattleHistory(address player) 
        external view returns (uint256[] memory) {
        return playerBattleHistory[player];
    }
    
    // è·å–æˆ˜æ–—é…ç½®
    function getBattleConfig(BattleType battleType) 
        external view returns (BattleConfig memory) {
        return battleConfigs[battleType];
    }
}
```

---

## ğŸª NFTå¸‚åœºäº¤æ˜“

### å»ä¸­å¿ƒåŒ–å¸‚åœº

```solidity
// NFTå¸‚åœºåˆçº¦
contract NFTMarketplace is Ownable, ReentrancyGuard {
    // æ‹å–ç±»å‹
    enum AuctionType { FixedPrice, Dutch, English }
    
    // æ‹å–çŠ¶æ€
    enum AuctionStatus { Active, Sold, Cancelled, Expired }
    
    // æ‹å–ä¿¡æ¯
    struct Auction {
        uint256 auctionId;
        uint256 tokenId;
        address seller;
        address highestBidder;
        AuctionType auctionType;
        AuctionStatus status;
        uint256 startPrice;
        uint256 currentPrice;
        uint256 reservePrice;
        uint256 startTime;
        uint256 endTime;
        uint256 priceDecrement; // è·å…°æ‹å–ä»·æ ¼é€’å‡
        uint256 decrementInterval; // ä»·æ ¼é€’å‡é—´éš”
        mapping(address => uint256) bids;
        address[] bidders;
    }
    
    // å¸‚åœºç»Ÿè®¡
    struct MarketStats {
        uint256 totalVolume;
        uint256 totalSales;
        uint256 averagePrice;
        uint256 activeListings;
        uint256 totalListings;
    }
    
    mapping(uint256 => Auction) public auctions;
    mapping(uint256 => uint256) public tokenToAuction; // tokenId => auctionId
    mapping(address => uint256[]) public userAuctions;
    
    uint256 public auctionCounter;
    uint256 public marketFeePercent = 250; // 2.5%
    address public feeRecipient;
    
    MarketStats public marketStats;
    
    GameAssetNFT public gameAssetNFT;
    IERC20 public paymentToken;
    
    event AuctionCreated(
        uint256 indexed auctionId,
        uint256 indexed tokenId,
        address indexed seller,
        AuctionType auctionType,
        uint256 startPrice
    );
    
    event BidPlaced(
        uint256 indexed auctionId,
        address indexed bidder,
        uint256 bidAmount
    );
    
    event AuctionCompleted(
        uint256 indexed auctionId,
        uint256 indexed tokenId,
        address indexed winner,
        uint256 finalPrice
    );
    
    event AuctionCancelled(
        uint256 indexed auctionId,
        uint256 indexed tokenId,
        address indexed seller
    );
    
    constructor(
        address _gameAssetNFT,
        address _paymentToken,
        address _feeRecipient
    ) {
        gameAssetNFT = GameAssetNFT(_gameAssetNFT);
        paymentToken = IERC20(_paymentToken);
        feeRecipient = _feeRecipient;
    }
    
    // åˆ›å»ºå›ºå®šä»·æ ¼æ‹å–
    function createFixedPriceAuction(
        uint256 tokenId,
        uint256 price
    ) external nonReentrant returns (uint256) {
        require(
            gameAssetNFT.ownerOf(tokenId) == msg.sender,
            "Not token owner"
        );
        require(
            gameAssetNFT.getApproved(tokenId) == address(this) ||
            gameAssetNFT.isApprovedForAll(msg.sender, address(this)),
            "Contract not approved"
        );
        require(price > 0, "Price must be greater than 0");
        
        uint256 auctionId = ++auctionCounter;
        
        Auction storage auction = auctions[auctionId];
        auction.auctionId = auctionId;
        auction.tokenId = tokenId;
        auction.seller = msg.sender;
        auction.auctionType = AuctionType.FixedPrice;
        auction.status = AuctionStatus.Active;
        auction.startPrice = price;
        auction.currentPrice = price;
        auction.startTime = block.timestamp;
        auction.endTime = block.timestamp + 30 days; // 30å¤©æœ‰æ•ˆæœŸ
        
        tokenToAuction[tokenId] = auctionId;
        userAuctions[msg.sender].push(auctionId);
        
        marketStats.activeListings++;
        marketStats.totalListings++;
        
        emit AuctionCreated(auctionId, tokenId, msg.sender, AuctionType.FixedPrice, price);
        
        return auctionId;
    }
    
    // åˆ›å»ºè·å…°æ‹å–
    function createDutchAuction(
        uint256 tokenId,
        uint256 startPrice,
        uint256 endPrice,
        uint256 duration
    ) external nonReentrant returns (uint256) {
        require(
            gameAssetNFT.ownerOf(tokenId) == msg.sender,
            "Not token owner"
        );
        require(
            gameAssetNFT.getApproved(tokenId) == address(this) ||
            gameAssetNFT.isApprovedForAll(msg.sender, address(this)),
            "Contract not approved"
        );
        require(startPrice > endPrice, "Start price must be higher than end price");
        require(duration > 0, "Duration must be greater than 0");
        
        uint256 auctionId = ++auctionCounter;
        
        Auction storage auction = auctions[auctionId];
        auction.auctionId = auctionId;
        auction.tokenId = tokenId;
        auction.seller = msg.sender;
        auction.auctionType = AuctionType.Dutch;
        auction.status = AuctionStatus.Active;
        auction.startPrice = startPrice;
        auction.currentPrice = startPrice;
        auction.reservePrice = endPrice;
        auction.startTime = block.timestamp;
        auction.endTime = block.timestamp + duration;
        auction.priceDecrement = (startPrice - endPrice) / (duration / 3600); // æ¯å°æ—¶é€’å‡
        auction.decrementInterval = 3600; // 1å°æ—¶
        
        tokenToAuction[tokenId] = auctionId;
        userAuctions[msg.sender].push(auctionId);
        
        marketStats.activeListings++;
        marketStats.totalListings++;
        
        emit AuctionCreated(auctionId, tokenId, msg.sender, AuctionType.Dutch, startPrice);
        
        return auctionId;
    }
    
    // åˆ›å»ºè‹±å¼æ‹å–
    function createEnglishAuction(
        uint256 tokenId,
        uint256 startPrice,
        uint256 reservePrice,
        uint256 duration
    ) external nonReentrant returns (uint256) {
        require(
            gameAssetNFT.ownerOf(tokenId) == msg.sender,
            "Not token owner"
        );
        require(
            gameAssetNFT.getApproved(tokenId) == address(this) ||
            gameAssetNFT.isApprovedForAll(msg.sender, address(this)),
            "Contract not approved"
        );
        require(reservePrice >= startPrice, "Reserve price too low");
        require(duration > 0, "Duration must be greater than 0");
        
        uint256 auctionId = ++auctionCounter;
        
        Auction storage auction = auctions[auctionId];
        auction.auctionId = auctionId;
        auction.tokenId = tokenId;
        auction.seller = msg.sender;
        auction.auctionType = AuctionType.English;
        auction.status = AuctionStatus.Active;
        auction.startPrice = startPrice;
        auction.currentPrice = startPrice;
        auction.reservePrice = reservePrice;
        auction.startTime = block.timestamp;
        auction.endTime = block.timestamp + duration;
        
        tokenToAuction[tokenId] = auctionId;
        userAuctions[msg.sender].push(auctionId);
        
        marketStats.activeListings++;
        marketStats.totalListings++;
        
        emit AuctionCreated(auctionId, tokenId, msg.sender, AuctionType.English, startPrice);
        
        return auctionId;
    }
    
    // è´­ä¹°å›ºå®šä»·æ ¼å•†å“
    function buyFixedPrice(uint256 auctionId) external nonReentrant {
        Auction storage auction = auctions[auctionId];
        
        require(auction.status == AuctionStatus.Active, "Auction not active");
        require(auction.auctionType == AuctionType.FixedPrice, "Not fixed price auction");
        require(block.timestamp <= auction.endTime, "Auction expired");
        require(msg.sender != auction.seller, "Cannot buy own item");
        
        uint256 price = auction.currentPrice;
        
        // è½¬ç§»ä»£å¸
        paymentToken.transferFrom(msg.sender, address(this), price);
        
        // è®¡ç®—è´¹ç”¨
        uint256 marketFee = price * marketFeePercent / 10000;
        uint256 sellerAmount = price - marketFee;
        
        // åˆ†é…èµ„é‡‘
        paymentToken.transfer(auction.seller, sellerAmount);
        paymentToken.transfer(feeRecipient, marketFee);
        
        // è½¬ç§»NFT
        gameAssetNFT.safeTransferFrom(auction.seller, msg.sender, auction.tokenId);
        
        // æ›´æ–°æ‹å–çŠ¶æ€
        auction.status = AuctionStatus.Sold;
        auction.highestBidder = msg.sender;
        
        // æ›´æ–°å¸‚åœºç»Ÿè®¡
        _updateMarketStats(price);
        
        delete tokenToAuction[auction.tokenId];
        
        emit AuctionCompleted(auctionId, auction.tokenId, msg.sender, price);
    }
    
    // è·å…°æ‹å–è´­ä¹°
    function buyDutchAuction(uint256 auctionId) external nonReentrant {
        Auction storage auction = auctions[auctionId];
        
        require(auction.status == AuctionStatus.Active, "Auction not active");
        require(auction.auctionType == AuctionType.Dutch, "Not Dutch auction");
        require(block.timestamp <= auction.endTime, "Auction expired");
        require(msg.sender != auction.seller, "Cannot buy own item");
        
        // è®¡ç®—å½“å‰ä»·æ ¼
        uint256 currentPrice = _getCurrentDutchPrice(auctionId);
        
        // è½¬ç§»ä»£å¸
        paymentToken.transferFrom(msg.sender, address(this), currentPrice);
        
        // è®¡ç®—è´¹ç”¨
        uint256 marketFee = currentPrice * marketFeePercent / 10000;
        uint256 sellerAmount = currentPrice - marketFee;
        
        // åˆ†é…èµ„é‡‘
        paymentToken.transfer(auction.seller, sellerAmount);
        paymentToken.transfer(feeRecipient, marketFee);
        
        // è½¬ç§»NFT
        gameAssetNFT.safeTransferFrom(auction.seller, msg.sender, auction.tokenId);
        
        // æ›´æ–°æ‹å–çŠ¶æ€
        auction.status = AuctionStatus.Sold;
        auction.highestBidder = msg.sender;
        auction.currentPrice = currentPrice;
        
        // æ›´æ–°å¸‚åœºç»Ÿè®¡
        _updateMarketStats(currentPrice);
        
        delete tokenToAuction[auction.tokenId];
        
        emit AuctionCompleted(auctionId, auction.tokenId, msg.sender, currentPrice);
    }
    
    // è‹±å¼æ‹å–å‡ºä»·
    function bidEnglishAuction(uint256 auctionId, uint256 bidAmount) external nonReentrant {
        Auction storage auction = auctions[auctionId];
        
        require(auction.status == AuctionStatus.Active, "Auction not active");
        require(auction.auctionType == AuctionType.English, "Not English auction");
        require(block.timestamp <= auction.endTime, "Auction expired");
        require(msg.sender != auction.seller, "Cannot bid on own item");
        require(bidAmount > auction.currentPrice, "Bid too low");
        
        // é€€è¿˜ä¹‹å‰çš„å‡ºä»·
        if (auction.highestBidder != address(0)) {
            paymentToken.transfer(auction.highestBidder, auction.currentPrice);
        }
        
        // æ¥æ”¶æ–°å‡ºä»·
        paymentToken.transferFrom(msg.sender, address(this), bidAmount);
        
        // æ›´æ–°æ‹å–ä¿¡æ¯
        auction.highestBidder = msg.sender;
        auction.currentPrice = bidAmount;
        
        // è®°å½•å‡ºä»·
        if (auction.bids[msg.sender] == 0) {
            auction.bidders.push(msg.sender);
        }
        auction.bids[msg.sender] = bidAmount;
        
        // å¦‚æœæ¥è¿‘ç»“æŸæ—¶é—´ï¼Œå»¶é•¿æ‹å–
        if (auction.endTime - block.timestamp < 300) { // 5åˆ†é’Ÿå†…
            auction.endTime += 300; // å»¶é•¿5åˆ†é’Ÿ
        }
        
        emit BidPlaced(auctionId, msg.sender, bidAmount);
    }
    
    // å®Œæˆè‹±å¼æ‹å–
    function finalizeEnglishAuction(uint256 auctionId) external nonReentrant {
        Auction storage auction = auctions[auctionId];
        
        require(auction.status == AuctionStatus.Active, "Auction not active");
        require(auction.auctionType == AuctionType.English, "Not English auction");
        require(block.timestamp > auction.endTime, "Auction still active");
        
        if (auction.highestBidder != address(0) && auction.currentPrice >= auction.reservePrice) {
            // æ‹å–æˆåŠŸ
            uint256 finalPrice = auction.currentPrice;
            
            // è®¡ç®—è´¹ç”¨
            uint256 marketFee = finalPrice * marketFeePercent / 10000;
            uint256 sellerAmount = finalPrice - marketFee;
            
            // åˆ†é…èµ„é‡‘
            paymentToken.transfer(auction.seller, sellerAmount);
            paymentToken.transfer(feeRecipient, marketFee);
            
            // è½¬ç§»NFT
            gameAssetNFT.safeTransferFrom(auction.seller, auction.highestBidder, auction.tokenId);
            
            auction.status = AuctionStatus.Sold;
            
            // æ›´æ–°å¸‚åœºç»Ÿè®¡
            _updateMarketStats(finalPrice);
            
            emit AuctionCompleted(auctionId, auction.tokenId, auction.highestBidder, finalPrice);
        } else {
            // æ‹å–å¤±è´¥ï¼Œé€€è¿˜æœ€é«˜å‡ºä»·
            if (auction.highestBidder != address(0)) {
                paymentToken.transfer(auction.highestBidder, auction.currentPrice);
            }
            
            auction.status = AuctionStatus.Expired;
            marketStats.activeListings--;
        }
        
        delete tokenToAuction[auction.tokenId];
    }
    
    // å–æ¶ˆæ‹å–
    function cancelAuction(uint256 auctionId) external nonReentrant {
        Auction storage auction = auctions[auctionId];
        
        require(
            msg.sender == auction.seller || msg.sender == owner(),
            "Not authorized"
        );
        require(auction.status == AuctionStatus.Active, "Auction not active");
        
        // è‹±å¼æ‹å–éœ€è¦é€€è¿˜å‡ºä»·
        if (auction.auctionType == AuctionType.English && auction.highestBidder != address(0)) {
            paymentToken.transfer(auction.highestBidder, auction.currentPrice);
        }
        
        auction.status = AuctionStatus.Cancelled;
        marketStats.activeListings--;
        
        delete tokenToAuction[auction.tokenId];
        
        emit AuctionCancelled(auctionId, auction.tokenId, auction.seller);
    }
    
    // è·å–è·å…°æ‹å–å½“å‰ä»·æ ¼
    function _getCurrentDutchPrice(uint256 auctionId) internal view returns (uint256) {
        Auction storage auction = auctions[auctionId];
        
        uint256 timeElapsed = block.timestamp - auction.startTime;
        uint256 intervals = timeElapsed / auction.decrementInterval;
        uint256 totalDecrement = intervals * auction.priceDecrement;
        
        if (totalDecrement >= auction.startPrice - auction.reservePrice) {
            return auction.reservePrice;
        }
        
        return auction.startPrice - totalDecrement;
    }
    
    // æ›´æ–°å¸‚åœºç»Ÿè®¡
    function _updateMarketStats(uint256 salePrice) internal {
        marketStats.totalVolume += salePrice;
        marketStats.totalSales++;
        marketStats.activeListings--;
        marketStats.averagePrice = marketStats.totalVolume / marketStats.totalSales;
    }
    
    // è·å–è·å…°æ‹å–å½“å‰ä»·æ ¼ï¼ˆå…¬å¼€å‡½æ•°ï¼‰
    function getCurrentDutchPrice(uint256 auctionId) external view returns (uint256) {
        return _getCurrentDutchPrice(auctionId);
    }
    
    // è·å–æ‹å–ä¿¡æ¯
    function getAuction(uint256 auctionId) 
        external view returns (
            uint256 tokenId,
            address seller,
            address highestBidder,
            AuctionType auctionType,
            AuctionStatus status,
            uint256 currentPrice,
            uint256 startTime,
            uint256 endTime
        ) {
        Auction storage auction = auctions[auctionId];
        return (
            auction.tokenId,
            auction.seller,
            auction.highestBidder,
            auction.auctionType,
            auction.status,
            auction.currentPrice,
            auction.startTime,
            auction.endTime
        );
    }
    
    // è·å–ç”¨æˆ·æ‹å–åˆ—è¡¨
    function getUserAuctions(address user) external view returns (uint256[] memory) {
        return userAuctions[user];
    }
    
    // è·å–å¸‚åœºç»Ÿè®¡
    function getMarketStats() external view returns (MarketStats memory) {
        return marketStats;
    }
    
    // è®¾ç½®å¸‚åœºè´¹ç‡
    function setMarketFeePercent(uint256 _feePercent) external onlyOwner {
        require(_feePercent <= 1000, "Fee too high"); // æœ€é«˜10%
        marketFeePercent = _feePercent;
    }
    
    // è®¾ç½®è´¹ç”¨æ¥æ”¶åœ°å€
    function setFeeRecipient(address _feeRecipient) external onlyOwner {
        feeRecipient = _feeRecipient;
    }
}
```

---

## ğŸ’¡ å­¦ä¹ å¿ƒå¾—ä¸æ€»ç»“

### GameFiæ ¸å¿ƒè¦ç´ 

1. **ç»æµå¾ªç¯è®¾è®¡**
   - ä»£å¸è·å–ä¸æ¶ˆè€—å¹³è¡¡
   - é€šèƒ€ä¸é€šç¼©æœºåˆ¶
   - å¤šå…ƒåŒ–æ”¶ç›Šæ¥æº

2. **æ¸¸æˆæ€§ä¸é‡‘èæ€§ç»“åˆ**
   - æœ‰è¶£çš„æ¸¸æˆæœºåˆ¶
   - åˆç†çš„ç»æµæ¿€åŠ±
   - å¯æŒç»­çš„ç”Ÿæ€ç³»ç»Ÿ

3. **NFTèµ„äº§ä»·å€¼**
   - å®ç”¨æ€§ä»·å€¼
   - ç¨€ç¼ºæ€§è®¾è®¡
   - å‡çº§æˆé•¿æœºåˆ¶

4. **ç¤¾åŒºæ²»ç†**
   - ç©å®¶å‚ä¸å†³ç­–
   - é€æ˜çš„è§„åˆ™åˆ¶å®š
   - å…¬å¹³çš„åˆ©ç›Šåˆ†é…

### æŠ€æœ¯å®ç°è¦ç‚¹

1. **æ™ºèƒ½åˆçº¦å®‰å…¨**ï¼šé‡å…¥æ”»å‡»é˜²æŠ¤ã€æƒé™æ§åˆ¶ã€æ•°æ®éªŒè¯
2. **Gasä¼˜åŒ–**ï¼šæ‰¹é‡æ“ä½œã€å­˜å‚¨ä¼˜åŒ–ã€äº‹ä»¶æ—¥å¿—åˆç†ä½¿ç”¨
3. **å¯æ‰©å±•æ€§**ï¼šæ¨¡å—åŒ–è®¾è®¡ã€å‡çº§æœºåˆ¶ã€è·¨é“¾å…¼å®¹
4. **ç”¨æˆ·ä½“éªŒ**ï¼šç®€åŒ–äº¤äº’æµç¨‹ã€é™ä½ä½¿ç”¨é—¨æ§›ã€å‹å¥½çš„é”™è¯¯æç¤º

### NFTè®¾è®¡åŸåˆ™

1. **å…ƒæ•°æ®æ ‡å‡†åŒ–**
   - éµå¾ªERC-721æ ‡å‡†
   - é“¾ä¸Šä¸é“¾ä¸‹æ•°æ®ç»“åˆ
   - åŠ¨æ€å±æ€§æ›´æ–°æœºåˆ¶

2. **ç¨€æœ‰åº¦ç³»ç»Ÿ**
   - åˆç†çš„ç¨€æœ‰åº¦åˆ†å¸ƒ
   - é€æ˜çš„ç”Ÿæˆç®—æ³•
   - é˜²æ­¢ç¨€æœ‰åº¦é€šèƒ€

3. **å®ç”¨æ€§è®¾è®¡**
   - æ¸¸æˆå†…åŠŸèƒ½ä»·å€¼
   - ç¤¾äº¤å±•ç¤ºä»·å€¼
   - ç»æµæŠ•èµ„ä»·å€¼

### å¸‚åœºæœºåˆ¶ä¼˜åŒ–

1. **å¤šæ ·åŒ–äº¤æ˜“æ–¹å¼**
   - å›ºå®šä»·æ ¼é”€å”®
   - æ‹å–æœºåˆ¶
   - ç§Ÿèµç³»ç»Ÿ

2. **æµåŠ¨æ€§ä¿éšœ**
   - åˆç†çš„æ‰‹ç»­è´¹è®¾ç½®
   - åšå¸‚å•†æ¿€åŠ±
   - äº¤æ˜“æ·±åº¦ç»´æŠ¤

3. **ä»·æ ¼å‘ç°æœºåˆ¶**
   - å†å²äº¤æ˜“æ•°æ®
   - ç¨€æœ‰åº¦è¯„ä¼°
   - å¸‚åœºæƒ…ç»ªæŒ‡æ ‡

### æ¸¸æˆå¹³è¡¡æ€§

1. **ç»æµå¹³è¡¡**
   - ä»£å¸äº§å‡ºä¸æ¶ˆè€—
   - é€šèƒ€æ§åˆ¶æœºåˆ¶
   - ä»·å€¼é”šå®šè®¾è®¡

2. **æ¸¸æˆå¹³è¡¡**
   - æŠ€èƒ½ä¸è£…å¤‡å¹³è¡¡
   - æ–°è€ç©å®¶ä½“éªŒ
   - ç«æŠ€å…¬å¹³æ€§

3. **ç”Ÿæ€å¹³è¡¡**
   - å¼€å‘è€…ä¸ç©å®¶åˆ©ç›Š
   - çŸ­æœŸä¸é•¿æœŸæ”¶ç›Š
   - æŠ•æœºä¸å®ç”¨ä»·å€¼

---

## ğŸš€ æœªæ¥å‘å±•è¶‹åŠ¿

### æŠ€æœ¯åˆ›æ–°æ–¹å‘

```solidity
// AIé©±åŠ¨çš„åŠ¨æ€NFT
contract AIEnhancedNFT is ERC721 {
    struct AIAttributes {
        uint256 learningRate;
        uint256 adaptabilityScore;
        uint256 performanceHistory;
        bytes32 behaviorPattern;
        uint256 evolutionStage;
    }
    
    mapping(uint256 => AIAttributes) public aiAttributes;
    
    // AIå­¦ä¹ æ¥å£
    function updateAIBehavior(
        uint256 tokenId,
        bytes32 newPattern,
        uint256 performanceScore
    ) external {
        AIAttributes storage ai = aiAttributes[tokenId];
        
        // æ›´æ–°è¡Œä¸ºæ¨¡å¼
        ai.behaviorPattern = newPattern;
        ai.performanceHistory = (ai.performanceHistory + performanceScore) / 2;
        
        // æ£€æŸ¥æ˜¯å¦éœ€è¦è¿›åŒ–
        if (ai.performanceHistory > 80 && ai.evolutionStage < 5) {
            ai.evolutionStage++;
            ai.learningRate += 10;
        }
    }
}
```

### è·¨é“¾æ¸¸æˆç”Ÿæ€

```solidity
// è·¨é“¾èµ„äº§æ¡¥æ¥
contract CrossChainGameBridge {
    struct CrossChainAsset {
        uint256 originChainId;
        uint256 originTokenId;
        address originContract;
        uint256 localTokenId;
        bool isLocked;
    }
    
    mapping(uint256 => CrossChainAsset) public bridgedAssets;
    mapping(bytes32 => bool) public processedTransfers;
    
    event AssetBridged(
        uint256 indexed originChainId,
        uint256 indexed originTokenId,
        uint256 indexed localTokenId,
        address recipient
    );
    
    // è·¨é“¾è½¬ç§»èµ„äº§
    function bridgeAsset(
        uint256 originChainId,
        uint256 originTokenId,
        address originContract,
        address recipient,
        bytes calldata proof
    ) external {
        bytes32 transferHash = keccak256(abi.encodePacked(
            originChainId,
            originTokenId,
            originContract,
            recipient
        ));
        
        require(!processedTransfers[transferHash], "Transfer already processed");
        
        // éªŒè¯è·¨é“¾è¯æ˜ï¼ˆç®€åŒ–å®ç°ï¼‰
        require(_verifyProof(proof, transferHash), "Invalid proof");
        
        // é“¸é€ æœ¬åœ°NFT
        uint256 localTokenId = _mintLocalNFT(recipient);
        
        bridgedAssets[localTokenId] = CrossChainAsset({
            originChainId: originChainId,
            originTokenId: originTokenId,
            originContract: originContract,
            localTokenId: localTokenId,
            isLocked: false
        });
        
        processedTransfers[transferHash] = true;
        
        emit AssetBridged(originChainId, originTokenId, localTokenId, recipient);
    }
    
    function _verifyProof(bytes calldata proof, bytes32 hash) 
        internal pure returns (bool) {
        // ç®€åŒ–çš„è¯æ˜éªŒè¯é€»è¾‘
        return true;
    }
    
    function _mintLocalNFT(address recipient) internal returns (uint256) {
        // é“¸é€ æœ¬åœ°NFTçš„é€»è¾‘
        return 1;
    }
}
```

### ç¤¾äº¤æ¸¸æˆåŠŸèƒ½

```solidity
// ç¤¾äº¤æ¸¸æˆåˆçº¦
contract SocialGameFeatures {
    struct Guild {
        string name;
        address leader;
        address[] members;
        uint256 totalPower;
        uint256 treasury;
        mapping(address => bool) isMember;
    }
    
    struct Achievement {
        string name;
        string description;
        uint256 points;
        bool isRare;
        uint256 unlockedBy;
    }
    
    mapping(uint256 => Guild) public guilds;
    mapping(address => uint256) public playerGuild;
    mapping(uint256 => Achievement) public achievements;
    mapping(address => uint256[]) public playerAchievements;
    
    uint256 public guildCounter;
    uint256 public achievementCounter;
    
    event GuildCreated(uint256 indexed guildId, string name, address leader);
    event PlayerJoinedGuild(address indexed player, uint256 indexed guildId);
    event AchievementUnlocked(address indexed player, uint256 indexed achievementId);
    
    // åˆ›å»ºå…¬ä¼š
    function createGuild(string calldata name) external returns (uint256) {
        require(playerGuild[msg.sender] == 0, "Already in a guild");
        
        uint256 guildId = ++guildCounter;
        Guild storage guild = guilds[guildId];
        
        guild.name = name;
        guild.leader = msg.sender;
        guild.members.push(msg.sender);
        guild.isMember[msg.sender] = true;
        
        playerGuild[msg.sender] = guildId;
        
        emit GuildCreated(guildId, name, msg.sender);
        return guildId;
    }
    
    // åŠ å…¥å…¬ä¼š
    function joinGuild(uint256 guildId) external {
        require(playerGuild[msg.sender] == 0, "Already in a guild");
        require(guildId <= guildCounter && guildId > 0, "Guild does not exist");
        
        Guild storage guild = guilds[guildId];
        guild.members.push(msg.sender);
        guild.isMember[msg.sender] = true;
        
        playerGuild[msg.sender] = guildId;
        
        emit PlayerJoinedGuild(msg.sender, guildId);
    }
    
    // è§£é”æˆå°±
    function unlockAchievement(address player, uint256 achievementId) external {
        require(achievementId <= achievementCounter && achievementId > 0, "Achievement does not exist");
        
        // æ£€æŸ¥æ˜¯å¦å·²è§£é”
        uint256[] storage playerAchs = playerAchievements[player];
        for (uint256 i = 0; i < playerAchs.length; i++) {
            require(playerAchs[i] != achievementId, "Achievement already unlocked");
        }
        
        playerAchievements[player].push(achievementId);
        
        emit AchievementUnlocked(player, achievementId);
    }
}
```

---

## ğŸ“š å­¦ä¹ æ€»ç»“

### æ ¸å¿ƒæ”¶è·

1. **GameFiç”Ÿæ€ç†è§£**
   - æ¸¸æˆæ€§ä¸é‡‘èæ€§çš„å¹³è¡¡
   - å¯æŒç»­ç»æµæ¨¡å‹è®¾è®¡
   - ç©å®¶æ¿€åŠ±æœºåˆ¶ä¼˜åŒ–

2. **NFTæŠ€æœ¯åº”ç”¨**
   - åŠ¨æ€å±æ€§ç³»ç»Ÿ
   - ç¨€æœ‰åº¦ç®—æ³•è®¾è®¡
   - è·¨é“¾èµ„äº§äº’æ“ä½œ

3. **æ™ºèƒ½åˆçº¦æ¶æ„**
   - æ¨¡å—åŒ–è®¾è®¡æ€æƒ³
   - å®‰å…¨æ€§æœ€ä½³å®è·µ
   - æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

### å®è·µæ–¹å‘

1. **åˆ›æ–°æ¸¸æˆæœºåˆ¶**ï¼šæ¢ç´¢æ–°çš„æ¸¸æˆç©æ³•ä¸åŒºå—é“¾æŠ€æœ¯ç»“åˆ
2. **ç»æµæ¨¡å‹ä¼˜åŒ–**ï¼šè®¾è®¡æ›´åŠ å¹³è¡¡å’Œå¯æŒç»­çš„ä»£å¸ç»æµ
3. **ç”¨æˆ·ä½“éªŒæå‡**ï¼šé™ä½åŒºå—é“¾æ¸¸æˆçš„ä½¿ç”¨é—¨æ§›
4. **ç¤¾åŒºç”Ÿæ€å»ºè®¾**ï¼šæ„å»ºæ´»è·ƒçš„ç©å®¶ç¤¾åŒºå’Œå¼€å‘è€…ç”Ÿæ€

### æŠ€æœ¯å‘å±•è¶‹åŠ¿

1. **AIä¸åŒºå—é“¾èåˆ**ï¼šæ™ºèƒ½NPCã€åŠ¨æ€æ¸¸æˆå†…å®¹ç”Ÿæˆ
2. **è·¨é“¾äº’æ“ä½œæ€§**ï¼šå¤šé“¾æ¸¸æˆç”Ÿæ€ã€èµ„äº§è‡ªç”±æµåŠ¨
3. **éšç§ä¿æŠ¤æŠ€æœ¯**ï¼šé›¶çŸ¥è¯†è¯æ˜åœ¨æ¸¸æˆä¸­çš„åº”ç”¨
4. **å¯æ‰©å±•æ€§è§£å†³æ–¹æ¡ˆ**ï¼šLayer2ã€ä¾§é“¾æŠ€æœ¯åº”ç”¨

---

**ä¸ªäººæ„Ÿæ‚Ÿ**: GameFiä»£è¡¨äº†æ¸¸æˆäº§ä¸šçš„æ–°æ–¹å‘ï¼Œé€šè¿‡åŒºå—é“¾æŠ€æœ¯èµ‹äºˆç©å®¶çœŸæ­£çš„æ•°å­—èµ„äº§æ‰€æœ‰æƒï¼Œåˆ›é€ äº†å…¨æ–°çš„ä»·å€¼åˆ›é€ å’Œåˆ†é…æ¨¡å¼ã€‚ä½œä¸ºå¼€å‘è€…ï¼Œéœ€è¦åœ¨æŠ€æœ¯åˆ›æ–°å’Œç”¨æˆ·ä½“éªŒä¹‹é—´æ‰¾åˆ°å¹³è¡¡ï¼Œæ„å»ºçœŸæ­£æœ‰ä»·å€¼å’Œå¯æŒç»­çš„æ¸¸æˆç”Ÿæ€ç³»ç»Ÿã€‚

**æœªæ¥è§„åˆ’**: ä¸“æ³¨äºGameFié¢†åŸŸçš„æŠ€æœ¯åˆ›æ–°ï¼Œæ¢ç´¢AIã€VR/ARç­‰å‰æ²¿æŠ€æœ¯ä¸åŒºå—é“¾æ¸¸æˆçš„ç»“åˆï¼Œä¸ºä¸‹ä¸€ä»£æ¸¸æˆä½“éªŒè´¡çŒ®åŠ›é‡ã€‚