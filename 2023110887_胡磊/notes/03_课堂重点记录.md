# 课堂重点记录

**学生**：胡磊  
**学号**：2023110887  
**日期**：2024年9月-12月  
**课程**：区块链智能合约开发  
**学习特色**：游戏化与NFT应用

---

## 学习目标与个人定位

作为一名专注于游戏化与NFT应用的学生，我的学习重点包括：
- 深入理解NFT技术原理和标准协议
- 掌握游戏化机制在区块链中的实现
- 学习数字资产的创建、交易和管理
- 研究GameFi和Play-to-Earn模式
- 探索元宇宙和虚拟世界的技术架构

---

## 第一周：NFT基础与标准协议

### 课堂重点

#### 1. ERC-721 NFT合约实现
```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/Counters.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";

/**
 * @title GameNFT
 * @dev 游戏NFT合约，支持装备、角色、道具等游戏资产
 * @author 胡磊
 */
contract GameNFT is ERC721, ERC721Enumerable, ERC721URIStorage, Ownable, ReentrancyGuard {
    using Counters for Counters.Counter;
    
    // ✅ 状态变量
    
    /// @notice 代币计数器
    Counters.Counter private _tokenIdCounter;
    
    /// @notice NFT元数据映射
    mapping(uint256 => NFTMetadata) public nftMetadata;
    
    /// @notice 稀有度映射
    mapping(uint256 => Rarity) public tokenRarity;
    
    /// @notice 等级映射
    mapping(uint256 => uint256) public tokenLevel;
    
    /// @notice 经验值映射
    mapping(uint256 => uint256) public tokenExperience;
    
    /// @notice 属性映射
    mapping(uint256 => mapping(string => uint256)) public tokenAttributes;
    
    /// @notice 铸造价格
    mapping(Rarity => uint256) public mintPrices;
    
    /// @notice 最大供应量
    mapping(Rarity => uint256) public maxSupply;
    
    /// @notice 当前供应量
    mapping(Rarity => uint256) public currentSupply;
    
    /// @notice 白名单映射
    mapping(address => bool) public whitelist;
    
    /// @notice 每个地址最大铸造数量
    mapping(address => uint256) public mintedCount;
    
    /// @notice 最大每地址铸造数量
    uint256 public maxMintPerAddress = 10;
    
    /// @notice 铸造开启状态
    bool public mintingEnabled = false;
    
    /// @notice 白名单铸造开启状态
    bool public whitelistMintingEnabled = false;
    
    // ✅ 结构体定义
    
    struct NFTMetadata {
        string name;           // NFT名称
        string description;    // NFT描述
        NFTType nftType;      // NFT类型
        Rarity rarity;        // 稀有度
        uint256 createdTime;  // 创建时间
        address creator;      // 创建者
        bool isUpgradeable;   // 是否可升级
        string[] tags;        // 标签
    }
    
    enum NFTType {
        Character,    // 角色
        Weapon,       // 武器
        Armor,        // 护甲
        Accessory,    // 配饰
        Consumable,   // 消耗品
        Land,         // 土地
        Building,     // 建筑
        Vehicle       // 载具
    }
    
    enum Rarity {
        Common,       // 普通 (白色)
        Uncommon,     // 不常见 (绿色)
        Rare,         // 稀有 (蓝色)
        Epic,         // 史诗 (紫色)
        Legendary,    // 传说 (橙色)
        Mythic        // 神话 (红色)
    }
    
    // ✅ 事件定义
    
    event NFTMinted(
        uint256 indexed tokenId,
        address indexed to,
        NFTType nftType,
        Rarity rarity,
        string name
    );
    
    event NFTUpgraded(
        uint256 indexed tokenId,
        uint256 oldLevel,
        uint256 newLevel
    );
    
    event ExperienceGained(
        uint256 indexed tokenId,
        uint256 experience,
        uint256 totalExperience
    );
    
    event AttributeUpdated(
        uint256 indexed tokenId,
        string attributeName,
        uint256 oldValue,
        uint256 newValue
    );
    
    // ✅ 修饰符
    
    modifier onlyTokenOwner(uint256 tokenId) {
        require(ownerOf(tokenId) == msg.sender, "GameNFT: Not token owner");
        _;
    }
    
    modifier validTokenId(uint256 tokenId) {
        require(_exists(tokenId), "GameNFT: Token does not exist");
        _;
    }
    
    modifier mintingActive() {
        require(mintingEnabled, "GameNFT: Minting not enabled");
        _;
    }
    
    modifier whitelistActive() {
        require(whitelistMintingEnabled, "GameNFT: Whitelist minting not enabled");
        _;
    }
    
    // ✅ 构造函数
    
    constructor() ERC721("Game NFT Collection", "GNFT") {
        // 设置铸造价格 (wei)
        mintPrices[Rarity.Common] = 0.01 ether;
        mintPrices[Rarity.Uncommon] = 0.05 ether;
        mintPrices[Rarity.Rare] = 0.1 ether;
        mintPrices[Rarity.Epic] = 0.5 ether;
        mintPrices[Rarity.Legendary] = 1 ether;
        mintPrices[Rarity.Mythic] = 5 ether;
        
        // 设置最大供应量
        maxSupply[Rarity.Common] = 10000;
        maxSupply[Rarity.Uncommon] = 5000;
        maxSupply[Rarity.Rare] = 2000;
        maxSupply[Rarity.Epic] = 500;
        maxSupply[Rarity.Legendary] = 100;
        maxSupply[Rarity.Mythic] = 10;
    }
    
    // ✅ 铸造功能
    
    /// @notice 公开铸造NFT
    /// @param to 接收者地址
    /// @param nftType NFT类型
    /// @param rarity 稀有度
    /// @param name NFT名称
    /// @param description NFT描述
    /// @param tokenURI 元数据URI
    /// @param tags 标签数组
    function mintNFT(
        address to,
        NFTType nftType,
        Rarity rarity,
        string calldata name,
        string calldata description,
        string calldata tokenURI,
        string[] calldata tags
    ) external payable mintingActive nonReentrant returns (uint256) {
        require(to != address(0), "GameNFT: Invalid recipient");
        require(msg.value >= mintPrices[rarity], "GameNFT: Insufficient payment");
        require(currentSupply[rarity] < maxSupply[rarity], "GameNFT: Max supply reached");
        require(mintedCount[msg.sender] < maxMintPerAddress, "GameNFT: Max mint per address reached");
        require(bytes(name).length > 0, "GameNFT: Name required");
        require(tags.length <= 10, "GameNFT: Too many tags");
        
        uint256 tokenId = _tokenIdCounter.current();
        _tokenIdCounter.increment();
        
        // 铸造NFT
        _safeMint(to, tokenId);
        _setTokenURI(tokenId, tokenURI);
        
        // 设置元数据
        nftMetadata[tokenId] = NFTMetadata({
            name: name,
            description: description,
            nftType: nftType,
            rarity: rarity,
            createdTime: block.timestamp,
            creator: msg.sender,
            isUpgradeable: true,
            tags: tags
        });
        
        // 设置基础属性
        tokenRarity[tokenId] = rarity;
        tokenLevel[tokenId] = 1;
        tokenExperience[tokenId] = 0;
        
        // 根据类型和稀有度设置初始属性
        _setInitialAttributes(tokenId, nftType, rarity);
        
        // 更新计数
        currentSupply[rarity]++;
        mintedCount[msg.sender]++;
        
        emit NFTMinted(tokenId, to, nftType, rarity, name);
        
        return tokenId;
    }
    
    /// @notice 白名单铸造
    /// @param to 接收者地址
    /// @param nftType NFT类型
    /// @param rarity 稀有度
    /// @param name NFT名称
    /// @param description NFT描述
    /// @param tokenURI 元数据URI
    /// @param tags 标签数组
    function whitelistMint(
        address to,
        NFTType nftType,
        Rarity rarity,
        string calldata name,
        string calldata description,
        string calldata tokenURI,
        string[] calldata tags
    ) external payable whitelistActive nonReentrant returns (uint256) {
        require(whitelist[msg.sender], "GameNFT: Not whitelisted");
        require(to != address(0), "GameNFT: Invalid recipient");
        require(msg.value >= mintPrices[rarity] / 2, "GameNFT: Insufficient payment"); // 50% 折扣
        require(currentSupply[rarity] < maxSupply[rarity], "GameNFT: Max supply reached");
        require(mintedCount[msg.sender] < maxMintPerAddress, "GameNFT: Max mint per address reached");
        
        uint256 tokenId = _tokenIdCounter.current();
        _tokenIdCounter.increment();
        
        // 铸造NFT
        _safeMint(to, tokenId);
        _setTokenURI(tokenId, tokenURI);
        
        // 设置元数据
        nftMetadata[tokenId] = NFTMetadata({
            name: name,
            description: description,
            nftType: nftType,
            rarity: rarity,
            createdTime: block.timestamp,
            creator: msg.sender,
            isUpgradeable: true,
            tags: tags
        });
        
        // 设置基础属性
        tokenRarity[tokenId] = rarity;
        tokenLevel[tokenId] = 1;
        tokenExperience[tokenId] = 0;
        
        // 根据类型和稀有度设置初始属性
        _setInitialAttributes(tokenId, nftType, rarity);
        
        // 更新计数
        currentSupply[rarity]++;
        mintedCount[msg.sender]++;
        
        emit NFTMinted(tokenId, to, nftType, rarity, name);
        
        return tokenId;
    }
    
    /// @notice 管理员铸造（免费）
    /// @param to 接收者地址
    /// @param nftType NFT类型
    /// @param rarity 稀有度
    /// @param name NFT名称
    /// @param description NFT描述
    /// @param tokenURI 元数据URI
    /// @param tags 标签数组
    function adminMint(
        address to,
        NFTType nftType,
        Rarity rarity,
        string calldata name,
        string calldata description,
        string calldata tokenURI,
        string[] calldata tags
    ) external onlyOwner returns (uint256) {
        require(to != address(0), "GameNFT: Invalid recipient");
        require(currentSupply[rarity] < maxSupply[rarity], "GameNFT: Max supply reached");
        
        uint256 tokenId = _tokenIdCounter.current();
        _tokenIdCounter.increment();
        
        // 铸造NFT
        _safeMint(to, tokenId);
        _setTokenURI(tokenId, tokenURI);
        
        // 设置元数据
        nftMetadata[tokenId] = NFTMetadata({
            name: name,
            description: description,
            nftType: nftType,
            rarity: rarity,
            createdTime: block.timestamp,
            creator: msg.sender,
            isUpgradeable: true,
            tags: tags
        });
        
        // 设置基础属性
        tokenRarity[tokenId] = rarity;
        tokenLevel[tokenId] = 1;
        tokenExperience[tokenId] = 0;
        
        // 根据类型和稀有度设置初始属性
        _setInitialAttributes(tokenId, nftType, rarity);
        
        // 更新计数
        currentSupply[rarity]++;
        
        emit NFTMinted(tokenId, to, nftType, rarity, name);
        
        return tokenId;
    }
    
    // ✅ 游戏化功能
    
    /// @notice 增加经验值
    /// @param tokenId 代币ID
    /// @param experience 经验值
    function gainExperience(
        uint256 tokenId,
        uint256 experience
    ) external validTokenId(tokenId) {
        require(
            ownerOf(tokenId) == msg.sender || owner() == msg.sender,
            "GameNFT: Not authorized"
        );
        
        tokenExperience[tokenId] += experience;
        
        // 检查是否可以升级
        uint256 currentLevel = tokenLevel[tokenId];
        uint256 requiredExp = _getRequiredExperience(currentLevel);
        
        if (tokenExperience[tokenId] >= requiredExp && currentLevel < 100) {
            _levelUp(tokenId);
        }
        
        emit ExperienceGained(tokenId, experience, tokenExperience[tokenId]);
    }
    
    /// @notice 升级NFT
    /// @param tokenId 代币ID
    function _levelUp(uint256 tokenId) internal {
        uint256 oldLevel = tokenLevel[tokenId];
        tokenLevel[tokenId]++;
        
        // 升级时提升属性
        _upgradeAttributes(tokenId, oldLevel, tokenLevel[tokenId]);
        
        emit NFTUpgraded(tokenId, oldLevel, tokenLevel[tokenId]);
    }
    
    /// @notice 手动升级NFT（消耗代币）
    /// @param tokenId 代币ID
    function upgradeNFT(
        uint256 tokenId
    ) external payable onlyTokenOwner(tokenId) validTokenId(tokenId) {
        require(nftMetadata[tokenId].isUpgradeable, "GameNFT: Not upgradeable");
        require(tokenLevel[tokenId] < 100, "GameNFT: Max level reached");
        
        uint256 upgradeCost = _getUpgradeCost(tokenId);
        require(msg.value >= upgradeCost, "GameNFT: Insufficient payment");
        
        uint256 oldLevel = tokenLevel[tokenId];
        tokenLevel[tokenId]++;
        
        // 升级时提升属性
        _upgradeAttributes(tokenId, oldLevel, tokenLevel[tokenId]);
        
        emit NFTUpgraded(tokenId, oldLevel, tokenLevel[tokenId]);
    }
    
    /// @notice 设置NFT属性
    /// @param tokenId 代币ID
    /// @param attributeName 属性名称
    /// @param value 属性值
    function setAttribute(
        uint256 tokenId,
        string calldata attributeName,
        uint256 value
    ) external validTokenId(tokenId) {
        require(
            ownerOf(tokenId) == msg.sender || owner() == msg.sender,
            "GameNFT: Not authorized"
        );
        
        uint256 oldValue = tokenAttributes[tokenId][attributeName];
        tokenAttributes[tokenId][attributeName] = value;
        
        emit AttributeUpdated(tokenId, attributeName, oldValue, value);
    }
    
    // ✅ 辅助函数
    
    /// @notice 设置初始属性
    /// @param tokenId 代币ID
    /// @param nftType NFT类型
    /// @param rarity 稀有度
    function _setInitialAttributes(
        uint256 tokenId,
        NFTType nftType,
        Rarity rarity
    ) internal {
        uint256 baseValue = _getBaseAttributeValue(rarity);
        
        if (nftType == NFTType.Character) {
            tokenAttributes[tokenId]["health"] = baseValue * 10;
            tokenAttributes[tokenId]["attack"] = baseValue * 2;
            tokenAttributes[tokenId]["defense"] = baseValue * 2;
            tokenAttributes[tokenId]["speed"] = baseValue;
            tokenAttributes[tokenId]["mana"] = baseValue * 5;
        } else if (nftType == NFTType.Weapon) {
            tokenAttributes[tokenId]["attack"] = baseValue * 5;
            tokenAttributes[tokenId]["durability"] = baseValue * 3;
            tokenAttributes[tokenId]["critical"] = baseValue;
        } else if (nftType == NFTType.Armor) {
            tokenAttributes[tokenId]["defense"] = baseValue * 5;
            tokenAttributes[tokenId]["durability"] = baseValue * 3;
            tokenAttributes[tokenId]["resistance"] = baseValue;
        }
        // 其他类型的属性设置...
    }
    
    /// @notice 获取基础属性值
    /// @param rarity 稀有度
    /// @return 基础属性值
    function _getBaseAttributeValue(Rarity rarity) internal pure returns (uint256) {
        if (rarity == Rarity.Common) return 10;
        if (rarity == Rarity.Uncommon) return 15;
        if (rarity == Rarity.Rare) return 25;
        if (rarity == Rarity.Epic) return 40;
        if (rarity == Rarity.Legendary) return 60;
        if (rarity == Rarity.Mythic) return 100;
        return 10;
    }
    
    /// @notice 升级属性
    /// @param tokenId 代币ID
    /// @param oldLevel 旧等级
    /// @param newLevel 新等级
    function _upgradeAttributes(
        uint256 tokenId,
        uint256 oldLevel,
        uint256 newLevel
    ) internal {
        uint256 levelDiff = newLevel - oldLevel;
        Rarity rarity = tokenRarity[tokenId];
        uint256 increment = _getBaseAttributeValue(rarity) / 10 * levelDiff;
        
        NFTType nftType = nftMetadata[tokenId].nftType;
        
        if (nftType == NFTType.Character) {
            tokenAttributes[tokenId]["health"] += increment * 10;
            tokenAttributes[tokenId]["attack"] += increment * 2;
            tokenAttributes[tokenId]["defense"] += increment * 2;
            tokenAttributes[tokenId]["speed"] += increment;
            tokenAttributes[tokenId]["mana"] += increment * 5;
        } else if (nftType == NFTType.Weapon) {
            tokenAttributes[tokenId]["attack"] += increment * 5;
            tokenAttributes[tokenId]["durability"] += increment * 3;
            tokenAttributes[tokenId]["critical"] += increment;
        } else if (nftType == NFTType.Armor) {
            tokenAttributes[tokenId]["defense"] += increment * 5;
            tokenAttributes[tokenId]["durability"] += increment * 3;
            tokenAttributes[tokenId]["resistance"] += increment;
        }
    }
    
    /// @notice 获取升级所需经验
    /// @param currentLevel 当前等级
    /// @return 所需经验值
    function _getRequiredExperience(uint256 currentLevel) internal pure returns (uint256) {
        return currentLevel * currentLevel * 100;
    }
    
    /// @notice 获取升级费用
    /// @param tokenId 代币ID
    /// @return 升级费用
    function _getUpgradeCost(uint256 tokenId) internal view returns (uint256) {
        uint256 currentLevel = tokenLevel[tokenId];
        Rarity rarity = tokenRarity[tokenId];
        uint256 baseCost = mintPrices[rarity] / 10;
        return baseCost * currentLevel;
    }
    
    // ✅ 管理功能
    
    /// @notice 设置铸造状态
    /// @param enabled 是否启用
    function setMintingEnabled(bool enabled) external onlyOwner {
        mintingEnabled = enabled;
    }
    
    /// @notice 设置白名单铸造状态
    /// @param enabled 是否启用
    function setWhitelistMintingEnabled(bool enabled) external onlyOwner {
        whitelistMintingEnabled = enabled;
    }
    
    /// @notice 添加白名单用户
    /// @param users 用户地址数组
    function addToWhitelist(address[] calldata users) external onlyOwner {
        for (uint256 i = 0; i < users.length; i++) {
            whitelist[users[i]] = true;
        }
    }
    
    /// @notice 移除白名单用户
    /// @param users 用户地址数组
    function removeFromWhitelist(address[] calldata users) external onlyOwner {
        for (uint256 i = 0; i < users.length; i++) {
            whitelist[users[i]] = false;
        }
    }
    
    /// @notice 设置铸造价格
    /// @param rarity 稀有度
    /// @param price 价格
    function setMintPrice(Rarity rarity, uint256 price) external onlyOwner {
        mintPrices[rarity] = price;
    }
    
    /// @notice 设置最大供应量
    /// @param rarity 稀有度
    /// @param supply 供应量
    function setMaxSupply(Rarity rarity, uint256 supply) external onlyOwner {
        require(supply >= currentSupply[rarity], "GameNFT: Supply less than current");
        maxSupply[rarity] = supply;
    }
    
    /// @notice 提取合约余额
    function withdraw() external onlyOwner {
        uint256 balance = address(this).balance;
        require(balance > 0, "GameNFT: No balance to withdraw");
        
        (bool success, ) = payable(owner()).call{value: balance}("");
        require(success, "GameNFT: Withdrawal failed");
    }
    
    // ✅ 查询功能
    
    /// @notice 获取NFT元数据
    /// @param tokenId 代币ID
    /// @return NFT元数据
    function getNFTMetadata(uint256 tokenId) 
        external 
        view 
        validTokenId(tokenId) 
        returns (NFTMetadata memory) 
    {
        return nftMetadata[tokenId];
    }
    
    /// @notice 获取NFT属性
    /// @param tokenId 代币ID
    /// @param attributeName 属性名称
    /// @return 属性值
    function getAttribute(
        uint256 tokenId,
        string calldata attributeName
    ) external view validTokenId(tokenId) returns (uint256) {
        return tokenAttributes[tokenId][attributeName];
    }
    
    /// @notice 获取NFT等级和经验
    /// @param tokenId 代币ID
    /// @return level 等级
    /// @return experience 经验值
    /// @return requiredExp 升级所需经验
    function getLevelInfo(uint256 tokenId) 
        external 
        view 
        validTokenId(tokenId) 
        returns (uint256 level, uint256 experience, uint256 requiredExp) 
    {
        level = tokenLevel[tokenId];
        experience = tokenExperience[tokenId];
        requiredExp = _getRequiredExperience(level);
    }
    
    /// @notice 获取用户拥有的NFT列表
    /// @param owner 用户地址
    /// @return NFT ID数组
    function getTokensByOwner(address owner) external view returns (uint256[] memory) {
        uint256 tokenCount = balanceOf(owner);
        uint256[] memory tokenIds = new uint256[](tokenCount);
        
        for (uint256 i = 0; i < tokenCount; i++) {
            tokenIds[i] = tokenOfOwnerByIndex(owner, i);
        }
        
        return tokenIds;
    }
    
    /// @notice 获取稀有度统计
    /// @param rarity 稀有度
    /// @return current 当前供应量
    /// @return max 最大供应量
    /// @return price 铸造价格
    function getRarityStats(Rarity rarity) 
        external 
        view 
        returns (uint256 current, uint256 max, uint256 price) 
    {
        return (currentSupply[rarity], maxSupply[rarity], mintPrices[rarity]);
    }
    
    // ✅ 重写必要的函数
    
    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 tokenId,
        uint256 batchSize
    ) internal override(ERC721, ERC721Enumerable) {
        super._beforeTokenTransfer(from, to, tokenId, batchSize);
    }
    
    function _burn(uint256 tokenId) internal override(ERC721, ERC721URIStorage) {
        super._burn(tokenId);
    }
    
    function tokenURI(uint256 tokenId)
        public
        view
        override(ERC721, ERC721URIStorage)
        returns (string memory)
    {
        return super.tokenURI(tokenId);
    }
    
    function supportsInterface(bytes4 interfaceId)
        public
        view
        override(ERC721, ERC721Enumerable)
        returns (bool)
    {
        return super.supportsInterface(interfaceId);
    }
}
```

#### 2. 游戏化奖励系统
```solidity
/**
 * @title GameRewardSystem
 * @dev 游戏化奖励和成就系统
 */
contract GameRewardSystem {
    // ✅ 状态变量
    
    /// @notice 成就映射
    mapping(uint256 => Achievement) public achievements;
    
    /// @notice 用户成就映射
    mapping(address => mapping(uint256 => bool)) public userAchievements;
    
    /// @notice 用户积分
    mapping(address => uint256) public userPoints;
    
    /// @notice 用户等级
    mapping(address => uint256) public userLevel;
    
    /// @notice 每日任务
    mapping(address => mapping(uint256 => bool)) public dailyTaskCompleted;
    
    /// @notice 连续签到天数
    mapping(address => uint256) public consecutiveCheckIns;
    
    /// @notice 最后签到时间
    mapping(address => uint256) public lastCheckInTime;
    
    /// @notice 成就计数器
    uint256 public achievementCounter;
    
    /// @notice NFT合约地址
    address public nftContract;
    
    /// @notice 管理员
    address public admin;
    
    // ✅ 结构体定义
    
    struct Achievement {
        uint256 id;
        string name;
        string description;
        AchievementType achievementType;
        uint256 requirement;
        uint256 points;
        bool isActive;
        string iconURI;
    }
    
    enum AchievementType {
        MintCount,        // 铸造数量
        LevelUp,          // 升级次数
        ConsecutiveCheckIn, // 连续签到
        TotalPoints,      // 总积分
        NFTCollection,    // NFT收集
        Trading,          // 交易次数
        Social            // 社交互动
    }
    
    // ✅ 事件定义
    
    event AchievementUnlocked(
        address indexed user,
        uint256 indexed achievementId,
        string name,
        uint256 points
    );
    
    event PointsEarned(
        address indexed user,
        uint256 points,
        string reason
    );
    
    event LevelUp(
        address indexed user,
        uint256 oldLevel,
        uint256 newLevel
    );
    
    event DailyCheckIn(
        address indexed user,
        uint256 consecutiveDays,
        uint256 points
    );
    
    // ✅ 修饰符
    
    modifier onlyAdmin() {
        require(msg.sender == admin, "Reward: Only admin");
        _;
    }
    
    modifier onlyNFTContract() {
        require(msg.sender == nftContract, "Reward: Only NFT contract");
        _;
    }
    
    // ✅ 构造函数
    
    constructor(address _nftContract) {
        admin = msg.sender;
        nftContract = _nftContract;
        
        // 创建初始成就
        _createInitialAchievements();
    }
    
    // ✅ 核心功能
    
    /// @notice 每日签到
    function dailyCheckIn() external {
        uint256 today = block.timestamp / 86400;
        uint256 lastCheckIn = lastCheckInTime[msg.sender] / 86400;
        
        require(today > lastCheckIn, "Reward: Already checked in today");
        
        // 更新签到信息
        lastCheckInTime[msg.sender] = block.timestamp;
        
        if (today == lastCheckIn + 1) {
            // 连续签到
            consecutiveCheckIns[msg.sender]++;
        } else {
            // 重新开始计数
            consecutiveCheckIns[msg.sender] = 1;
        }
        
        // 计算奖励积分
        uint256 basePoints = 10;
        uint256 bonusPoints = consecutiveCheckIns[msg.sender] / 7 * 5; // 每周额外5分
        uint256 totalPoints = basePoints + bonusPoints;
        
        // 发放奖励
        _awardPoints(msg.sender, totalPoints, "Daily check-in");
        
        // 检查连续签到成就
        _checkAchievement(msg.sender, AchievementType.ConsecutiveCheckIn, consecutiveCheckIns[msg.sender]);
        
        emit DailyCheckIn(msg.sender, consecutiveCheckIns[msg.sender], totalPoints);
    }
    
    /// @notice 完成NFT铸造奖励
    /// @param user 用户地址
    /// @param rarity NFT稀有度
    function onNFTMinted(address user, uint8 rarity) external onlyNFTContract {
        uint256 points = _calculateMintPoints(rarity);
        _awardPoints(user, points, "NFT minted");
        
        // 检查铸造相关成就
        uint256 mintCount = _getUserMintCount(user);
        _checkAchievement(user, AchievementType.MintCount, mintCount);
    }
    
    /// @notice 完成NFT升级奖励
    /// @param user 用户地址
    /// @param tokenId NFT ID
    /// @param newLevel 新等级
    function onNFTUpgraded(address user, uint256 tokenId, uint256 newLevel) external onlyNFTContract {
        uint256 points = newLevel * 5;
        _awardPoints(user, points, "NFT upgraded");
        
        // 检查升级相关成就
        uint256 upgradeCount = _getUserUpgradeCount(user);
        _checkAchievement(user, AchievementType.LevelUp, upgradeCount);
    }
    
    /// @notice 发放积分
    /// @param user 用户地址
    /// @param points 积分数量
    /// @param reason 原因
    function _awardPoints(address user, uint256 points, string memory reason) internal {
        uint256 oldLevel = userLevel[user];
        userPoints[user] += points;
        
        // 检查是否升级
        uint256 newLevel = _calculateUserLevel(userPoints[user]);
        if (newLevel > oldLevel) {
            userLevel[user] = newLevel;
            emit LevelUp(user, oldLevel, newLevel);
        }
        
        // 检查积分相关成就
        _checkAchievement(user, AchievementType.TotalPoints, userPoints[user]);
        
        emit PointsEarned(user, points, reason);
    }
    
    /// @notice 检查成就
    /// @param user 用户地址
    /// @param achievementType 成就类型
    /// @param value 当前值
    function _checkAchievement(
        address user,
        AchievementType achievementType,
        uint256 value
    ) internal {
        for (uint256 i = 0; i < achievementCounter; i++) {
            Achievement memory achievement = achievements[i];
            
            if (
                achievement.isActive &&
                achievement.achievementType == achievementType &&
                value >= achievement.requirement &&
                !userAchievements[user][i]
            ) {
                // 解锁成就
                userAchievements[user][i] = true;
                userPoints[user] += achievement.points;
                
                emit AchievementUnlocked(user, i, achievement.name, achievement.points);
            }
        }
    }
    
    /// @notice 计算用户等级
    /// @param points 积分
    /// @return 等级
    function _calculateUserLevel(uint256 points) internal pure returns (uint256) {
        if (points < 100) return 1;
        if (points < 500) return 2;
        if (points < 1000) return 3;
        if (points < 2500) return 4;
        if (points < 5000) return 5;
        if (points < 10000) return 6;
        if (points < 25000) return 7;
        if (points < 50000) return 8;
        if (points < 100000) return 9;
        return 10; // 最高等级
    }
    
    /// @notice 计算铸造积分
    /// @param rarity 稀有度
    /// @return 积分
    function _calculateMintPoints(uint8 rarity) internal pure returns (uint256) {
        if (rarity == 0) return 10;  // Common
        if (rarity == 1) return 25;  // Uncommon
        if (rarity == 2) return 50;  // Rare
        if (rarity == 3) return 100; // Epic
        if (rarity == 4) return 250; // Legendary
        if (rarity == 5) return 500; // Mythic
        return 10;
    }
    
    /// @notice 获取用户铸造数量（简化实现）
    /// @param user 用户地址
    /// @return 铸造数量
    function _getUserMintCount(address user) internal view returns (uint256) {
        // 实际实现中需要从NFT合约获取
        return userPoints[user] / 50; // 简化计算
    }
    
    /// @notice 获取用户升级次数（简化实现）
    /// @param user 用户地址
    /// @return 升级次数
    function _getUserUpgradeCount(address user) internal view returns (uint256) {
        // 实际实现中需要从NFT合约获取
        return userPoints[user] / 100; // 简化计算
    }
    
    /// @notice 创建初始成就
    function _createInitialAchievements() internal {
        // 铸造成就
        _createAchievement("First Mint", "Mint your first NFT", AchievementType.MintCount, 1, 50, "ipfs://first-mint");
        _createAchievement("Collector", "Mint 10 NFTs", AchievementType.MintCount, 10, 200, "ipfs://collector");
        _createAchievement("Master Collector", "Mint 100 NFTs", AchievementType.MintCount, 100, 1000, "ipfs://master-collector");
        
        // 签到成就
        _createAchievement("Consistent", "Check in for 7 consecutive days", AchievementType.ConsecutiveCheckIn, 7, 100, "ipfs://consistent");
        _createAchievement("Dedicated", "Check in for 30 consecutive days", AchievementType.ConsecutiveCheckIn, 30, 500, "ipfs://dedicated");
        
        // 积分成就
        _createAchievement("Rising Star", "Earn 1000 points", AchievementType.TotalPoints, 1000, 100, "ipfs://rising-star");
        _createAchievement("Champion", "Earn 10000 points", AchievementType.TotalPoints, 10000, 500, "ipfs://champion");
        
        // 升级成就
        _createAchievement("Upgrader", "Upgrade 5 NFTs", AchievementType.LevelUp, 5, 150, "ipfs://upgrader");
        _createAchievement("Master Upgrader", "Upgrade 50 NFTs", AchievementType.LevelUp, 50, 750, "ipfs://master-upgrader");
    }
    
    /// @notice 创建成就
    /// @param name 成就名称
    /// @param description 成就描述
    /// @param achievementType 成就类型
    /// @param requirement 要求
    /// @param points 奖励积分
    /// @param iconURI 图标URI
    function _createAchievement(
        string memory name,
        string memory description,
        AchievementType achievementType,
        uint256 requirement,
        uint256 points,
        string memory iconURI
    ) internal {
        achievements[achievementCounter] = Achievement({
            id: achievementCounter,
            name: name,
            description: description,
            achievementType: achievementType,
            requirement: requirement,
            points: points,
            isActive: true,
            iconURI: iconURI
        });
        
        achievementCounter++;
    }
    
    // ✅ 管理功能
    
    /// @notice 创建新成就
    /// @param name 成就名称
    /// @param description 成就描述
    /// @param achievementType 成就类型
    /// @param requirement 要求
    /// @param points 奖励积分
    /// @param iconURI 图标URI
    function createAchievement(
        string calldata name,
        string calldata description,
        AchievementType achievementType,
        uint256 requirement,
        uint256 points,
        string calldata iconURI
    ) external onlyAdmin {
        _createAchievement(name, description, achievementType, requirement, points, iconURI);
    }
    
    /// @notice 设置成就状态
    /// @param achievementId 成就ID
    /// @param isActive 是否激活
    function setAchievementStatus(uint256 achievementId, bool isActive) external onlyAdmin {
        require(achievementId < achievementCounter, "Reward: Invalid achievement ID");
        achievements[achievementId].isActive = isActive;
    }
    
    /// @notice 手动发放积分
    /// @param user 用户地址
    /// @param points 积分数量
    /// @param reason 原因
    function awardPoints(
        address user,
        uint256 points,
        string calldata reason
    ) external onlyAdmin {
        _awardPoints(user, points, reason);
    }
    
    // ✅ 查询功能
    
    /// @notice 获取用户成就列表
    /// @param user 用户地址
    /// @return 成就ID数组
    function getUserAchievements(address user) external view returns (uint256[] memory) {
        uint256 count = 0;
        
        // 计算已解锁成就数量
        for (uint256 i = 0; i < achievementCounter; i++) {
            if (userAchievements[user][i]) {
                count++;
            }
        }
        
        // 构建结果数组
        uint256[] memory result = new uint256[](count);
        uint256 index = 0;
        
        for (uint256 i = 0; i < achievementCounter; i++) {
            if (userAchievements[user][i]) {
                result[index] = i;
                index++;
            }
        }
        
        return result;
    }
    
    /// @notice 获取用户统计信息
    /// @param user 用户地址
    /// @return points 积分
    /// @return level 等级
    /// @return achievementCount 成就数量
    /// @return consecutiveDays 连续签到天数
    function getUserStats(address user) 
        external 
        view 
        returns (
            uint256 points,
            uint256 level,
            uint256 achievementCount,
            uint256 consecutiveDays
        ) 
    {
        points = userPoints[user];
        level = userLevel[user];
        consecutiveDays = consecutiveCheckIns[user];
        
        // 计算成就数量
        for (uint256 i = 0; i < achievementCounter; i++) {
            if (userAchievements[user][i]) {
                achievementCount++;
            }
        }
    }
    
    /// @notice 获取成就信息
    /// @param achievementId 成就ID
    /// @return 成就信息
    function getAchievement(uint256 achievementId) 
        external 
        view 
        returns (Achievement memory) 
    {
        require(achievementId < achievementCounter, "Reward: Invalid achievement ID");
        return achievements[achievementId];
    }
    
    /// @notice 检查用户是否可以签到
    /// @param user 用户地址
    /// @return 是否可以签到
    function canCheckIn(address user) external view returns (bool) {
        uint256 today = block.timestamp / 86400;
        uint256 lastCheckIn = lastCheckInTime[user] / 86400;
        return today > lastCheckIn;
    }
}
```

### 核心技能掌握
1. **NFT标准实现**：深入理解ERC-721标准和扩展功能
2. **游戏化机制**：等级系统、经验值、属性升级的设计
3. **稀有度系统**：不同稀有度NFT的差异化设计
4. **奖励机制**：积分系统、成就系统、签到奖励
5. **属性系统**：动态属性、升级机制、属性计算

### 项目记录
- 实现了完整的游戏NFT系统，支持多种类型和稀有度
- 设计了复杂的游戏化奖励机制
- 开发了用户成就和等级系统

---

## 第二周：GameFi与Play-to-Earn机制

### 课堂重点

#### 1. GameFi核心合约
```solidity
/**
 * @title GameFiCore
 * @dev GameFi核心合约，实现Play-to-Earn机制
 */
contract GameFiCore {
    // ✅ 状态变量
    
    /// @notice 游戏代币合约
    IERC20 public gameToken;
    
    /// @notice NFT合约
    IERC721 public gameNFT;
    
    /// @notice 玩家信息映射
    mapping(address => Player) public players;
    
    /// @notice 游戏会话映射
    mapping(uint256 => GameSession) public gameSessions;
    
    /// @notice 质押信息映射
    mapping(address => mapping(uint256 => StakeInfo)) public stakes;
    
    /// @notice 奖励池
    uint256 public rewardPool;
    
    /// @notice 会话计数器
    uint256 public sessionCounter;
    
    /// @notice 每日奖励限额
    mapping(address => mapping(uint256 => uint256)) public dailyEarnings;
    
    /// @notice 最大每日收益
    uint256 public maxDailyEarnings = 1000 * 10**18; // 1000 tokens
    
    /// @notice 管理员
    address public admin;
    
    // ✅ 结构体定义
    
    struct Player {
        uint256 totalEarnings;     // 总收益
        uint256 gamesPlayed;       // 游戏次数
        uint256 winCount;          // 胜利次数
        uint256 lastPlayTime;     // 最后游戏时间
        uint256 playerLevel;       // 玩家等级
        uint256 experience;        // 经验值
        bool isActive;             // 是否活跃
        PlayerTier tier;           // 玩家等级
    }
    
    struct GameSession {
        uint256 id;
        address player;
        uint256 startTime;
        uint256 endTime;
        uint256 score;
        uint256 reward;
        GameResult result;
        GameMode mode;
        bool claimed;
    }
    
    struct StakeInfo {
        uint256 tokenId;
        uint256 stakedTime;
        uint256 lastClaimTime;
        uint256 accumulatedReward;
        bool isStaked;
    }
    
    enum GameResult {
        Pending,
        Win,
        Loss,
        Draw
    }
    
    enum GameMode {
        Practice,
        Ranked,
        Tournament,
        Challenge
    }
    
    enum PlayerTier {
        Bronze,
        Silver,
        Gold,
        Platinum,
        Diamond
    }
    
    // ✅ 事件定义
    
    event GameStarted(
        uint256 indexed sessionId,
        address indexed player,
        GameMode mode
    );
    
    event GameCompleted(
        uint256 indexed sessionId,
        address indexed player,
        GameResult result,
        uint256 score,
        uint256 reward
    );
    
    event RewardClaimed(
        address indexed player,
        uint256 amount
    );
    
    event NFTStaked(
        address indexed player,
        uint256 indexed tokenId
    );
    
    event NFTUnstaked(
        address indexed player,
        uint256 indexed tokenId,
        uint256 reward
    );
    
    event PlayerLevelUp(
        address indexed player,
        uint256 oldLevel,
        uint256 newLevel,
        PlayerTier newTier
    );
    
    // ✅ 修饰符
    
    modifier onlyAdmin() {
        require(msg.sender == admin, "GameFi: Only admin");
        _;
    }
    
    modifier validSession(uint256 sessionId) {
        require(sessionId < sessionCounter, "GameFi: Invalid session");
        _;
    }
    
    modifier activePlayer() {
        require(players[msg.sender].isActive, "GameFi: Player not active");
        _;
    }
    
    // ✅ 构造函数
    
    constructor(
        address _gameToken,
        address _gameNFT
    ) {
        admin = msg.sender;
        gameToken = IERC20(_gameToken);
        gameNFT = IERC721(_gameNFT);
    }
    
    // ✅ 核心游戏功能
    
    /// @notice 注册玩家
    function registerPlayer() external {
        require(!players[msg.sender].isActive, "GameFi: Already registered");
        
        players[msg.sender] = Player({
            totalEarnings: 0,
            gamesPlayed: 0,
            winCount: 0,
            lastPlayTime: 0,
            playerLevel: 1,
            experience: 0,
            isActive: true,
            tier: PlayerTier.Bronze
        });
    }
    
    /// @notice 开始游戏
    /// @param mode 游戏模式
    function startGame(GameMode mode) external activePlayer returns (uint256) {
        require(_canPlayToday(msg.sender), "GameFi: Daily limit reached");
        
        uint256 sessionId = sessionCounter++;
        
        gameSessions[sessionId] = GameSession({
            id: sessionId,
            player: msg.sender,
            startTime: block.timestamp,
            endTime: 0,
            score: 0,
            reward: 0,
            result: GameResult.Pending,
            mode: mode,
            claimed: false
        });
        
        emit GameStarted(sessionId, msg.sender, mode);
        
        return sessionId;
    }
    
    /// @notice 完成游戏
    /// @param sessionId 会话ID
    /// @param score 得分
    /// @param result 游戏结果
    function completeGame(
        uint256 sessionId,
        uint256 score,
        GameResult result
    ) external validSession(sessionId) {
        GameSession storage session = gameSessions[sessionId];
        require(session.player == msg.sender, "GameFi: Not your session");
        require(session.result == GameResult.Pending, "GameFi: Game already completed");
        
        session.endTime = block.timestamp;
        session.score = score;
        session.result = result;
        
        // 计算奖励
        uint256 reward = _calculateReward(sessionId, score, result, session.mode);
        session.reward = reward;
        
        // 更新玩家统计
        Player storage player = players[msg.sender];
        player.gamesPlayed++;
        player.lastPlayTime = block.timestamp;
        
        if (result == GameResult.Win) {
            player.winCount++;
        }
        
        // 增加经验值
        uint256 expGain = _calculateExperience(score, result, session.mode);
        _addExperience(msg.sender, expGain);
        
        emit GameCompleted(sessionId, msg.sender, result, score, reward);
    }
    
    /// @notice 领取奖励
    /// @param sessionId 会话ID
    function claimReward(uint256 sessionId) external validSession(sessionId) {
        GameSession storage session = gameSessions[sessionId];
        require(session.player == msg.sender, "GameFi: Not your session");
        require(session.result != GameResult.Pending, "GameFi: Game not completed");
        require(!session.claimed, "GameFi: Already claimed");
        require(session.reward > 0, "GameFi: No reward to claim");
        
        // 检查每日限额
        uint256 today = block.timestamp / 86400;
        require(
            dailyEarnings[msg.sender][today] + session.reward <= maxDailyEarnings,
            "GameFi: Daily limit exceeded"
        );
        
        session.claimed = true;
        dailyEarnings[msg.sender][today] += session.reward;
        players[msg.sender].totalEarnings += session.reward;
        
        // 转账奖励
        require(
            gameToken.transfer(msg.sender, session.reward),
            "GameFi: Transfer failed"
        );
        
        emit RewardClaimed(msg.sender, session.reward);
    }
    
    // ✅ NFT质押功能
    
    /// @notice 质押NFT
    /// @param tokenId NFT ID
    function stakeNFT(uint256 tokenId) external activePlayer {
        require(gameNFT.ownerOf(tokenId) == msg.sender, "GameFi: Not NFT owner");
        require(!stakes[msg.sender][tokenId].isStaked, "GameFi: Already staked");
        
        // 转移NFT到合约
        gameNFT.transferFrom(msg.sender, address(this), tokenId);
        
        stakes[msg.sender][tokenId] = StakeInfo({
            tokenId: tokenId,
            stakedTime: block.timestamp,
            lastClaimTime: block.timestamp,
            accumulatedReward: 0,
            isStaked: true
        });
        
        emit NFTStaked(msg.sender, tokenId);
    }
    
    /// @notice 取消质押NFT
    /// @param tokenId NFT ID
    function unstakeNFT(uint256 tokenId) external {
        StakeInfo storage stake = stakes[msg.sender][tokenId];
        require(stake.isStaked, "GameFi: Not staked");
        
        // 计算质押奖励
        uint256 reward = _calculateStakeReward(msg.sender, tokenId);
        
        // 更新状态
        stake.isStaked = false;
        stake.accumulatedReward += reward;
        
        // 返还NFT
        gameNFT.transferFrom(address(this), msg.sender, tokenId);
        
        // 发放奖励
        if (reward > 0) {
            require(
                gameToken.transfer(msg.sender, reward),
                "GameFi: Transfer failed"
            );
        }
        
        emit NFTUnstaked(msg.sender, tokenId, reward);
    }
    
    /// @notice 领取质押奖励
    /// @param tokenId NFT ID
    function claimStakeReward(uint256 tokenId) external {
        StakeInfo storage stake = stakes[msg.sender][tokenId];
        require(stake.isStaked, "GameFi: Not staked");
        
        uint256 reward = _calculateStakeReward(msg.sender, tokenId);
        require(reward > 0, "GameFi: No reward to claim");
        
        stake.lastClaimTime = block.timestamp;
        stake.accumulatedReward += reward;
        
        require(
            gameToken.transfer(msg.sender, reward),
            "GameFi: Transfer failed"
        );
        
        emit RewardClaimed(msg.sender, reward);
    }
    
    // ✅ 辅助函数
    
    /// @notice 计算游戏奖励
    /// @param sessionId 会话ID
    /// @param score 得分
    /// @param result 游戏结果
    /// @param mode 游戏模式
    /// @return 奖励数量
    function _calculateReward(
        uint256 sessionId,
        uint256 score,
        GameResult result,
        GameMode mode
    ) internal view returns (uint256) {
        if (result == GameResult.Loss) return 0;
        
        uint256 baseReward = 10 * 10**18; // 10 tokens
        uint256 scoreMultiplier = score / 100;
        uint256 modeMultiplier = _getModeMultiplier(mode);
        uint256 tierMultiplier = _getTierMultiplier(players[gameSessions[sessionId].player].tier);
        
        uint256 totalReward = baseReward * (1 + scoreMultiplier) * modeMultiplier * tierMultiplier / 100;
        
        return totalReward;
    }
    
    /// @notice 计算经验值
    /// @param score 得分
    /// @param result 游戏结果
    /// @param mode 游戏模式
    /// @return 经验值
    function _calculateExperience(
        uint256 score,
        GameResult result,
        GameMode mode
    ) internal pure returns (uint256) {
        uint256 baseExp = 50;
        
        if (result == GameResult.Win) {
            baseExp *= 2;
        } else if (result == GameResult.Draw) {
            baseExp = baseExp * 3 / 2;
        }
        
        baseExp += score / 10;
        
        if (mode == GameMode.Ranked) {
            baseExp *= 2;
        } else if (mode == GameMode.Tournament) {
            baseExp *= 3;
        }
        
        return baseExp;
    }
    
    /// @notice 增加经验值
    /// @param player 玩家地址
    /// @param exp 经验值
    function _addExperience(address player, uint256 exp) internal {
        Player storage playerData = players[player];
        uint256 oldLevel = playerData.playerLevel;
        
        playerData.experience += exp;
        
        // 检查升级
        uint256 newLevel = _calculateLevel(playerData.experience);
        if (newLevel > oldLevel) {
            playerData.playerLevel = newLevel;
            PlayerTier newTier = _calculateTier(newLevel);
            playerData.tier = newTier;
            
            emit PlayerLevelUp(player, oldLevel, newLevel, newTier);
        }
    }
    
    /// @notice 计算等级
    /// @param experience 经验值
    /// @return 等级
    function _calculateLevel(uint256 experience) internal pure returns (uint256) {
        return (experience / 1000) + 1;
    }
    
    /// @notice 计算玩家等级
    /// @param level 等级
    /// @return 玩家等级
    function _calculateTier(uint256 level) internal pure returns (PlayerTier) {
        if (level >= 50) return PlayerTier.Diamond;
        if (level >= 30) return PlayerTier.Platinum;
        if (level >= 20) return PlayerTier.Gold;
        if (level >= 10) return PlayerTier.Silver;
        return PlayerTier.Bronze;
    }
    
    /// @notice 获取模式倍数
    /// @param mode 游戏模式
    /// @return 倍数
    function _getModeMultiplier(GameMode mode) internal pure returns (uint256) {
        if (mode == GameMode.Practice) return 50;
        if (mode == GameMode.Ranked) return 150;
        if (mode == GameMode.Tournament) return 200;
        if (mode == GameMode.Challenge) return 300;
        return 100;
    }
    
    /// @notice 获取等级倍数
    /// @param tier 玩家等级
    /// @return 倍数
    function _getTierMultiplier(PlayerTier tier) internal pure returns (uint256) {
        if (tier == PlayerTier.Bronze) return 100;
        if (tier == PlayerTier.Silver) return 110;
        if (tier == PlayerTier.Gold) return 125;
        if (tier == PlayerTier.Platinum) return 150;
        if (tier == PlayerTier.Diamond) return 200;
        return 100;
    }
    
    /// @notice 计算质押奖励
    /// @param player 玩家地址
    /// @param tokenId NFT ID
    /// @return 奖励数量
    function _calculateStakeReward(address player, uint256 tokenId) internal view returns (uint256) {
        StakeInfo storage stake = stakes[player][tokenId];
        if (!stake.isStaked) return 0;
        
        uint256 stakingDuration = block.timestamp - stake.lastClaimTime;
        uint256 dailyReward = 5 * 10**18; // 5 tokens per day
        
        return (stakingDuration * dailyReward) / 86400;
    }
    
    /// @notice 检查今日是否可以游戏
    /// @param player 玩家地址
    /// @return 是否可以游戏
    function _canPlayToday(address player) internal view returns (bool) {
        uint256 today = block.timestamp / 86400;
        return dailyEarnings[player][today] < maxDailyEarnings;
    }
    
    // ✅ 管理功能
    
    /// @notice 设置最大每日收益
    /// @param amount 数量
    function setMaxDailyEarnings(uint256 amount) external onlyAdmin {
        maxDailyEarnings = amount;
    }
    
    /// @notice 添加奖励池
    /// @param amount 数量
    function addRewardPool(uint256 amount) external onlyAdmin {
        require(
            gameToken.transferFrom(msg.sender, address(this), amount),
            "GameFi: Transfer failed"
        );
        rewardPool += amount;
    }
    
    /// @notice 紧急提取
    /// @param amount 数量
    function emergencyWithdraw(uint256 amount) external onlyAdmin {
        require(amount <= rewardPool, "GameFi: Insufficient pool");
        rewardPool -= amount;
        
        require(
            gameToken.transfer(admin, amount),
            "GameFi: Transfer failed"
        );
    }
    
    // ✅ 查询功能
    
    /// @notice 获取玩家信息
    /// @param player 玩家地址
    /// @return 玩家信息
    function getPlayerInfo(address player) external view returns (Player memory) {
        return players[player];
    }
    
    /// @notice 获取游戏会话信息
    /// @param sessionId 会话ID
    /// @return 会话信息
    function getGameSession(uint256 sessionId) external view returns (GameSession memory) {
        return gameSessions[sessionId];
    }
    
    /// @notice 获取质押信息
    /// @param player 玩家地址
    /// @param tokenId NFT ID
    /// @return 质押信息
    function getStakeInfo(address player, uint256 tokenId) external view returns (StakeInfo memory) {
        return stakes[player][tokenId];
    }
    
    /// @notice 获取今日收益
    /// @param player 玩家地址
    /// @return 今日收益
    function getTodayEarnings(address player) external view returns (uint256) {
        uint256 today = block.timestamp / 86400;
        return dailyEarnings[player][today];
    }
    
    /// @notice 获取剩余每日限额
    /// @param player 玩家地址
    /// @return 剩余限额
    function getRemainingDailyLimit(address player) external view returns (uint256) {
        uint256 today = block.timestamp / 86400;
        uint256 earned = dailyEarnings[player][today];
        return earned >= maxDailyEarnings ? 0 : maxDailyEarnings - earned;
    }
}
```

#### 2. 代币经济模型
```solidity
/**
 * @title GameToken
 * @dev 游戏代币合约，支持通胀控制和经济平衡
 */
contract GameToken is ERC20, Ownable {
    // ✅ 状态变量
    
    /// @notice 每日铸造限额
    uint256 public dailyMintLimit = 100000 * 10**18;
    
    /// @notice 每日已铸造数量
    mapping(uint256 => uint256) public dailyMinted;
    
    /// @notice 销毁总量
    uint256 public totalBurned;
    
    /// @notice 铸造者权限
    mapping(address => bool) public minters;
    
    /// @notice 交易费率 (基点)
    uint256 public transferFeeRate = 100; // 1%
    
    /// @notice 费用收集地址
    address public feeCollector;
    
    /// @notice 免费转账白名单
    mapping(address => bool) public feeExempt;
    
    // ✅ 事件定义
    
    event MinterAdded(address indexed minter);
    event MinterRemoved(address indexed minter);
    event TokensBurned(address indexed from, uint256 amount);
    event FeeCollected(address indexed from, address indexed to, uint256 amount);
    
    // ✅ 修饰符
    
    modifier onlyMinter() {
        require(minters[msg.sender], "GameToken: Not a minter");
        _;
    }
    
    // ✅ 构造函数
    
    constructor() ERC20("Game Token", "GAME") {
        feeCollector = msg.sender;
        feeExempt[msg.sender] = true;
        
        // 初始供应量
        _mint(msg.sender, 1000000 * 10**18);
    }
    
    // ✅ 铸造功能
    
    /// @notice 铸造代币
    /// @param to 接收地址
    /// @param amount 数量
    function mint(address to, uint256 amount) external onlyMinter {
        uint256 today = block.timestamp / 86400;
        require(
            dailyMinted[today] + amount <= dailyMintLimit,
            "GameToken: Daily mint limit exceeded"
        );
        
        dailyMinted[today] += amount;
        _mint(to, amount);
    }
    
    /// @notice 销毁代币
    /// @param amount 数量
    function burn(uint256 amount) external {
        _burn(msg.sender, amount);
        totalBurned += amount;
        
        emit TokensBurned(msg.sender, amount);
    }
    
    /// @notice 从指定地址销毁代币
    /// @param from 地址
    /// @param amount 数量
    function burnFrom(address from, uint256 amount) external {
        uint256 currentAllowance = allowance(from, msg.sender);
        require(currentAllowance >= amount, "GameToken: Burn amount exceeds allowance");
        
        _approve(from, msg.sender, currentAllowance - amount);
        _burn(from, amount);
        totalBurned += amount;
        
        emit TokensBurned(from, amount);
    }
    
    // ✅ 转账功能重写
    
    /// @notice 转账（含手续费）
    /// @param to 接收地址
    /// @param amount 数量
    /// @return 是否成功
    function transfer(address to, uint256 amount) public override returns (bool) {
        address owner = _msgSender();
        
        if (feeExempt[owner] || feeExempt[to] || transferFeeRate == 0) {
            _transfer(owner, to, amount);
        } else {
            uint256 fee = (amount * transferFeeRate) / 10000;
            uint256 transferAmount = amount - fee;
            
            _transfer(owner, to, transferAmount);
            _transfer(owner, feeCollector, fee);
            
            emit FeeCollected(owner, feeCollector, fee);
        }
        
        return true;
    }
    
    /// @notice 授权转账（含手续费）
    /// @param from 发送地址
    /// @param to 接收地址
    /// @param amount 数量
    /// @return 是否成功
    function transferFrom(address from, address to, uint256 amount) public override returns (bool) {
        address spender = _msgSender();
        _spendAllowance(from, spender, amount);
        
        if (feeExempt[from] || feeExempt[to] || transferFeeRate == 0) {
            _transfer(from, to, amount);
        } else {
            uint256 fee = (amount * transferFeeRate) / 10000;
            uint256 transferAmount = amount - fee;
            
            _transfer(from, to, transferAmount);
            _transfer(from, feeCollector, fee);
            
            emit FeeCollected(from, feeCollector, fee);
        }
        
        return true;
    }
    
    // ✅ 管理功能
    
    /// @notice 添加铸造者
    /// @param minter 铸造者地址
    function addMinter(address minter) external onlyOwner {
        minters[minter] = true;
        emit MinterAdded(minter);
    }
    
    /// @notice 移除铸造者
    /// @param minter 铸造者地址
    function removeMinter(address minter) external onlyOwner {
        minters[minter] = false;
        emit MinterRemoved(minter);
    }
    
    /// @notice 设置每日铸造限额
    /// @param limit 限额
    function setDailyMintLimit(uint256 limit) external onlyOwner {
        dailyMintLimit = limit;
    }
    
    /// @notice 设置转账费率
    /// @param rate 费率（基点）
    function setTransferFeeRate(uint256 rate) external onlyOwner {
        require(rate <= 1000, "GameToken: Fee rate too high"); // 最高10%
        transferFeeRate = rate;
    }
    
    /// @notice 设置费用收集地址
    /// @param collector 收集地址
    function setFeeCollector(address collector) external onlyOwner {
        require(collector != address(0), "GameToken: Invalid collector");
        feeCollector = collector;
    }
    
    /// @notice 设置免费转账白名单
    /// @param account 账户地址
    /// @param exempt 是否免费
    function setFeeExempt(address account, bool exempt) external onlyOwner {
        feeExempt[account] = exempt;
    }
    
    // ✅ 查询功能
    
    /// @notice 获取今日剩余铸造额度
    /// @return 剩余额度
    function getRemainingMintLimit() external view returns (uint256) {
        uint256 today = block.timestamp / 86400;
        uint256 minted = dailyMinted[today];
        return minted >= dailyMintLimit ? 0 : dailyMintLimit - minted;
    }
    
    /// @notice 获取流通供应量
    /// @return 流通供应量
    function circulatingSupply() external view returns (uint256) {
        return totalSupply() - totalBurned;
    }
    
    /// @notice 计算转账费用
    /// @param amount 转账数量
    /// @return fee 手续费
    /// @return transferAmount 实际转账数量
    function calculateTransferFee(uint256 amount) external view returns (uint256 fee, uint256 transferAmount) {
        if (transferFeeRate == 0) {
            return (0, amount);
        }
        
        fee = (amount * transferFeeRate) / 10000;
        transferAmount = amount - fee;
    }
}
```

### 核心技能掌握
1. **GameFi架构设计**：Play-to-Earn机制的完整实现
2. **代币经济学**：通胀控制、销毁机制、费用模型
3. **质押系统**：NFT质押挖矿和奖励分发
4. **游戏化设计**：等级系统、经验值、玩家分层
5. **经济平衡**：每日限额、奖励计算、防刷机制

### 项目记录
- 开发了完整的GameFi核心系统
- 实现了可持续的Play-to-Earn经济模型
- 设计了多层次的奖励和激励机制

---

## 第三周：元宇宙与虚拟世界技术

### 课堂重点

#### 1. 虚拟土地系统
```solidity
/**
 * @title VirtualLand
 * @dev 虚拟土地NFT合约，支持土地开发和租赁
 */
contract VirtualLand is ERC721, ERC721Enumerable, Ownable {
    using Counters for Counters.Counter;
    
    // ✅ 状态变量
    
    /// @notice 土地计数器
    Counters.Counter private _landIdCounter;
    
    /// @notice 土地信息映射
    mapping(uint256 => LandInfo) public lands;
    
    /// @notice 坐标到土地ID映射
    mapping(int256 => mapping(int256 => uint256)) public coordinateToLandId;
    
    /// @notice 租赁信息映射
    mapping(uint256 => RentalInfo) public rentals;
    
    /// @notice 建筑信息映射
    mapping(uint256 => Building[]) public landBuildings;
    
    /// @notice 土地价格映射
    mapping(LandType => uint256) public landPrices;
    
    /// @notice 开发费用映射
    mapping(BuildingType => uint256) public buildingCosts;
    
    /// @notice 游戏代币合约
    IERC20 public gameToken;
    
    /// @notice 世界大小
    int256 public constant WORLD_SIZE = 1000;
    
    // ✅ 结构体定义
    
    struct LandInfo {
        uint256 id;
        int256 x;
        int256 y;
        LandType landType;
        uint256 size;
        address owner;
        uint256 purchaseTime;
        uint256 lastDevelopmentTime;
        bool isForSale;
        uint256 salePrice;
        bool isForRent;
        uint256 rentPrice;
        uint256 developmentLevel;
        string metadataURI;
    }
    
    struct RentalInfo {
        uint256 landId;
        address tenant;
        uint256 startTime;
        uint256 endTime;
        uint256 rentAmount;
        bool isActive;
        bool isPaid;
    }
    
    struct Building {
        uint256 id;
        BuildingType buildingType;
        uint256 level;
        uint256 constructionTime;
        bool isActive;
        uint256 maintenanceCost;
        uint256 income;
        string name;
    }
    
    enum LandType {
        Residential,  // 住宅
        Commercial,   // 商业
        Industrial,   // 工业
        Entertainment, // 娱乐
        Special       // 特殊
    }
    
    enum BuildingType {
        House,        // 房屋
        Shop,         // 商店
        Factory,      // 工厂
        Casino,       // 赌场
        Museum,       // 博物馆
        Park,         // 公园
        Stadium       // 体育场
    }
    
    // ✅ 事件定义
    
    event LandMinted(
        uint256 indexed landId,
        address indexed owner,
        int256 x,
        int256 y,
        LandType landType
    );
    
    event LandDeveloped(
        uint256 indexed landId,
        uint256 oldLevel,
        uint256 newLevel
    );
    
    event BuildingConstructed(
        uint256 indexed landId,
        uint256 indexed buildingId,
        BuildingType buildingType
    );
    
    event LandRented(
        uint256 indexed landId,
        address indexed tenant,
        uint256 rentAmount,
        uint256 duration
    );
    
    event LandSold(
        uint256 indexed landId,
        address indexed from,
        address indexed to,
        uint256 price
    );
    
    // ✅ 修饰符
    
    modifier validCoordinate(int256 x, int256 y) {
        require(
            x >= -WORLD_SIZE && x <= WORLD_SIZE && y >= -WORLD_SIZE && y <= WORLD_SIZE,
            "VirtualLand: Invalid coordinates"
        );
        _;
    }
    
    modifier landOwner(uint256 landId) {
        require(ownerOf(landId) == msg.sender, "VirtualLand: Not land owner");
        _;
    }
    
    modifier validLand(uint256 landId) {
        require(_exists(landId), "VirtualLand: Land does not exist");
        _;
    }
    
    // ✅ 构造函数
    
    constructor(address _gameToken) ERC721("Virtual Land", "VLAND") {
        gameToken = IERC20(_gameToken);
        
        // 设置土地价格
        landPrices[LandType.Residential] = 1000 * 10**18;
        landPrices[LandType.Commercial] = 2000 * 10**18;
        landPrices[LandType.Industrial] = 1500 * 10**18;
        landPrices[LandType.Entertainment] = 3000 * 10**18;
        landPrices[LandType.Special] = 5000 * 10**18;
        
        // 设置建筑费用
        buildingCosts[BuildingType.House] = 500 * 10**18;
        buildingCosts[BuildingType.Shop] = 1000 * 10**18;
        buildingCosts[BuildingType.Factory] = 2000 * 10**18;
        buildingCosts[BuildingType.Casino] = 5000 * 10**18;
        buildingCosts[BuildingType.Museum] = 3000 * 10**18;
        buildingCosts[BuildingType.Park] = 1500 * 10**18;
        buildingCosts[BuildingType.Stadium] = 10000 * 10**18;
    }
    
    // ✅ 土地铸造功能
    
    /// @notice 购买土地
    /// @param x X坐标
    /// @param y Y坐标
    /// @param landType 土地类型
    /// @param size 土地大小
    /// @param metadataURI 元数据URI
    function purchaseLand(
        int256 x,
        int256 y,
        LandType landType,
        uint256 size,
        string calldata metadataURI
    ) external validCoordinate(x, y) returns (uint256) {
        require(coordinateToLandId[x][y] == 0, "VirtualLand: Land already exists");
        require(size > 0 && size <= 100, "VirtualLand: Invalid size");
        
        uint256 totalCost = landPrices[landType] * size;
        require(
            gameToken.transferFrom(msg.sender, address(this), totalCost),
            "VirtualLand: Payment failed"
        );
        
        uint256 landId = _landIdCounter.current();
        _landIdCounter.increment();
        
        // 铸造土地NFT
        _safeMint(msg.sender, landId);
        _setTokenURI(landId, metadataURI);
        
        // 设置土地信息
        lands[landId] = LandInfo({
            id: landId,
            x: x,
            y: y,
            landType: landType,
            size: size,
            owner: msg.sender,
            purchaseTime: block.timestamp,
            lastDevelopmentTime: 0,
            isForSale: false,
            salePrice: 0,
            isForRent: false,
            rentPrice: 0,
            developmentLevel: 0,
            metadataURI: metadataURI
        });
        
        // 更新坐标映射
        coordinateToLandId[x][y] = landId;
        
        emit LandMinted(landId, msg.sender, x, y, landType);
        
        return landId;
    }
    
    // ✅ 土地开发功能
    
    /// @notice 开发土地
    /// @param landId 土地ID
    function developLand(uint256 landId) external landOwner(landId) validLand(landId) {
        LandInfo storage land = lands[landId];
        require(land.developmentLevel < 10, "VirtualLand: Max development level reached");
        
        uint256 developmentCost = _calculateDevelopmentCost(landId);
        require(
            gameToken.transferFrom(msg.sender, address(this), developmentCost),
            "VirtualLand: Payment failed"
        );
        
        uint256 oldLevel = land.developmentLevel;
        land.developmentLevel++;
        land.lastDevelopmentTime = block.timestamp;
        
        emit LandDeveloped(landId, oldLevel, land.developmentLevel);
    }
    
    /// @notice 建造建筑
    /// @param landId 土地ID
    /// @param buildingType 建筑类型
    /// @param name 建筑名称
    function constructBuilding(
        uint256 landId,
        BuildingType buildingType,
        string calldata name
    ) external landOwner(landId) validLand(landId) returns (uint256) {
        LandInfo storage land = lands[landId];
        require(land.developmentLevel >= 1, "VirtualLand: Land not developed");
        require(landBuildings[landId].length < land.size, "VirtualLand: No space for building");
        
        // 检查建筑类型是否适合土地类型
        require(_isBuildingCompatible(land.landType, buildingType), "VirtualLand: Incompatible building type");
        
        uint256 cost = buildingCosts[buildingType];
        require(
            gameToken.transferFrom(msg.sender, address(this), cost),
            "VirtualLand: Payment failed"
        );
        
        uint256 buildingId = landBuildings[landId].length;
        
        Building memory newBuilding = Building({
            id: buildingId,
            buildingType: buildingType,
            level: 1,
            constructionTime: block.timestamp,
            isActive: true,
            maintenanceCost: cost / 100, // 1% of construction cost
            income: _calculateBuildingIncome(buildingType, 1),
            name: name
        });
        
        landBuildings[landId].push(newBuilding);
        
        emit BuildingConstructed(landId, buildingId, buildingType);
        
        return buildingId;
    }
    
    // ✅ 租赁功能
    
    /// @notice 设置土地出租
    /// @param landId 土地ID
    /// @param rentPrice 租金价格
    function setLandForRent(
        uint256 landId,
        uint256 rentPrice
    ) external landOwner(landId) validLand(landId) {
        require(rentPrice > 0, "VirtualLand: Invalid rent price");
        require(!rentals[landId].isActive, "VirtualLand: Already rented");
        
        LandInfo storage land = lands[landId];
        land.isForRent = true;
        land.rentPrice = rentPrice;
    }
    
    /// @notice 租赁土地
    /// @param landId 土地ID
    /// @param duration 租赁时长（秒）
    function rentLand(
        uint256 landId,
        uint256 duration
    ) external validLand(landId) {
        LandInfo storage land = lands[landId];
        require(land.isForRent, "VirtualLand: Land not for rent");
        require(!rentals[landId].isActive, "VirtualLand: Already rented");
        require(duration >= 86400, "VirtualLand: Minimum 1 day rental");
        require(msg.sender != ownerOf(landId), "VirtualLand: Cannot rent own land");
        
        uint256 totalRent = (land.rentPrice * duration) / 86400; // 按天计算
        require(
            gameToken.transferFrom(msg.sender, ownerOf(landId), totalRent),
            "VirtualLand: Payment failed"
        );
        
        rentals[landId] = RentalInfo({
            landId: landId,
            tenant: msg.sender,
            startTime: block.timestamp,
            endTime: block.timestamp + duration,
            rentAmount: totalRent,
            isActive: true,
            isPaid: true
        });
        
        land.isForRent = false;
        
        emit LandRented(landId, msg.sender, totalRent, duration);
    }
    
    /// @notice 结束租赁
    /// @param landId 土地ID
    function endRental(uint256 landId) external validLand(landId) {
        RentalInfo storage rental = rentals[landId];
        require(rental.isActive, "VirtualLand: No active rental");
        require(
            msg.sender == ownerOf(landId) || 
            msg.sender == rental.tenant || 
            block.timestamp >= rental.endTime,
            "VirtualLand: Not authorized to end rental"
        );
        
        rental.isActive = false;
    }
    
    // ✅ 交易功能
    
    /// @notice 设置土地出售
    /// @param landId 土地ID
    /// @param salePrice 售价
    function setLandForSale(
        uint256 landId,
        uint256 salePrice
    ) external landOwner(landId) validLand(landId) {
        require(salePrice > 0, "VirtualLand: Invalid sale price");
        require(!rentals[landId].isActive, "VirtualLand: Cannot sell rented land");
        
        LandInfo storage land = lands[landId];
        land.isForSale = true;
        land.salePrice = salePrice;
    }
    
    /// @notice 购买土地
    /// @param landId 土地ID
    function buyLand(uint256 landId) external validLand(landId) {
        LandInfo storage land = lands[landId];
        require(land.isForSale, "VirtualLand: Land not for sale");
        require(msg.sender != ownerOf(landId), "VirtualLand: Cannot buy own land");
        
        address seller = ownerOf(landId);
        uint256 price = land.salePrice;
        
        require(
            gameToken.transferFrom(msg.sender, seller, price),
            "VirtualLand: Payment failed"
        );
        
        // 转移土地所有权
        _transfer(seller, msg.sender, landId);
        
        // 更新土地信息
        land.owner = msg.sender;
        land.isForSale = false;
        land.salePrice = 0;
        
        emit LandSold(landId, seller, msg.sender, price);
    }
    
    // ✅ 辅助函数
    
    /// @notice 计算开发费用
    /// @param landId 土地ID
    /// @return 开发费用
    function _calculateDevelopmentCost(uint256 landId) internal view returns (uint256) {
        LandInfo storage land = lands[landId];
        uint256 baseCost = landPrices[land.landType] / 10;
        uint256 levelMultiplier = land.developmentLevel + 1;
        return baseCost * levelMultiplier;
    }
    
    /// @notice 检查建筑类型兼容性
    /// @param landType 土地类型
    /// @param buildingType 建筑类型
    /// @return 是否兼容
    function _isBuildingCompatible(LandType landType, BuildingType buildingType) internal pure returns (bool) {
        if (landType == LandType.Residential) {
            return buildingType == BuildingType.House || buildingType == BuildingType.Park;
        } else if (landType == LandType.Commercial) {
            return buildingType == BuildingType.Shop || buildingType == BuildingType.Museum;
        } else if (landType == LandType.Industrial) {
            return buildingType == BuildingType.Factory;
        } else if (landType == LandType.Entertainment) {
            return buildingType == BuildingType.Casino || buildingType == BuildingType.Stadium;
        } else if (landType == LandType.Special) {
            return true; // 特殊土地可以建造任何建筑
        }
        return false;
    }
    
    /// @notice 计算建筑收入
    /// @param buildingType 建筑类型
    /// @param level 建筑等级
    /// @return 收入
    function _calculateBuildingIncome(BuildingType buildingType, uint256 level) internal pure returns (uint256) {
        uint256 baseIncome;
        
        if (buildingType == BuildingType.House) {
            baseIncome = 10 * 10**18;
        } else if (buildingType == BuildingType.Shop) {
            baseIncome = 50 * 10**18;
        } else if (buildingType == BuildingType.Factory) {
            baseIncome = 100 * 10**18;
        } else if (buildingType == BuildingType.Casino) {
            baseIncome = 200 * 10**18;
        } else if (buildingType == BuildingType.Museum) {
            baseIncome = 30 * 10**18;
        } else if (buildingType == BuildingType.Park) {
            baseIncome = 5 * 10**18;
        } else if (buildingType == BuildingType.Stadium) {
            baseIncome = 500 * 10**18;
        }
        
        return baseIncome * level;
    }
    
    // ✅ 查询功能
    
    /// @notice 获取土地信息
    /// @param landId 土地ID
    /// @return 土地信息
    function getLandInfo(uint256 landId) external view validLand(landId) returns (LandInfo memory) {
        return lands[landId];
    }
    
    /// @notice 获取坐标处的土地ID
    /// @param x X坐标
    /// @param y Y坐标
    /// @return 土地ID
    function getLandIdByCoordinate(int256 x, int256 y) external view returns (uint256) {
        return coordinateToLandId[x][y];
    }
    
    /// @notice 获取土地建筑列表
    /// @param landId 土地ID
    /// @return 建筑列表
    function getLandBuildings(uint256 landId) external view validLand(landId) returns (Building[] memory) {
        return landBuildings[landId];
    }
    
    /// @notice 获取租赁信息
    /// @param landId 土地ID
    /// @return 租赁信息
    function getRentalInfo(uint256 landId) external view validLand(landId) returns (RentalInfo memory) {
        return rentals[landId];
    }
    
    /// @notice 获取用户拥有的土地列表
    /// @param owner 用户地址
    /// @return 土地ID数组
    function getLandsByOwner(address owner) external view returns (uint256[] memory) {
        uint256 balance = balanceOf(owner);
        uint256[] memory result = new uint256[](balance);
        
        for (uint256 i = 0; i < balance; i++) {
            result[i] = tokenOfOwnerByIndex(owner, i);
        }
        
        return result;
    }
    
    /// @notice 获取出售中的土地列表
    /// @return 土地ID数组
    function getLandsForSale() external view returns (uint256[] memory) {
        uint256 totalSupply = _landIdCounter.current();
        uint256 count = 0;
        
        // 计算出售中的土地数量
        for (uint256 i = 0; i < totalSupply; i++) {
            if (_exists(i) && lands[i].isForSale) {
                count++;
            }
        }
        
        // 构建结果数组
        uint256[] memory result = new uint256[](count);
        uint256 index = 0;
        
        for (uint256 i = 0; i < totalSupply; i++) {
            if (_exists(i) && lands[i].isForSale) {
                result[index] = i;
                index++;
            }
        }
        
        return result;
    }
    
    /// @notice 获取出租中的土地列表
    /// @return 土地ID数组
    function getLandsForRent() external view returns (uint256[] memory) {
        uint256 totalSupply = _landIdCounter.current();
        uint256 count = 0;
        
        // 计算出租中的土地数量
        for (uint256 i = 0; i < totalSupply; i++) {
            if (_exists(i) && lands[i].isForRent) {
                count++;
            }
        }
        
        // 构建结果数组
        uint256[] memory result = new uint256[](count);
        uint256 index = 0;
        
        for (uint256 i = 0; i < totalSupply; i++) {
            if (_exists(i) && lands[i].isForRent) {
                result[index] = i;
                index++;
            }
        }
        
        return result;
    }
    
    // ✅ 管理功能
    
    /// @notice 设置土地价格
    /// @param landType 土地类型
    /// @param price 价格
    function setLandPrice(LandType landType, uint256 price) external onlyOwner {
        landPrices[landType] = price;
    }
    
    /// @notice 设置建筑费用
    /// @param buildingType 建筑类型
    /// @param cost 费用
    function setBuildingCost(BuildingType buildingType, uint256 cost) external onlyOwner {
        buildingCosts[buildingType] = cost;
    }
    
    /// @notice 提取合约余额
    function withdraw() external onlyOwner {
        uint256 balance = gameToken.balanceOf(address(this));
        require(balance > 0, "VirtualLand: No balance to withdraw");
        
        require(
            gameToken.transfer(owner(), balance),
            "VirtualLand: Transfer failed"
        );
    }
    
    // ✅ 重写必要的函数
    
    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 tokenId,
        uint256 batchSize
    ) internal override(ERC721, ERC721Enumerable) {
        super._beforeTokenTransfer(from, to, tokenId, batchSize);
        
        // 转移时更新土地所有者信息
        if (from != address(0) && to != address(0)) {
            lands[tokenId].owner = to;
        }
    }
    
    function supportsInterface(bytes4 interfaceId)
        public
        view
        override(ERC721, ERC721Enumerable)
        returns (bool)
    {
        return super.supportsInterface(interfaceId);
    }
}
```

### 核心技能掌握
1. **虚拟世界架构**：坐标系统、土地管理、空间规划
2. **NFT土地系统**：土地铸造、开发、交易机制
3. **建筑系统**：建筑类型、兼容性检查、收入计算
4. **租赁经济**：土地租赁、收益分配、时间管理
5. **元宇宙经济**：虚拟资产定价、市场机制设计

### 项目记录
- 实现了完整的虚拟土地系统
- 开发了多样化的建筑和开发机制
- 设计了灵活的租赁和交易系统

---

## 学习心得与总结

### 核心技术掌握

通过本课程的学习，我在游戏化与NFT应用方面取得了显著进展：

1. **NFT技术深度应用**
   - 掌握了ERC-721标准的高级特性和扩展功能
   - 实现了复杂的NFT属性系统和升级机制
   - 开发了多层次的稀有度和游戏化设计

2. **GameFi生态构建**
   - 深入理解Play-to-Earn经济模型的设计原理
   - 实现了可持续的代币经济和奖励分发机制
   - 掌握了质押挖矿和游戏化激励的技术实现

3. **元宇宙技术架构**
   - 构建了完整的虚拟世界基础设施
   - 实现了土地系统、建筑系统和租赁经济
   - 设计了复杂的空间管理和资产交易机制

### 技术创新点

1. **动态属性系统**：实现了NFT属性的动态升级和经验值积累
2. **多维度奖励机制**：结合签到、成就、游戏表现的综合奖励系统
3. **经济平衡设计**：通过每日限额、费用机制实现经济可持续性
4. **空间坐标系统**：基于坐标的虚拟世界管理和土地分配

### 实践项目成果

1. **GameNFT合约**：支持多种类型、稀有度和游戏化功能的NFT系统
2. **GameFiCore合约**：完整的Play-to-Earn游戏核心逻辑
3. **GameRewardSystem合约**：成就系统和奖励分发机制
4. **VirtualLand合约**：虚拟土地管理和元宇宙基础设施
5. **GameToken合约**：支持经济平衡的游戏代币系统

### 未来发展方向

1. **跨链游戏资产**：研究NFT和游戏资产的跨链互操作性
2. **AI驱动的游戏机制**：结合人工智能优化游戏平衡和用户体验
3. **社交游戏功能**：开发公会系统、社交互动和协作机制
4. **可持续经济模型**：深入研究长期可持续的GameFi经济设计

### 技术栈总结

- **智能合约开发**：Solidity 0.8.19+, OpenZeppelin库
- **NFT标准**：ERC-721, ERC-721Enumerable, ERC-721URIStorage
- **代币标准**：ERC-20, 自定义代币经济模型
- **游戏化设计**：等级系统、经验值、成就系统
- **经济模型**：通胀控制、销毁机制、奖励分发
- **元宇宙技术**：坐标系统、虚拟资产管理

---

**文档更新时间**：2024年12月  
**版本**：v1.0  
**学习状态**：持续进行中