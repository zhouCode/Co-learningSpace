# æ™ºèƒ½åˆçº¦å¼€å‘è¦ç‚¹

> **å­¦ä¹ è€…**: è´¹æ²çƒ½  
> **å­¦ä¹ ç‰¹è‰²**: æ³¨é‡ç»†èŠ‚å’Œä»£ç è´¨é‡  
> **ä»£ç é£æ ¼**: ç²¾ç›Šæ±‚ç²¾ï¼Œè´¨é‡å¯¼å‘  
> **ç¬”è®°é‡ç‚¹**: ä»£ç è´¨é‡ä¿è¯ä¸æµ‹è¯•  
> **é¡¹ç›®ä»£ç **: QualityAssurance.sol  
> **åˆ›å»ºæ—¶é—´**: 2024å¹´

---

## ğŸ” ä»£ç è´¨é‡ä¿è¯ä½“ç³»

### é™æ€ä»£ç åˆ†æå™¨

é™æ€ä»£ç åˆ†ææ˜¯ç¡®ä¿ä»£ç è´¨é‡çš„ç¬¬ä¸€é“é˜²çº¿ï¼Œé€šè¿‡è‡ªåŠ¨åŒ–å·¥å…·æ£€æµ‹æ½œåœ¨é—®é¢˜ã€‚

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

/**
 * @title é™æ€ä»£ç åˆ†æå™¨
 * @dev å®ç°æ™ºèƒ½åˆçº¦çš„é™æ€ä»£ç è´¨é‡æ£€æŸ¥
 * @author è´¹æ²çƒ½ (2023111423)
 */
contract StaticCodeAnalyzer {
    
    // ==================== çŠ¶æ€å˜é‡ ====================
    
    struct CodeMetrics {
        uint256 linesOfCode;           // ä»£ç è¡Œæ•°
        uint256 cyclomaticComplexity;  // åœˆå¤æ‚åº¦
        uint256 functionCount;         // å‡½æ•°æ•°é‡
        uint256 securityIssues;        // å®‰å…¨é—®é¢˜æ•°é‡
        uint256 codeSmells;            // ä»£ç å¼‚å‘³æ•°é‡
        bool isAnalyzed;               // æ˜¯å¦å·²åˆ†æ
    }
    
    struct SecurityIssue {
        string issueType;              // é—®é¢˜ç±»å‹
        string severity;               // ä¸¥é‡ç¨‹åº¦
        string description;            // é—®é¢˜æè¿°
        string recommendation;         // ä¿®å¤å»ºè®®
        bool isFixed;                  // æ˜¯å¦å·²ä¿®å¤
    }
    
    mapping(address => CodeMetrics) public contractMetrics;
    mapping(address => SecurityIssue[]) public securityIssues;
    mapping(address => string[]) public codeSmells;
    
    address public analyzer;
    uint256 public totalAnalyzedContracts;
    
    // ==================== äº‹ä»¶å®šä¹‰ ====================
    
    event ContractAnalyzed(
        address indexed contractAddress,
        uint256 linesOfCode,
        uint256 cyclomaticComplexity,
        uint256 securityIssues
    );
    
    event SecurityIssueFound(
        address indexed contractAddress,
        string issueType,
        string severity
    );
    
    event IssueFixed(
        address indexed contractAddress,
        uint256 issueIndex
    );
    
    // ==================== ä¿®é¥°ç¬¦ ====================
    
    modifier onlyAnalyzer() {
        require(msg.sender == analyzer, "Only analyzer can perform this action");
        _;
    }
    
    modifier validContract(address contractAddr) {
        require(contractAddr != address(0), "Invalid contract address");
        require(contractAddr.code.length > 0, "Address is not a contract");
        _;
    }
    
    // ==================== æ„é€ å‡½æ•° ====================
    
    constructor() {
        analyzer = msg.sender;
    }
    
    // ==================== åˆ†æå‡½æ•° ====================
    
    /**
     * @dev åˆ†æåˆçº¦ä»£ç è´¨é‡
     * @param contractAddr åˆçº¦åœ°å€
     * @param linesOfCode ä»£ç è¡Œæ•°
     * @param cyclomaticComplexity åœˆå¤æ‚åº¦
     * @param functionCount å‡½æ•°æ•°é‡
     */
    function analyzeContract(
        address contractAddr,
        uint256 linesOfCode,
        uint256 cyclomaticComplexity,
        uint256 functionCount
    ) external onlyAnalyzer validContract(contractAddr) {
        require(!contractMetrics[contractAddr].isAnalyzed, "Contract already analyzed");
        
        // åˆå§‹åŒ–ä»£ç åº¦é‡
        contractMetrics[contractAddr] = CodeMetrics({
            linesOfCode: linesOfCode,
            cyclomaticComplexity: cyclomaticComplexity,
            functionCount: functionCount,
            securityIssues: 0,
            codeSmells: 0,
            isAnalyzed: true
        });
        
        // æ‰§è¡Œè´¨é‡æ£€æŸ¥
        _performQualityChecks(contractAddr);
        
        totalAnalyzedContracts++;
        
        emit ContractAnalyzed(
            contractAddr,
            linesOfCode,
            cyclomaticComplexity,
            contractMetrics[contractAddr].securityIssues
        );
    }
    
    /**
     * @dev æ‰§è¡Œè´¨é‡æ£€æŸ¥
     * @param contractAddr åˆçº¦åœ°å€
     */
    function _performQualityChecks(address contractAddr) internal {
        CodeMetrics storage metrics = contractMetrics[contractAddr];
        
        // æ£€æŸ¥åœˆå¤æ‚åº¦
        if (metrics.cyclomaticComplexity > 10) {
            _addSecurityIssue(
                contractAddr,
                "High Complexity",
                "Warning",
                "Cyclomatic complexity is too high",
                "Consider breaking down complex functions"
            );
        }
        
        // æ£€æŸ¥å‡½æ•°æ•°é‡
        if (metrics.functionCount > 20) {
            _addCodeSmell(contractAddr, "Too many functions in contract");
        }
        
        // æ£€æŸ¥ä»£ç è¡Œæ•°
        if (metrics.linesOfCode > 500) {
            _addCodeSmell(contractAddr, "Contract is too large");
        }
        
        // æ£€æŸ¥å‡½æ•°å¹³å‡é•¿åº¦
        uint256 avgFunctionLength = metrics.linesOfCode / metrics.functionCount;
        if (avgFunctionLength > 50) {
            _addCodeSmell(contractAddr, "Functions are too long on average");
        }
    }
    
    /**
     * @dev æ·»åŠ å®‰å…¨é—®é¢˜
     */
    function _addSecurityIssue(
        address contractAddr,
        string memory issueType,
        string memory severity,
        string memory description,
        string memory recommendation
    ) internal {
        securityIssues[contractAddr].push(SecurityIssue({
            issueType: issueType,
            severity: severity,
            description: description,
            recommendation: recommendation,
            isFixed: false
        }));
        
        contractMetrics[contractAddr].securityIssues++;
        
        emit SecurityIssueFound(contractAddr, issueType, severity);
    }
    
    /**
     * @dev æ·»åŠ ä»£ç å¼‚å‘³
     */
    function _addCodeSmell(address contractAddr, string memory smell) internal {
        codeSmells[contractAddr].push(smell);
        contractMetrics[contractAddr].codeSmells++;
    }
    
    /**
     * @dev æ ‡è®°é—®é¢˜å·²ä¿®å¤
     * @param contractAddr åˆçº¦åœ°å€
     * @param issueIndex é—®é¢˜ç´¢å¼•
     */
    function markIssueFixed(
        address contractAddr,
        uint256 issueIndex
    ) external onlyAnalyzer {
        require(issueIndex < securityIssues[contractAddr].length, "Invalid issue index");
        require(!securityIssues[contractAddr][issueIndex].isFixed, "Issue already fixed");
        
        securityIssues[contractAddr][issueIndex].isFixed = true;
        
        emit IssueFixed(contractAddr, issueIndex);
    }
    
    // ==================== æŸ¥è¯¢å‡½æ•° ====================
    
    /**
     * @dev è·å–åˆçº¦åº¦é‡ä¿¡æ¯
     * @param contractAddr åˆçº¦åœ°å€
     * @return metrics åº¦é‡ä¿¡æ¯
     */
    function getContractMetrics(address contractAddr) 
        external 
        view 
        returns (CodeMetrics memory metrics) 
    {
        return contractMetrics[contractAddr];
    }
    
    /**
     * @dev è·å–å®‰å…¨é—®é¢˜æ•°é‡
     * @param contractAddr åˆçº¦åœ°å€
     * @return count é—®é¢˜æ•°é‡
     */
    function getSecurityIssueCount(address contractAddr) 
        external 
        view 
        returns (uint256 count) 
    {
        return securityIssues[contractAddr].length;
    }
    
    /**
     * @dev è·å–ä»£ç å¼‚å‘³æ•°é‡
     * @param contractAddr åˆçº¦åœ°å€
     * @return count å¼‚å‘³æ•°é‡
     */
    function getCodeSmellCount(address contractAddr) 
        external 
        view 
        returns (uint256 count) 
    {
        return codeSmells[contractAddr].length;
    }
    
    /**
     * @dev è·å–è´¨é‡è¯„åˆ†
     * @param contractAddr åˆçº¦åœ°å€
     * @return score è´¨é‡è¯„åˆ† (0-100)
     */
    function getQualityScore(address contractAddr) 
        external 
        view 
        returns (uint256 score) 
    {
        require(contractMetrics[contractAddr].isAnalyzed, "Contract not analyzed");
        
        CodeMetrics memory metrics = contractMetrics[contractAddr];
        
        // åŸºç¡€åˆ†æ•°
        uint256 baseScore = 100;
        
        // æ ¹æ®å®‰å…¨é—®é¢˜æ‰£åˆ†
        uint256 securityPenalty = metrics.securityIssues * 10;
        
        // æ ¹æ®ä»£ç å¼‚å‘³æ‰£åˆ†
        uint256 smellPenalty = metrics.codeSmells * 5;
        
        // æ ¹æ®å¤æ‚åº¦æ‰£åˆ†
        uint256 complexityPenalty = 0;
        if (metrics.cyclomaticComplexity > 10) {
            complexityPenalty = (metrics.cyclomaticComplexity - 10) * 2;
        }
        
        // è®¡ç®—æœ€ç»ˆåˆ†æ•°
        uint256 totalPenalty = securityPenalty + smellPenalty + complexityPenalty;
        
        if (totalPenalty >= baseScore) {
            return 0;
        }
        
        return baseScore - totalPenalty;
    }
}
```

### æµ‹è¯•è¦†ç›–ç‡åˆ†æ

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

/**
 * @title æµ‹è¯•è¦†ç›–ç‡åˆ†æå™¨
 * @dev è·Ÿè¸ªå’Œåˆ†ææ™ºèƒ½åˆçº¦çš„æµ‹è¯•è¦†ç›–ç‡
 * @author è´¹æ²çƒ½ (2023111423)
 */
contract TestCoverageAnalyzer {
    
    // ==================== æ•°æ®ç»“æ„ ====================
    
    struct CoverageData {
        uint256 totalLines;            // æ€»è¡Œæ•°
        uint256 coveredLines;          // è¦†ç›–è¡Œæ•°
        uint256 totalFunctions;        // æ€»å‡½æ•°æ•°
        uint256 coveredFunctions;      // è¦†ç›–å‡½æ•°æ•°
        uint256 totalBranches;         // æ€»åˆ†æ”¯æ•°
        uint256 coveredBranches;       // è¦†ç›–åˆ†æ”¯æ•°
        bool isInitialized;            // æ˜¯å¦å·²åˆå§‹åŒ–
    }
    
    struct TestCase {
        string name;                   // æµ‹è¯•ç”¨ä¾‹åç§°
        string description;            // æµ‹è¯•æè¿°
        bool passed;                   // æ˜¯å¦é€šè¿‡
        uint256 executionTime;         // æ‰§è¡Œæ—¶é—´(ms)
        string[] coveredFunctions;     // è¦†ç›–çš„å‡½æ•°
    }
    
    mapping(address => CoverageData) public contractCoverage;
    mapping(address => TestCase[]) public testCases;
    mapping(address => mapping(string => bool)) public functionCovered;
    
    address public tester;
    uint256 public totalTestedContracts;
    
    // ==================== äº‹ä»¶å®šä¹‰ ====================
    
    event CoverageUpdated(
        address indexed contractAddress,
        uint256 lineCoverage,
        uint256 functionCoverage,
        uint256 branchCoverage
    );
    
    event TestCaseAdded(
        address indexed contractAddress,
        string testName,
        bool passed
    );
    
    event CoverageThresholdReached(
        address indexed contractAddress,
        string coverageType,
        uint256 percentage
    );
    
    // ==================== ä¿®é¥°ç¬¦ ====================
    
    modifier onlyTester() {
        require(msg.sender == tester, "Only tester can perform this action");
        _;
    }
    
    modifier validContract(address contractAddr) {
        require(contractAddr != address(0), "Invalid contract address");
        _;
    }
    
    // ==================== æ„é€ å‡½æ•° ====================
    
    constructor() {
        tester = msg.sender;
    }
    
    // ==================== è¦†ç›–ç‡ç®¡ç† ====================
    
    /**
     * @dev åˆå§‹åŒ–åˆçº¦è¦†ç›–ç‡æ•°æ®
     * @param contractAddr åˆçº¦åœ°å€
     * @param totalLines æ€»è¡Œæ•°
     * @param totalFunctions æ€»å‡½æ•°æ•°
     * @param totalBranches æ€»åˆ†æ”¯æ•°
     */
    function initializeCoverage(
        address contractAddr,
        uint256 totalLines,
        uint256 totalFunctions,
        uint256 totalBranches
    ) external onlyTester validContract(contractAddr) {
        require(!contractCoverage[contractAddr].isInitialized, "Coverage already initialized");
        
        contractCoverage[contractAddr] = CoverageData({
            totalLines: totalLines,
            coveredLines: 0,
            totalFunctions: totalFunctions,
            coveredFunctions: 0,
            totalBranches: totalBranches,
            coveredBranches: 0,
            isInitialized: true
        });
        
        totalTestedContracts++;
    }
    
    /**
     * @dev æ·»åŠ æµ‹è¯•ç”¨ä¾‹
     * @param contractAddr åˆçº¦åœ°å€
     * @param name æµ‹è¯•ç”¨ä¾‹åç§°
     * @param description æµ‹è¯•æè¿°
     * @param passed æ˜¯å¦é€šè¿‡
     * @param executionTime æ‰§è¡Œæ—¶é—´
     * @param coveredFunctions è¦†ç›–çš„å‡½æ•°åˆ—è¡¨
     */
    function addTestCase(
        address contractAddr,
        string memory name,
        string memory description,
        bool passed,
        uint256 executionTime,
        string[] memory coveredFunctions
    ) external onlyTester validContract(contractAddr) {
        require(contractCoverage[contractAddr].isInitialized, "Coverage not initialized");
        
        // æ·»åŠ æµ‹è¯•ç”¨ä¾‹
        testCases[contractAddr].push(TestCase({
            name: name,
            description: description,
            passed: passed,
            executionTime: executionTime,
            coveredFunctions: coveredFunctions
        }));
        
        // æ›´æ–°å‡½æ•°è¦†ç›–ç‡
        for (uint256 i = 0; i < coveredFunctions.length; i++) {
            if (!functionCovered[contractAddr][coveredFunctions[i]]) {
                functionCovered[contractAddr][coveredFunctions[i]] = true;
                contractCoverage[contractAddr].coveredFunctions++;
            }
        }
        
        emit TestCaseAdded(contractAddr, name, passed);
        
        // æ£€æŸ¥è¦†ç›–ç‡é˜ˆå€¼
        _checkCoverageThresholds(contractAddr);
    }
    
    /**
     * @dev æ›´æ–°è¡Œè¦†ç›–ç‡
     * @param contractAddr åˆçº¦åœ°å€
     * @param coveredLines è¦†ç›–çš„è¡Œæ•°
     */
    function updateLineCoverage(
        address contractAddr,
        uint256 coveredLines
    ) external onlyTester validContract(contractAddr) {
        require(contractCoverage[contractAddr].isInitialized, "Coverage not initialized");
        require(coveredLines <= contractCoverage[contractAddr].totalLines, "Invalid covered lines");
        
        contractCoverage[contractAddr].coveredLines = coveredLines;
        
        _emitCoverageUpdate(contractAddr);
        _checkCoverageThresholds(contractAddr);
    }
    
    /**
     * @dev æ›´æ–°åˆ†æ”¯è¦†ç›–ç‡
     * @param contractAddr åˆçº¦åœ°å€
     * @param coveredBranches è¦†ç›–çš„åˆ†æ”¯æ•°
     */
    function updateBranchCoverage(
        address contractAddr,
        uint256 coveredBranches
    ) external onlyTester validContract(contractAddr) {
        require(contractCoverage[contractAddr].isInitialized, "Coverage not initialized");
        require(coveredBranches <= contractCoverage[contractAddr].totalBranches, "Invalid covered branches");
        
        contractCoverage[contractAddr].coveredBranches = coveredBranches;
        
        _emitCoverageUpdate(contractAddr);
        _checkCoverageThresholds(contractAddr);
    }
    
    /**
     * @dev æ£€æŸ¥è¦†ç›–ç‡é˜ˆå€¼
     * @param contractAddr åˆçº¦åœ°å€
     */
    function _checkCoverageThresholds(address contractAddr) internal {
        CoverageData memory coverage = contractCoverage[contractAddr];
        
        // æ£€æŸ¥è¡Œè¦†ç›–ç‡
        uint256 lineCoveragePercent = (coverage.coveredLines * 100) / coverage.totalLines;
        if (lineCoveragePercent >= 80) {
            emit CoverageThresholdReached(contractAddr, "Line", lineCoveragePercent);
        }
        
        // æ£€æŸ¥å‡½æ•°è¦†ç›–ç‡
        uint256 functionCoveragePercent = (coverage.coveredFunctions * 100) / coverage.totalFunctions;
        if (functionCoveragePercent >= 90) {
            emit CoverageThresholdReached(contractAddr, "Function", functionCoveragePercent);
        }
        
        // æ£€æŸ¥åˆ†æ”¯è¦†ç›–ç‡
        if (coverage.totalBranches > 0) {
            uint256 branchCoveragePercent = (coverage.coveredBranches * 100) / coverage.totalBranches;
            if (branchCoveragePercent >= 75) {
                emit CoverageThresholdReached(contractAddr, "Branch", branchCoveragePercent);
            }
        }
    }
    
    /**
     * @dev å‘å‡ºè¦†ç›–ç‡æ›´æ–°äº‹ä»¶
     * @param contractAddr åˆçº¦åœ°å€
     */
    function _emitCoverageUpdate(address contractAddr) internal {
        CoverageData memory coverage = contractCoverage[contractAddr];
        
        uint256 lineCoverage = (coverage.coveredLines * 100) / coverage.totalLines;
        uint256 functionCoverage = (coverage.coveredFunctions * 100) / coverage.totalFunctions;
        uint256 branchCoverage = coverage.totalBranches > 0 ? 
            (coverage.coveredBranches * 100) / coverage.totalBranches : 0;
        
        emit CoverageUpdated(contractAddr, lineCoverage, functionCoverage, branchCoverage);
    }
    
    // ==================== æŸ¥è¯¢å‡½æ•° ====================
    
    /**
     * @dev è·å–è¦†ç›–ç‡æ•°æ®
     * @param contractAddr åˆçº¦åœ°å€
     * @return coverage è¦†ç›–ç‡æ•°æ®
     */
    function getCoverageData(address contractAddr) 
        external 
        view 
        returns (CoverageData memory coverage) 
    {
        return contractCoverage[contractAddr];
    }
    
    /**
     * @dev è·å–è¡Œè¦†ç›–ç‡ç™¾åˆ†æ¯”
     * @param contractAddr åˆçº¦åœ°å€
     * @return percentage è¦†ç›–ç‡ç™¾åˆ†æ¯”
     */
    function getLineCoveragePercentage(address contractAddr) 
        external 
        view 
        returns (uint256 percentage) 
    {
        CoverageData memory coverage = contractCoverage[contractAddr];
        require(coverage.isInitialized, "Coverage not initialized");
        
        return (coverage.coveredLines * 100) / coverage.totalLines;
    }
    
    /**
     * @dev è·å–å‡½æ•°è¦†ç›–ç‡ç™¾åˆ†æ¯”
     * @param contractAddr åˆçº¦åœ°å€
     * @return percentage è¦†ç›–ç‡ç™¾åˆ†æ¯”
     */
    function getFunctionCoveragePercentage(address contractAddr) 
        external 
        view 
        returns (uint256 percentage) 
    {
        CoverageData memory coverage = contractCoverage[contractAddr];
        require(coverage.isInitialized, "Coverage not initialized");
        
        return (coverage.coveredFunctions * 100) / coverage.totalFunctions;
    }
    
    /**
     * @dev è·å–åˆ†æ”¯è¦†ç›–ç‡ç™¾åˆ†æ¯”
     * @param contractAddr åˆçº¦åœ°å€
     * @return percentage è¦†ç›–ç‡ç™¾åˆ†æ¯”
     */
    function getBranchCoveragePercentage(address contractAddr) 
        external 
        view 
        returns (uint256 percentage) 
    {
        CoverageData memory coverage = contractCoverage[contractAddr];
        require(coverage.isInitialized, "Coverage not initialized");
        
        if (coverage.totalBranches == 0) {
            return 100; // æ²¡æœ‰åˆ†æ”¯æ—¶è®¤ä¸º100%è¦†ç›–
        }
        
        return (coverage.coveredBranches * 100) / coverage.totalBranches;
    }
    
    /**
     * @dev è·å–æµ‹è¯•ç”¨ä¾‹æ•°é‡
     * @param contractAddr åˆçº¦åœ°å€
     * @return count æµ‹è¯•ç”¨ä¾‹æ•°é‡
     */
    function getTestCaseCount(address contractAddr) 
        external 
        view 
        returns (uint256 count) 
    {
        return testCases[contractAddr].length;
    }
    
    /**
     * @dev è·å–é€šè¿‡çš„æµ‹è¯•ç”¨ä¾‹æ•°é‡
     * @param contractAddr åˆçº¦åœ°å€
     * @return count é€šè¿‡çš„æµ‹è¯•ç”¨ä¾‹æ•°é‡
     */
    function getPassedTestCount(address contractAddr) 
        external 
        view 
        returns (uint256 count) 
    {
        TestCase[] memory cases = testCases[contractAddr];
        uint256 passedCount = 0;
        
        for (uint256 i = 0; i < cases.length; i++) {
            if (cases[i].passed) {
                passedCount++;
            }
        }
        
        return passedCount;
    }
    
    /**
     * @dev è·å–æµ‹è¯•é€šè¿‡ç‡
     * @param contractAddr åˆçº¦åœ°å€
     * @return percentage é€šè¿‡ç‡ç™¾åˆ†æ¯”
     */
    function getTestPassRate(address contractAddr) 
        external 
        view 
        returns (uint256 percentage) 
    {
        uint256 totalTests = testCases[contractAddr].length;
        if (totalTests == 0) {
            return 0;
        }
        
        uint256 passedTests = this.getPassedTestCount(contractAddr);
        return (passedTests * 100) / totalTests;
    }
}
```

### æ€§èƒ½ç›‘æ§ç³»ç»Ÿ

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

/**
 * @title æ€§èƒ½ç›‘æ§ç³»ç»Ÿ
 * @dev ç›‘æ§æ™ºèƒ½åˆçº¦çš„æ€§èƒ½æŒ‡æ ‡å’Œèµ„æºä½¿ç”¨æƒ…å†µ
 * @author è´¹æ²çƒ½ (2023111423)
 */
contract PerformanceMonitor {
    
    // ==================== æ•°æ®ç»“æ„ ====================
    
    struct PerformanceMetrics {
        uint256 gasUsed;               // Gasä½¿ç”¨é‡
        uint256 executionTime;         // æ‰§è¡Œæ—¶é—´(ms)
        uint256 memoryUsage;           // å†…å­˜ä½¿ç”¨é‡
        uint256 storageReads;          // å­˜å‚¨è¯»å–æ¬¡æ•°
        uint256 storageWrites;         // å­˜å‚¨å†™å…¥æ¬¡æ•°
        uint256 timestamp;             // æ—¶é—´æˆ³
    }
    
    struct FunctionMetrics {
        string functionName;           // å‡½æ•°åç§°
        uint256 callCount;             // è°ƒç”¨æ¬¡æ•°
        uint256 totalGasUsed;          // æ€»Gasä½¿ç”¨é‡
        uint256 averageGasUsed;        // å¹³å‡Gasä½¿ç”¨é‡
        uint256 maxGasUsed;            // æœ€å¤§Gasä½¿ç”¨é‡
        uint256 minGasUsed;            // æœ€å°Gasä½¿ç”¨é‡
        uint256 totalExecutionTime;    // æ€»æ‰§è¡Œæ—¶é—´
        uint256 averageExecutionTime;  // å¹³å‡æ‰§è¡Œæ—¶é—´
    }
    
    struct ContractPerformance {
        uint256 totalTransactions;     // æ€»äº¤æ˜“æ•°
        uint256 totalGasConsumed;      // æ€»Gasæ¶ˆè€—
        uint256 averageGasPerTx;       // å¹³å‡æ¯ç¬”äº¤æ˜“Gas
        uint256 peakGasUsage;          // å³°å€¼Gasä½¿ç”¨
        uint256 lastUpdated;           // æœ€åæ›´æ–°æ—¶é—´
        bool isMonitored;              // æ˜¯å¦è¢«ç›‘æ§
    }
    
    mapping(address => ContractPerformance) public contractPerformance;
    mapping(address => mapping(string => FunctionMetrics)) public functionMetrics;
    mapping(address => PerformanceMetrics[]) public performanceHistory;
    
    address public monitor;
    uint256 public monitoredContracts;
    
    // æ€§èƒ½é˜ˆå€¼
    uint256 public constant MAX_GAS_THRESHOLD = 500000;
    uint256 public constant MAX_EXECUTION_TIME = 5000; // 5ç§’
    
    // ==================== äº‹ä»¶å®šä¹‰ ====================
    
    event PerformanceRecorded(
        address indexed contractAddress,
        string functionName,
        uint256 gasUsed,
        uint256 executionTime
    );
    
    event PerformanceAlert(
        address indexed contractAddress,
        string alertType,
        uint256 value,
        uint256 threshold
    );
    
    event ContractMonitoringStarted(
        address indexed contractAddress
    );
    
    event PerformanceOptimizationSuggested(
        address indexed contractAddress,
        string suggestion
    );
    
    // ==================== ä¿®é¥°ç¬¦ ====================
    
    modifier onlyMonitor() {
        require(msg.sender == monitor, "Only monitor can perform this action");
        _;
    }
    
    modifier validContract(address contractAddr) {
        require(contractAddr != address(0), "Invalid contract address");
        _;
    }
    
    modifier isMonitored(address contractAddr) {
        require(contractPerformance[contractAddr].isMonitored, "Contract not monitored");
        _;
    }
    
    // ==================== æ„é€ å‡½æ•° ====================
    
    constructor() {
        monitor = msg.sender;
    }
    
    // ==================== ç›‘æ§ç®¡ç† ====================
    
    /**
     * @dev å¼€å§‹ç›‘æ§åˆçº¦
     * @param contractAddr åˆçº¦åœ°å€
     */
    function startMonitoring(address contractAddr) 
        external 
        onlyMonitor 
        validContract(contractAddr) 
    {
        require(!contractPerformance[contractAddr].isMonitored, "Contract already monitored");
        
        contractPerformance[contractAddr] = ContractPerformance({
            totalTransactions: 0,
            totalGasConsumed: 0,
            averageGasPerTx: 0,
            peakGasUsage: 0,
            lastUpdated: block.timestamp,
            isMonitored: true
        });
        
        monitoredContracts++;
        
        emit ContractMonitoringStarted(contractAddr);
    }
    
    /**
     * @dev è®°å½•æ€§èƒ½æ•°æ®
     * @param contractAddr åˆçº¦åœ°å€
     * @param functionName å‡½æ•°åç§°
     * @param gasUsed Gasä½¿ç”¨é‡
     * @param executionTime æ‰§è¡Œæ—¶é—´
     * @param memoryUsage å†…å­˜ä½¿ç”¨é‡
     * @param storageReads å­˜å‚¨è¯»å–æ¬¡æ•°
     * @param storageWrites å­˜å‚¨å†™å…¥æ¬¡æ•°
     */
    function recordPerformance(
        address contractAddr,
        string memory functionName,
        uint256 gasUsed,
        uint256 executionTime,
        uint256 memoryUsage,
        uint256 storageReads,
        uint256 storageWrites
    ) external onlyMonitor validContract(contractAddr) isMonitored(contractAddr) {
        
        // è®°å½•æ€§èƒ½å†å²
        performanceHistory[contractAddr].push(PerformanceMetrics({
            gasUsed: gasUsed,
            executionTime: executionTime,
            memoryUsage: memoryUsage,
            storageReads: storageReads,
            storageWrites: storageWrites,
            timestamp: block.timestamp
        }));
        
        // æ›´æ–°åˆçº¦æ€§èƒ½ç»Ÿè®¡
        _updateContractPerformance(contractAddr, gasUsed);
        
        // æ›´æ–°å‡½æ•°æ€§èƒ½ç»Ÿè®¡
        _updateFunctionMetrics(contractAddr, functionName, gasUsed, executionTime);
        
        // æ£€æŸ¥æ€§èƒ½é˜ˆå€¼
        _checkPerformanceThresholds(contractAddr, functionName, gasUsed, executionTime);
        
        emit PerformanceRecorded(contractAddr, functionName, gasUsed, executionTime);
    }
    
    /**
     * @dev æ›´æ–°åˆçº¦æ€§èƒ½ç»Ÿè®¡
     * @param contractAddr åˆçº¦åœ°å€
     * @param gasUsed Gasä½¿ç”¨é‡
     */
    function _updateContractPerformance(address contractAddr, uint256 gasUsed) internal {
        ContractPerformance storage perf = contractPerformance[contractAddr];
        
        perf.totalTransactions++;
        perf.totalGasConsumed += gasUsed;
        perf.averageGasPerTx = perf.totalGasConsumed / perf.totalTransactions;
        
        if (gasUsed > perf.peakGasUsage) {
            perf.peakGasUsage = gasUsed;
        }
        
        perf.lastUpdated = block.timestamp;
    }
    
    /**
     * @dev æ›´æ–°å‡½æ•°æ€§èƒ½ç»Ÿè®¡
     * @param contractAddr åˆçº¦åœ°å€
     * @param functionName å‡½æ•°åç§°
     * @param gasUsed Gasä½¿ç”¨é‡
     * @param executionTime æ‰§è¡Œæ—¶é—´
     */
    function _updateFunctionMetrics(
        address contractAddr,
        string memory functionName,
        uint256 gasUsed,
        uint256 executionTime
    ) internal {
        FunctionMetrics storage metrics = functionMetrics[contractAddr][functionName];
        
        if (bytes(metrics.functionName).length == 0) {
            // é¦–æ¬¡è®°å½•è¯¥å‡½æ•°
            metrics.functionName = functionName;
            metrics.minGasUsed = gasUsed;
            metrics.maxGasUsed = gasUsed;
        }
        
        metrics.callCount++;
        metrics.totalGasUsed += gasUsed;
        metrics.averageGasUsed = metrics.totalGasUsed / metrics.callCount;
        
        if (gasUsed > metrics.maxGasUsed) {
            metrics.maxGasUsed = gasUsed;
        }
        
        if (gasUsed < metrics.minGasUsed) {
            metrics.minGasUsed = gasUsed;
        }
        
        metrics.totalExecutionTime += executionTime;
        metrics.averageExecutionTime = metrics.totalExecutionTime / metrics.callCount;
    }
    
    /**
     * @dev æ£€æŸ¥æ€§èƒ½é˜ˆå€¼
     * @param contractAddr åˆçº¦åœ°å€
     * @param functionName å‡½æ•°åç§°
     * @param gasUsed Gasä½¿ç”¨é‡
     * @param executionTime æ‰§è¡Œæ—¶é—´
     */
    function _checkPerformanceThresholds(
        address contractAddr,
        string memory functionName,
        uint256 gasUsed,
        uint256 executionTime
    ) internal {
        // æ£€æŸ¥Gasä½¿ç”¨é‡é˜ˆå€¼
        if (gasUsed > MAX_GAS_THRESHOLD) {
            emit PerformanceAlert(
                contractAddr,
                "High Gas Usage",
                gasUsed,
                MAX_GAS_THRESHOLD
            );
            
            emit PerformanceOptimizationSuggested(
                contractAddr,
                string(abi.encodePacked("Function ", functionName, " uses excessive gas. Consider optimization."))
            );
        }
        
        // æ£€æŸ¥æ‰§è¡Œæ—¶é—´é˜ˆå€¼
        if (executionTime > MAX_EXECUTION_TIME) {
            emit PerformanceAlert(
                contractAddr,
                "Long Execution Time",
                executionTime,
                MAX_EXECUTION_TIME
            );
            
            emit PerformanceOptimizationSuggested(
                contractAddr,
                string(abi.encodePacked("Function ", functionName, " takes too long to execute. Consider optimization."))
            );
        }
    }
    
    // ==================== æŸ¥è¯¢å‡½æ•° ====================
    
    /**
     * @dev è·å–åˆçº¦æ€§èƒ½ç»Ÿè®¡
     * @param contractAddr åˆçº¦åœ°å€
     * @return performance æ€§èƒ½ç»Ÿè®¡
     */
    function getContractPerformance(address contractAddr) 
        external 
        view 
        returns (ContractPerformance memory performance) 
    {
        return contractPerformance[contractAddr];
    }
    
    /**
     * @dev è·å–å‡½æ•°æ€§èƒ½ç»Ÿè®¡
     * @param contractAddr åˆçº¦åœ°å€
     * @param functionName å‡½æ•°åç§°
     * @return metrics å‡½æ•°æ€§èƒ½ç»Ÿè®¡
     */
    function getFunctionMetrics(address contractAddr, string memory functionName) 
        external 
        view 
        returns (FunctionMetrics memory metrics) 
    {
        return functionMetrics[contractAddr][functionName];
    }
    
    /**
     * @dev è·å–æ€§èƒ½å†å²è®°å½•æ•°é‡
     * @param contractAddr åˆçº¦åœ°å€
     * @return count è®°å½•æ•°é‡
     */
    function getPerformanceHistoryCount(address contractAddr) 
        external 
        view 
        returns (uint256 count) 
    {
        return performanceHistory[contractAddr].length;
    }
    
    /**
     * @dev è·å–æœ€è¿‘çš„æ€§èƒ½æ•°æ®
     * @param contractAddr åˆçº¦åœ°å€
     * @param count è·å–æ•°é‡
     * @return metrics æ€§èƒ½æ•°æ®æ•°ç»„
     */
    function getRecentPerformanceData(address contractAddr, uint256 count) 
        external 
        view 
        returns (PerformanceMetrics[] memory metrics) 
    {
        PerformanceMetrics[] storage history = performanceHistory[contractAddr];
        uint256 totalCount = history.length;
        
        if (count > totalCount) {
            count = totalCount;
        }
        
        metrics = new PerformanceMetrics[](count);
        
        for (uint256 i = 0; i < count; i++) {
            metrics[i] = history[totalCount - count + i];
        }
        
        return metrics;
    }
    
    /**
     * @dev è·å–æ€§èƒ½è¶‹åŠ¿åˆ†æ
     * @param contractAddr åˆçº¦åœ°å€
     * @return trend è¶‹åŠ¿åˆ†æç»“æœ (1: ä¸Šå‡, 0: ç¨³å®š, -1: ä¸‹é™)
     */
    function getPerformanceTrend(address contractAddr) 
        external 
        view 
        returns (int256 trend) 
    {
        PerformanceMetrics[] storage history = performanceHistory[contractAddr];
        uint256 length = history.length;
        
        if (length < 10) {
            return 0; // æ•°æ®ä¸è¶³ï¼Œè®¤ä¸ºç¨³å®š
        }
        
        // è®¡ç®—æœ€è¿‘10æ¬¡çš„å¹³å‡Gasä½¿ç”¨é‡
        uint256 recentAvg = 0;
        uint256 previousAvg = 0;
        
        for (uint256 i = length - 10; i < length; i++) {
            recentAvg += history[i].gasUsed;
        }
        recentAvg /= 10;
        
        for (uint256 i = length - 20; i < length - 10; i++) {
            previousAvg += history[i].gasUsed;
        }
        previousAvg /= 10;
        
        // åˆ¤æ–­è¶‹åŠ¿
        if (recentAvg > previousAvg * 110 / 100) { // å¢é•¿è¶…è¿‡10%
            return 1;
        } else if (recentAvg < previousAvg * 90 / 100) { // ä¸‹é™è¶…è¿‡10%
            return -1;
        } else {
            return 0;
        }
    }
}
```

---

## âš¡ ç»†èŠ‚ä¼˜åŒ–æŠ€å·§

### Gasä¼˜åŒ–ç­–ç•¥

1. **å­˜å‚¨ä¼˜åŒ–**
   - ä½¿ç”¨packedç»“æ„ä½“å‡å°‘å­˜å‚¨æ§½
   - åˆç†å®‰æ’å˜é‡é¡ºåº
   - é¿å…ä¸å¿…è¦çš„å­˜å‚¨æ“ä½œ
   - ä½¿ç”¨å¸¸é‡å’Œä¸å¯å˜å˜é‡

2. **è®¡ç®—ä¼˜åŒ–**
   - ä½¿ç”¨ä½è¿ç®—æ›¿ä»£é™¤æ³•å’Œæ¨¡è¿ç®—
   - é¿å…å¾ªç¯ä¸­çš„é‡å¤è®¡ç®—
   - ä½¿ç”¨uncheckedå—è¿›è¡Œå®‰å…¨çš„ç®—æœ¯è¿ç®—
   - é¢„è®¡ç®—å¸¸ç”¨å€¼

3. **å‡½æ•°ä¼˜åŒ–**
   - ä½¿ç”¨externalè€Œépublic
   - åˆç†ä½¿ç”¨viewå’Œpureä¿®é¥°ç¬¦
   - é¿å…ä¸å¿…è¦çš„å‡½æ•°è°ƒç”¨
   - ä½¿ç”¨å†…è”æ±‡ç¼–ä¼˜åŒ–å…³é”®è·¯å¾„

### é”™è¯¯å¤„ç†æœ€ä½³å®è·µ

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

/**
 * @title é”™è¯¯å¤„ç†æœ€ä½³å®è·µæ¼”ç¤º
 * @dev å±•ç¤ºæ™ºèƒ½åˆçº¦ä¸­çš„é”™è¯¯å¤„ç†æŠ€å·§
 * @author è´¹æ²çƒ½ (2023111423)
 */
contract ErrorHandlingBestPractices {
    
    // ==================== è‡ªå®šä¹‰é”™è¯¯ ====================
    
    // ä½¿ç”¨è‡ªå®šä¹‰é”™è¯¯æ¯”å­—ç¬¦ä¸²æ›´èŠ‚çœGas
    error InsufficientBalance(uint256 available, uint256 required);
    error InvalidAddress(address addr);
    error Unauthorized(address caller, address required);
    error TransferFailed(address from, address to, uint256 amount);
    error InvalidAmount(uint256 amount);
    error ContractPaused();
    error DeadlineExceeded(uint256 deadline, uint256 current);
    
    // ==================== çŠ¶æ€å˜é‡ ====================
    
    mapping(address => uint256) private _balances;
    address private _owner;
    bool private _paused;
    uint256 private _totalSupply;
    
    // ==================== äº‹ä»¶å®šä¹‰ ====================
    
    event Transfer(address indexed from, address indexed to, uint256 value);
    event ErrorLogged(string errorType, string message, address user);
    event RecoveryExecuted(string action, address executor);
    
    // ==================== ä¿®é¥°ç¬¦ ====================
    
    /**
     * @dev æ£€æŸ¥åˆçº¦æ˜¯å¦æš‚åœ
     */
    modifier whenNotPaused() {
        if (_paused) {
            revert ContractPaused();
        }
        _;
    }
    
    /**
     * @dev æ£€æŸ¥è°ƒç”¨è€…æƒé™
     */
    modifier onlyOwner() {
        if (msg.sender != _owner) {
            revert Unauthorized(msg.sender, _owner);
        }
        _;
    }
    
    /**
     * @dev æ£€æŸ¥åœ°å€æœ‰æ•ˆæ€§
     */
    modifier validAddress(address addr) {
        if (addr == address(0)) {
            revert InvalidAddress(addr);
        }
        _;
    }
    
    /**
     * @dev æ£€æŸ¥é‡‘é¢æœ‰æ•ˆæ€§
     */
    modifier validAmount(uint256 amount) {
        if (amount == 0) {
            revert InvalidAmount(amount);
        }
        _;
    }
    
    /**
     * @dev æ£€æŸ¥æˆªæ­¢æ—¶é—´
     */
    modifier beforeDeadline(uint256 deadline) {
        if (block.timestamp > deadline) {
            revert DeadlineExceeded(deadline, block.timestamp);
        }
        _;
    }
    
    // ==================== æ„é€ å‡½æ•° ====================
    
    constructor(uint256 initialSupply) {
        _owner = msg.sender;
        _totalSupply = initialSupply;
        _balances[msg.sender] = initialSupply;
        _paused = false;
    }
    
    // ==================== æ ¸å¿ƒåŠŸèƒ½ ====================
    
    /**
     * @dev å®‰å…¨è½¬è´¦å‡½æ•°
     * @param to æ¥æ”¶åœ°å€
     * @param amount è½¬è´¦é‡‘é¢
     * @param deadline æˆªæ­¢æ—¶é—´
     */
    function safeTransfer(
        address to,
        uint256 amount,
        uint256 deadline
    ) 
        external 
        whenNotPaused
        validAddress(to)
        validAmount(amount)
        beforeDeadline(deadline)
    {
        address from = msg.sender;
        uint256 fromBalance = _balances[from];
        
        // ä½¿ç”¨è‡ªå®šä¹‰é”™è¯¯æä¾›è¯¦ç»†ä¿¡æ¯
        if (fromBalance < amount) {
            revert InsufficientBalance(fromBalance, amount);
        }
        
        // æ‰§è¡Œè½¬è´¦
        bool success = _executeTransfer(from, to, amount);
        
        if (!success) {
            revert TransferFailed(from, to, amount);
        }
    }
    
    /**
     * @dev æ‰¹é‡è½¬è´¦å‡½æ•°
     * @param recipients æ¥æ”¶è€…æ•°ç»„
     * @param amounts é‡‘é¢æ•°ç»„
     */
    function batchTransfer(
        address[] calldata recipients,
        uint256[] calldata amounts
    ) external whenNotPaused {
        require(recipients.length == amounts.length, "Arrays length mismatch");
        require(recipients.length <= 100, "Too many recipients");
        
        address from = msg.sender;
        uint256 totalAmount = 0;
        
        // é¢„å…ˆè®¡ç®—æ€»é‡‘é¢
        for (uint256 i = 0; i < amounts.length; i++) {
            if (amounts[i] == 0) {
                revert InvalidAmount(amounts[i]);
            }
            totalAmount += amounts[i];
        }
        
        // æ£€æŸ¥æ€»ä½™é¢
        uint256 fromBalance = _balances[from];
        if (fromBalance < totalAmount) {
            revert InsufficientBalance(fromBalance, totalAmount);
        }
        
        // æ‰§è¡Œæ‰¹é‡è½¬è´¦
        for (uint256 i = 0; i < recipients.length; i++) {
            address to = recipients[i];
            uint256 amount = amounts[i];
            
            if (to == address(0)) {
                // è®°å½•é”™è¯¯ä½†ç»§ç»­æ‰§è¡Œ
                emit ErrorLogged("InvalidAddress", "Skipping zero address", from);
                continue;
            }
            
            bool success = _executeTransfer(from, to, amount);
            
            if (!success) {
                // è®°å½•å¤±è´¥ä½†ç»§ç»­æ‰§è¡Œå…¶ä»–è½¬è´¦
                emit ErrorLogged("TransferFailed", "Individual transfer failed", from);
            }
        }
    }
    
    /**
     * @dev å†…éƒ¨è½¬è´¦æ‰§è¡Œå‡½æ•°
     * @param from å‘é€åœ°å€
     * @param to æ¥æ”¶åœ°å€
     * @param amount è½¬è´¦é‡‘é¢
     * @return success æ˜¯å¦æˆåŠŸ
     */
    function _executeTransfer(
        address from,
        address to,
        uint256 amount
    ) internal returns (bool success) {
        try this._internalTransfer(from, to, amount) {
            return true;
        } catch Error(string memory reason) {
            // æ•è·requireé”™è¯¯
            emit ErrorLogged("RequireError", reason, from);
            return false;
        } catch Panic(uint errorCode) {
            // æ•è·panicé”™è¯¯
            emit ErrorLogged("PanicError", _getPanicReason(errorCode), from);
            return false;
        } catch (bytes memory lowLevelData) {
            // æ•è·ä½çº§é”™è¯¯
            emit ErrorLogged("LowLevelError", "Unknown error occurred", from);
            return false;
        }
    }
    
    /**
     * @dev å†…éƒ¨è½¬è´¦å‡½æ•°ï¼ˆå¯èƒ½æŠ›å‡ºå¼‚å¸¸ï¼‰
     * @param from å‘é€åœ°å€
     * @param to æ¥æ”¶åœ°å€
     * @param amount è½¬è´¦é‡‘é¢
     */
    function _internalTransfer(
        address from,
        address to,
        uint256 amount
    ) external {
        require(msg.sender == address(this), "Internal function");
        
        // æ‰§è¡Œè½¬è´¦é€»è¾‘
        _balances[from] -= amount;
        _balances[to] += amount;
        
        emit Transfer(from, to, amount);
    }
    
    /**
     * @dev è·å–panicé”™è¯¯åŸå› 
     * @param errorCode é”™è¯¯ä»£ç 
     * @return reason é”™è¯¯åŸå› 
     */
    function _getPanicReason(uint errorCode) internal pure returns (string memory reason) {
        if (errorCode == 0x01) {
            return "Assertion failed";
        } else if (errorCode == 0x11) {
            return "Arithmetic overflow/underflow";
        } else if (errorCode == 0x12) {
            return "Division by zero";
        } else if (errorCode == 0x21) {
            return "Invalid enum value";
        } else if (errorCode == 0x22) {
            return "Invalid storage byte array access";
        } else if (errorCode == 0x31) {
            return "Pop on empty array";
        } else if (errorCode == 0x32) {
            return "Array index out of bounds";
        } else if (errorCode == 0x41) {
            return "Out of memory";
        } else if (errorCode == 0x51) {
            return "Invalid function call";
        } else {
            return "Unknown panic";
        }
    }
    
    // ==================== é”™è¯¯æ¢å¤ ====================
    
    /**
     * @dev ç´§æ€¥æš‚åœåˆçº¦
     */
    function emergencyPause() external onlyOwner {
        _paused = true;
        emit RecoveryExecuted("EmergencyPause", msg.sender);
    }
    
    /**
     * @dev æ¢å¤åˆçº¦è¿è¡Œ
     */
    function unpause() external onlyOwner {
        _paused = false;
        emit RecoveryExecuted("Unpause", msg.sender);
    }
    
    /**
     * @dev ç´§æ€¥æå–èµ„é‡‘
     * @param token ä»£å¸åœ°å€ï¼ˆaddress(0)è¡¨ç¤ºETHï¼‰
     * @param amount æå–é‡‘é¢
     */
    function emergencyWithdraw(address token, uint256 amount) external onlyOwner {
        if (token == address(0)) {
            // æå–ETH
            (bool success, ) = payable(_owner).call{value: amount}("");
            require(success, "ETH transfer failed");
        } else {
            // æå–ERC20ä»£å¸
            (bool success, bytes memory data) = token.call(
                abi.encodeWithSignature("transfer(address,uint256)", _owner, amount)
            );
            require(success && (data.length == 0 || abi.decode(data, (bool))), "Token transfer failed");
        }
        
        emit RecoveryExecuted("EmergencyWithdraw", msg.sender);
    }
    
    /**
     * @dev ä¿®å¤æŸåçš„ä½™é¢
     * @param account è´¦æˆ·åœ°å€
     * @param correctBalance æ­£ç¡®çš„ä½™é¢
     */
    function fixBalance(address account, uint256 correctBalance) external onlyOwner {
        require(_paused, "Contract must be paused");
        
        uint256 oldBalance = _balances[account];
        _balances[account] = correctBalance;
        
        emit RecoveryExecuted(
            string(abi.encodePacked("FixBalance:", _addressToString(account))),
            msg.sender
        );
    }
    
    // ==================== è¾…åŠ©å‡½æ•° ====================
    
    /**
     * @dev å°†åœ°å€è½¬æ¢ä¸ºå­—ç¬¦ä¸²
     * @param addr åœ°å€
     * @return str å­—ç¬¦ä¸²è¡¨ç¤º
     */
    function _addressToString(address addr) internal pure returns (string memory str) {
        bytes32 value = bytes32(uint256(uint160(addr)));
        bytes memory alphabet = "0123456789abcdef";
        bytes memory result = new bytes(42);
        result[0] = '0';
        result[1] = 'x';
        
        for (uint256 i = 0; i < 20; i++) {
            result[2 + i * 2] = alphabet[uint8(value[i + 12] >> 4)];
            result[3 + i * 2] = alphabet[uint8(value[i + 12] & 0x0f)];
        }
        
        return string(result);
    }
    
    // ==================== æŸ¥è¯¢å‡½æ•° ====================
    
    /**
     * @dev è·å–ä½™é¢
     * @param account è´¦æˆ·åœ°å€
     * @return balance ä½™é¢
     */
    function balanceOf(address account) external view returns (uint256 balance) {
        return _balances[account];
    }
    
    /**
     * @dev è·å–åˆçº¦çŠ¶æ€
     * @return paused æ˜¯å¦æš‚åœ
     * @return owner æ‰€æœ‰è€…åœ°å€
     * @return totalSupply æ€»ä¾›åº”é‡
     */
    function getContractStatus() 
        external 
        view 
        returns (bool paused, address owner, uint256 totalSupply) 
    {
        return (_paused, _owner, _totalSupply);
    }
}
```

---

## ğŸ’¡ å­¦ä¹ å¿ƒå¾—ä¸æ€»ç»“

### ä»£ç è´¨é‡çš„é‡è¦æ€§

1. **å¯ç»´æŠ¤æ€§**
   - æ¸…æ™°çš„ä»£ç ç»“æ„å’Œå‘½åè§„èŒƒ
   - å®Œå–„çš„æ³¨é‡Šå’Œæ–‡æ¡£
   - æ¨¡å—åŒ–çš„è®¾è®¡æ€è·¯
   - ä¸€è‡´çš„ç¼–ç é£æ ¼

2. **å¯é æ€§**
   - å…¨é¢çš„é”™è¯¯å¤„ç†æœºåˆ¶
   - å……åˆ†çš„è¾¹ç•Œæ¡ä»¶æ£€æŸ¥
   - å®Œæ•´çš„æµ‹è¯•è¦†ç›–
   - ä¸¥æ ¼çš„ä»£ç å®¡æŸ¥æµç¨‹

3. **å®‰å…¨æ€§**
   - é˜²èŒƒå¸¸è§çš„å®‰å…¨æ¼æ´
   - å®æ–½æœ€å°æƒé™åŸåˆ™
   - ä½¿ç”¨ç»è¿‡éªŒè¯çš„è®¾è®¡æ¨¡å¼
   - å®šæœŸè¿›è¡Œå®‰å…¨å®¡è®¡

### è´¨é‡ä¿è¯å®è·µ

1. **å¼€å‘é˜¶æ®µ**
   - ä½¿ç”¨é™æ€åˆ†æå·¥å…·
   - ç¼–å†™å•å…ƒæµ‹è¯•å’Œé›†æˆæµ‹è¯•
   - è¿›è¡Œä»£ç å®¡æŸ¥
   - éµå¾ªç¼–ç è§„èŒƒ

2. **æµ‹è¯•é˜¶æ®µ**
   - åŠŸèƒ½æµ‹è¯•ï¼šéªŒè¯ä¸šåŠ¡é€»è¾‘æ­£ç¡®æ€§
   - æ€§èƒ½æµ‹è¯•ï¼šç¡®ä¿ç³»ç»Ÿæ€§èƒ½æ»¡è¶³è¦æ±‚
   - å®‰å…¨æµ‹è¯•ï¼šå‘ç°æ½œåœ¨çš„å®‰å…¨é£é™©
   - å…¼å®¹æ€§æµ‹è¯•ï¼šç¡®ä¿è·¨å¹³å°å…¼å®¹æ€§

3. **éƒ¨ç½²é˜¶æ®µ**
   - æ¸è¿›å¼éƒ¨ç½²ç­–ç•¥
   - å®æ—¶ç›‘æ§å’Œå‘Šè­¦
   - å¿«é€Ÿå›æ»šæœºåˆ¶
   - æŒç»­æ€§èƒ½ä¼˜åŒ–

### ç»†èŠ‚ä¼˜åŒ–å¿ƒå¾—

1. **Gasä¼˜åŒ–**
   - æ¯ä¸€ä¸ªæ“ä½œéƒ½è¦è€ƒè™‘Gasæˆæœ¬
   - å­˜å‚¨æ“ä½œæ˜¯æœ€æ˜‚è´µçš„ï¼Œè¦è°¨æ…ä½¿ç”¨
   - åˆç†ä½¿ç”¨å†…å­˜å’Œcalldata
   - é¿å…ä¸å¿…è¦çš„è®¡ç®—å’Œå­˜å‚¨

2. **é”™è¯¯å¤„ç†**
   - ä½¿ç”¨è‡ªå®šä¹‰é”™è¯¯èŠ‚çœGas
   - æä¾›æœ‰æ„ä¹‰çš„é”™è¯¯ä¿¡æ¯
   - å®ç°ä¼˜é›…çš„é”™è¯¯æ¢å¤æœºåˆ¶
   - è®°å½•é”™è¯¯æ—¥å¿—ä¾¿äºè°ƒè¯•

3. **ä»£ç ç»„ç»‡**
   - æŒ‰åŠŸèƒ½æ¨¡å—ç»„ç»‡ä»£ç 
   - ä½¿ç”¨æ¥å£å®šä¹‰æ ‡å‡†
   - å®ç°å¯å‡çº§çš„åˆçº¦æ¶æ„
   - ä¿æŒä»£ç çš„ç®€æ´æ€§

### æœªæ¥å‘å±•æ–¹å‘

1. **è‡ªåŠ¨åŒ–è´¨é‡ä¿è¯**
   - AIè¾…åŠ©ä»£ç å®¡æŸ¥
   - è‡ªåŠ¨åŒ–æµ‹è¯•ç”Ÿæˆ
   - æ™ºèƒ½æ¼æ´æ£€æµ‹
   - æŒç»­é›†æˆ/æŒç»­éƒ¨ç½²

2. **å½¢å¼åŒ–éªŒè¯**
   - æ•°å­¦è¯æ˜çš„æ­£ç¡®æ€§
   - è‡ªåŠ¨åŒ–éªŒè¯å·¥å…·
   - è§„çº¦é©±åŠ¨å¼€å‘
   - é›¶ç¼ºé™·è½¯ä»¶ç›®æ ‡

3. **æ€§èƒ½ä¼˜åŒ–**
   - ç¼–è¯‘å™¨ä¼˜åŒ–æŠ€æœ¯
   - è¿è¡Œæ—¶ä¼˜åŒ–
   - ç¡¬ä»¶åŠ é€Ÿ
   - å¹¶è¡Œå¤„ç†èƒ½åŠ›

### ä¸ªäººæˆé•¿æ„Ÿæ‚Ÿ

é€šè¿‡æ·±å…¥å­¦ä¹ ä»£ç è´¨é‡ä¿è¯å’Œç»†èŠ‚ä¼˜åŒ–ï¼Œæˆ‘æ·±åˆ»è®¤è¯†åˆ°"ç»†èŠ‚å†³å®šæˆè´¥"è¿™å¥è¯åœ¨è½¯ä»¶å¼€å‘ä¸­çš„é‡è¦æ€§ã€‚æ¯ä¸€è¡Œä»£ç ã€æ¯ä¸€ä¸ªå‡½æ•°ã€æ¯ä¸€ä¸ªè®¾è®¡å†³ç­–éƒ½å¯èƒ½å½±å“æ•´ä¸ªç³»ç»Ÿçš„è´¨é‡å’Œæ€§èƒ½ã€‚

è´¨é‡ä¸æ˜¯ä¸€è¹´è€Œå°±çš„ï¼Œè€Œæ˜¯éœ€è¦åœ¨å¼€å‘è¿‡ç¨‹ä¸­æŒç»­å…³æ³¨å’Œæ”¹è¿›çš„ã€‚ä»éœ€æ±‚åˆ†æåˆ°è®¾è®¡å®ç°ï¼Œä»æµ‹è¯•éªŒè¯åˆ°éƒ¨ç½²ç»´æŠ¤ï¼Œæ¯ä¸ªç¯èŠ‚éƒ½éœ€è¦ä¸¥æ ¼æŠŠæ§è´¨é‡æ ‡å‡†ã€‚

åœ¨æ™ºèƒ½åˆçº¦å¼€å‘ä¸­ï¼Œè´¨é‡é—®é¢˜å¯èƒ½å¯¼è‡´èµ„é‡‘æŸå¤±ï¼Œå› æ­¤æ›´éœ€è¦æˆ‘ä»¬ä»¥ä¸¥è°¨çš„æ€åº¦å¯¹å¾…æ¯ä¸€ä¸ªç»†èŠ‚ã€‚é€šè¿‡å»ºç«‹å®Œå–„çš„è´¨é‡ä¿è¯ä½“ç³»ï¼Œæˆ‘ä»¬å¯ä»¥æœ€å¤§ç¨‹åº¦åœ°é™ä½é£é™©ï¼Œæé«˜ç³»ç»Ÿçš„å¯é æ€§å’Œå®‰å…¨æ€§ã€‚

æœªæ¥ï¼Œæˆ‘å°†ç»§ç»­æ·±å…¥ç ”ç©¶ä»£ç è´¨é‡ä¿è¯æŠ€æœ¯ï¼Œæ¢ç´¢æ›´åŠ é«˜æ•ˆå’Œæ™ºèƒ½çš„è´¨é‡ç®¡ç†æ–¹æ³•ï¼Œä¸ºæ„å»ºæ›´åŠ å®‰å…¨ã€å¯é çš„æ™ºèƒ½åˆçº¦ç³»ç»Ÿè´¡çŒ®è‡ªå·±çš„åŠ›é‡ã€‚