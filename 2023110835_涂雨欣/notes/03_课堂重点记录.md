# 课堂重点记录

**学生**：涂雨欣  
**学号**：2023110835  
**日期**：2024年9月-12月  
**课程**：区块链智能合约开发  
**学习特色**：社交功能与社区治理

---

## 学习目标与个人定位

作为一名专注于社交功能与社区治理的学生，我的学习重点包括：
- 深入理解去中心化社交网络的架构设计
- 掌握社区治理机制和DAO的实现原理
- 学习社交代币经济学和激励机制设计
- 研究用户身份认证和隐私保护技术
- 探索社交图谱和关系网络的区块链应用

---

## 第一周：去中心化社交网络基础

### 课堂重点

#### 1. 社交网络核心合约
```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

/**
 * @title DecentralizedSocialNetwork
 * @dev 去中心化社交网络核心合约
 * @author 涂雨欣
 */
contract DecentralizedSocialNetwork {
    // ✅ 状态变量
    
    /// @notice 用户信息映射
    mapping(address => UserProfile) public userProfiles;
    
    /// @notice 帖子信息映射
    mapping(uint256 => Post) public posts;
    
    /// @notice 关注关系映射
    mapping(address => mapping(address => bool)) public following;
    
    /// @notice 用户关注者数量
    mapping(address => uint256) public followerCount;
    
    /// @notice 用户关注数量
    mapping(address => uint256) public followingCount;
    
    /// @notice 帖子计数器
    uint256 public postCounter;
    
    /// @notice 平台管理员
    address public admin;
    
    /// @notice 内容审核员
    mapping(address => bool) public moderators;
    
    // ✅ 结构体定义
    
    struct UserProfile {
        string username;          // 用户名
        string displayName;       // 显示名称
        string bio;              // 个人简介
        string avatarHash;       // 头像IPFS哈希
        string coverHash;        // 封面IPFS哈希
        uint256 joinTime;        // 加入时间
        uint256 reputation;      // 声誉值
        bool isVerified;         // 是否认证
        bool isActive;           // 是否活跃
        UserType userType;       // 用户类型
    }
    
    struct Post {
        uint256 id;              // 帖子ID
        address author;          // 作者地址
        string contentHash;      // 内容IPFS哈希
        string[] mediaHashes;    // 媒体文件哈希数组
        uint256 timestamp;       // 发布时间
        uint256 likes;           // 点赞数
        uint256 shares;          // 分享数
        uint256 comments;        // 评论数
        PostType postType;       // 帖子类型
        PostStatus status;       // 帖子状态
        uint256 replyTo;         // 回复的帖子ID（0表示原创）
        string[] tags;           // 标签数组
    }
    
    enum UserType {
        Regular,    // 普通用户
        Creator,    // 内容创作者
        Influencer, // 影响者
        Organization // 组织
    }
    
    enum PostType {
        Text,       // 文本
        Image,      // 图片
        Video,      // 视频
        Audio,      // 音频
        Poll,       // 投票
        Article     // 文章
    }
    
    enum PostStatus {
        Active,     // 活跃
        Hidden,     // 隐藏
        Reported,   // 被举报
        Removed     // 已删除
    }
    
    // ✅ 事件定义
    
    event UserRegistered(
        address indexed user,
        string username,
        uint256 timestamp
    );
    
    event PostCreated(
        uint256 indexed postId,
        address indexed author,
        PostType postType,
        uint256 timestamp
    );
    
    event UserFollowed(
        address indexed follower,
        address indexed following,
        uint256 timestamp
    );
    
    event PostLiked(
        uint256 indexed postId,
        address indexed user,
        uint256 timestamp
    );
    
    event PostShared(
        uint256 indexed postId,
        address indexed user,
        uint256 timestamp
    );
    
    event ReputationUpdated(
        address indexed user,
        uint256 oldReputation,
        uint256 newReputation
    );
    
    // ✅ 修饰符
    
    modifier onlyAdmin() {
        require(msg.sender == admin, "Social: Only admin");
        _;
    }
    
    modifier onlyModerator() {
        require(moderators[msg.sender] || msg.sender == admin, "Social: Only moderator");
        _;
    }
    
    modifier onlyRegistered() {
        require(userProfiles[msg.sender].isActive, "Social: User not registered");
        _;
    }
    
    modifier validPost(uint256 postId) {
        require(postId < postCounter, "Social: Invalid post ID");
        require(posts[postId].status == PostStatus.Active, "Social: Post not active");
        _;
    }
    
    // ✅ 构造函数
    
    constructor() {
        admin = msg.sender;
        moderators[msg.sender] = true;
    }
    
    // ✅ 用户管理功能
    
    /// @notice 注册用户
    /// @param username 用户名
    /// @param displayName 显示名称
    /// @param bio 个人简介
    /// @param avatarHash 头像哈希
    function registerUser(
        string calldata username,
        string calldata displayName,
        string calldata bio,
        string calldata avatarHash
    ) external {
        require(!userProfiles[msg.sender].isActive, "Social: User already registered");
        require(bytes(username).length > 0, "Social: Username required");
        require(bytes(username).length <= 32, "Social: Username too long");
        
        userProfiles[msg.sender] = UserProfile({
            username: username,
            displayName: displayName,
            bio: bio,
            avatarHash: avatarHash,
            coverHash: "",
            joinTime: block.timestamp,
            reputation: 100, // 初始声誉值
            isVerified: false,
            isActive: true,
            userType: UserType.Regular
        });
        
        emit UserRegistered(msg.sender, username, block.timestamp);
    }
    
    /// @notice 更新用户资料
    /// @param displayName 显示名称
    /// @param bio 个人简介
    /// @param avatarHash 头像哈希
    /// @param coverHash 封面哈希
    function updateProfile(
        string calldata displayName,
        string calldata bio,
        string calldata avatarHash,
        string calldata coverHash
    ) external onlyRegistered {
        UserProfile storage profile = userProfiles[msg.sender];
        
        profile.displayName = displayName;
        profile.bio = bio;
        profile.avatarHash = avatarHash;
        profile.coverHash = coverHash;
    }
    
    /// @notice 关注用户
    /// @param userToFollow 要关注的用户地址
    function followUser(address userToFollow) external onlyRegistered {
        require(userToFollow != msg.sender, "Social: Cannot follow yourself");
        require(userProfiles[userToFollow].isActive, "Social: User not found");
        require(!following[msg.sender][userToFollow], "Social: Already following");
        
        following[msg.sender][userToFollow] = true;
        followerCount[userToFollow]++;
        followingCount[msg.sender]++;
        
        // 增加被关注者的声誉值
        _updateReputation(userToFollow, 5);
        
        emit UserFollowed(msg.sender, userToFollow, block.timestamp);
    }
    
    /// @notice 取消关注用户
    /// @param userToUnfollow 要取消关注的用户地址
    function unfollowUser(address userToUnfollow) external onlyRegistered {
        require(following[msg.sender][userToUnfollow], "Social: Not following");
        
        following[msg.sender][userToUnfollow] = false;
        followerCount[userToUnfollow]--;
        followingCount[msg.sender]--;
        
        // 减少被取消关注者的声誉值
        _updateReputation(userToUnfollow, -5);
    }
    
    // ✅ 内容发布功能
    
    /// @notice 创建帖子
    /// @param contentHash 内容IPFS哈希
    /// @param mediaHashes 媒体文件哈希数组
    /// @param postType 帖子类型
    /// @param tags 标签数组
    /// @param replyTo 回复的帖子ID（0表示原创）
    function createPost(
        string calldata contentHash,
        string[] calldata mediaHashes,
        PostType postType,
        string[] calldata tags,
        uint256 replyTo
    ) external onlyRegistered returns (uint256) {
        require(bytes(contentHash).length > 0, "Social: Content required");
        require(tags.length <= 10, "Social: Too many tags");
        
        if (replyTo > 0) {
            require(replyTo < postCounter, "Social: Invalid reply target");
            require(posts[replyTo].status == PostStatus.Active, "Social: Cannot reply to inactive post");
        }
        
        uint256 postId = postCounter++;
        
        posts[postId] = Post({
            id: postId,
            author: msg.sender,
            contentHash: contentHash,
            mediaHashes: mediaHashes,
            timestamp: block.timestamp,
            likes: 0,
            shares: 0,
            comments: 0,
            postType: postType,
            status: PostStatus.Active,
            replyTo: replyTo,
            tags: tags
        });
        
        // 如果是回复，增加原帖的评论数
        if (replyTo > 0) {
            posts[replyTo].comments++;
        }
        
        // 增加作者声誉值
        _updateReputation(msg.sender, 10);
        
        emit PostCreated(postId, msg.sender, postType, block.timestamp);
        
        return postId;
    }
    
    /// @notice 点赞帖子
    /// @param postId 帖子ID
    function likePost(uint256 postId) external onlyRegistered validPost(postId) {
        Post storage post = posts[postId];
        
        // 简化实现，不检查重复点赞
        post.likes++;
        
        // 增加作者声誉值
        _updateReputation(post.author, 2);
        
        emit PostLiked(postId, msg.sender, block.timestamp);
    }
    
    /// @notice 分享帖子
    /// @param postId 帖子ID
    function sharePost(uint256 postId) external onlyRegistered validPost(postId) {
        Post storage post = posts[postId];
        
        post.shares++;
        
        // 增加作者声誉值
        _updateReputation(post.author, 3);
        
        emit PostShared(postId, msg.sender, block.timestamp);
    }
    
    // ✅ 内容审核功能
    
    /// @notice 举报帖子
    /// @param postId 帖子ID
    /// @param reason 举报原因
    function reportPost(
        uint256 postId,
        string calldata reason
    ) external onlyRegistered validPost(postId) {
        posts[postId].status = PostStatus.Reported;
        
        // 这里可以添加举报记录逻辑
        // 实际实现中需要更复杂的举报处理机制
    }
    
    /// @notice 审核帖子
    /// @param postId 帖子ID
    /// @param approved 是否通过审核
    function moderatePost(
        uint256 postId,
        bool approved
    ) external onlyModerator {
        require(postId < postCounter, "Social: Invalid post ID");
        
        if (approved) {
            posts[postId].status = PostStatus.Active;
        } else {
            posts[postId].status = PostStatus.Removed;
            // 减少作者声誉值
            _updateReputation(posts[postId].author, -20);
        }
    }
    
    // ✅ 声誉系统
    
    /// @notice 更新用户声誉值
    /// @param user 用户地址
    /// @param change 声誉变化值（可为负数）
    function _updateReputation(address user, int256 change) internal {
        UserProfile storage profile = userProfiles[user];
        uint256 oldReputation = profile.reputation;
        
        if (change > 0) {
            profile.reputation += uint256(change);
        } else if (change < 0) {
            uint256 decrease = uint256(-change);
            if (profile.reputation > decrease) {
                profile.reputation -= decrease;
            } else {
                profile.reputation = 0;
            }
        }
        
        // 根据声誉值更新用户类型
        if (profile.reputation >= 1000) {
            profile.userType = UserType.Influencer;
        } else if (profile.reputation >= 500) {
            profile.userType = UserType.Creator;
        }
        
        emit ReputationUpdated(user, oldReputation, profile.reputation);
    }
    
    // ✅ 管理功能
    
    /// @notice 添加审核员
    /// @param moderator 审核员地址
    function addModerator(address moderator) external onlyAdmin {
        moderators[moderator] = true;
    }
    
    /// @notice 移除审核员
    /// @param moderator 审核员地址
    function removeModerator(address moderator) external onlyAdmin {
        moderators[moderator] = false;
    }
    
    /// @notice 认证用户
    /// @param user 用户地址
    function verifyUser(address user) external onlyAdmin {
        require(userProfiles[user].isActive, "Social: User not found");
        userProfiles[user].isVerified = true;
    }
    
    // ✅ 查询功能
    
    /// @notice 获取用户资料
    /// @param user 用户地址
    /// @return 用户资料
    function getUserProfile(address user) 
        external 
        view 
        returns (UserProfile memory) 
    {
        return userProfiles[user];
    }
    
    /// @notice 获取帖子信息
    /// @param postId 帖子ID
    /// @return 帖子信息
    function getPost(uint256 postId) 
        external 
        view 
        returns (Post memory) 
    {
        return posts[postId];
    }
    
    /// @notice 检查关注关系
    /// @param follower 关注者
    /// @param followed 被关注者
    /// @return 是否关注
    function isFollowing(
        address follower,
        address followed
    ) external view returns (bool) {
        return following[follower][followed];
    }
    
    /// @notice 获取用户统计信息
    /// @param user 用户地址
    /// @return followers 关注者数量
    /// @return followings 关注数量
    /// @return reputation 声誉值
    function getUserStats(address user) 
        external 
        view 
        returns (uint256 followers, uint256 followings, uint256 reputation) 
    {
        return (
            followerCount[user],
            followingCount[user],
            userProfiles[user].reputation
        );
    }
}
```

#### 2. 社交代币经济系统
```solidity
/**
 * @title SocialToken
 * @dev 社交代币合约，用于激励社区参与
 */
contract SocialToken {
    // ✅ 状态变量
    
    /// @notice 代币基本信息
    string public name = "Social Network Token";
    string public symbol = "SNT";
    uint8 public decimals = 18;
    uint256 public totalSupply;
    
    /// @notice 余额映射
    mapping(address => uint256) public balanceOf;
    
    /// @notice 授权映射
    mapping(address => mapping(address => uint256)) public allowance;
    
    /// @notice 挖矿奖励池
    uint256 public rewardPool;
    
    /// @notice 每日挖矿限额
    mapping(address => mapping(uint256 => uint256)) public dailyMined;
    
    /// @notice 社交网络合约地址
    address public socialNetworkContract;
    
    /// @notice 管理员
    address public admin;
    
    // ✅ 事件定义
    
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    event Mint(address indexed to, uint256 amount, string reason);
    event Burn(address indexed from, uint256 amount);
    
    // ✅ 修饰符
    
    modifier onlyAdmin() {
        require(msg.sender == admin, "Token: Only admin");
        _;
    }
    
    modifier onlySocialContract() {
        require(msg.sender == socialNetworkContract, "Token: Only social contract");
        _;
    }
    
    // ✅ 构造函数
    
    constructor(uint256 _initialSupply) {
        admin = msg.sender;
        totalSupply = _initialSupply * 10**decimals;
        balanceOf[msg.sender] = totalSupply;
        rewardPool = totalSupply / 10; // 10%作为奖励池
    }
    
    // ✅ ERC20基础功能
    
    /// @notice 转账
    /// @param to 接收者
    /// @param value 数量
    /// @return 是否成功
    function transfer(address to, uint256 value) external returns (bool) {
        require(to != address(0), "Token: Invalid recipient");
        require(balanceOf[msg.sender] >= value, "Token: Insufficient balance");
        
        balanceOf[msg.sender] -= value;
        balanceOf[to] += value;
        
        emit Transfer(msg.sender, to, value);
        return true;
    }
    
    /// @notice 授权转账
    /// @param from 发送者
    /// @param to 接收者
    /// @param value 数量
    /// @return 是否成功
    function transferFrom(
        address from,
        address to,
        uint256 value
    ) external returns (bool) {
        require(to != address(0), "Token: Invalid recipient");
        require(balanceOf[from] >= value, "Token: Insufficient balance");
        require(allowance[from][msg.sender] >= value, "Token: Insufficient allowance");
        
        balanceOf[from] -= value;
        balanceOf[to] += value;
        allowance[from][msg.sender] -= value;
        
        emit Transfer(from, to, value);
        return true;
    }
    
    /// @notice 授权
    /// @param spender 被授权者
    /// @param value 授权数量
    /// @return 是否成功
    function approve(address spender, uint256 value) external returns (bool) {
        allowance[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }
    
    // ✅ 挖矿奖励功能
    
    /// @notice 发帖奖励
    /// @param user 用户地址
    /// @param postType 帖子类型
    function rewardForPost(
        address user,
        uint8 postType
    ) external onlySocialContract {
        uint256 reward = _calculatePostReward(postType);
        _mint(user, reward, "Post creation reward");
    }
    
    /// @notice 互动奖励
    /// @param user 用户地址
    /// @param actionType 行为类型（1=点赞，2=分享，3=评论）
    function rewardForInteraction(
        address user,
        uint8 actionType
    ) external onlySocialContract {
        uint256 reward = _calculateInteractionReward(actionType);
        _mint(user, reward, "Interaction reward");
    }
    
    /// @notice 每日签到奖励
    function dailyCheckIn() external {
        uint256 today = block.timestamp / 86400; // 天数
        require(dailyMined[msg.sender][today] == 0, "Token: Already checked in today");
        
        uint256 reward = 10 * 10**decimals; // 10 SNT
        dailyMined[msg.sender][today] = reward;
        
        _mint(msg.sender, reward, "Daily check-in reward");
    }
    
    /// @notice 计算发帖奖励
    /// @param postType 帖子类型
    /// @return 奖励数量
    function _calculatePostReward(uint8 postType) internal pure returns (uint256) {
        if (postType == 0) return 5 * 10**18;  // 文本帖子：5 SNT
        if (postType == 1) return 8 * 10**18;  // 图片帖子：8 SNT
        if (postType == 2) return 15 * 10**18; // 视频帖子：15 SNT
        if (postType == 3) return 10 * 10**18; // 音频帖子：10 SNT
        if (postType == 4) return 12 * 10**18; // 投票帖子：12 SNT
        if (postType == 5) return 20 * 10**18; // 文章帖子：20 SNT
        return 5 * 10**18; // 默认奖励
    }
    
    /// @notice 计算互动奖励
    /// @param actionType 行为类型
    /// @return 奖励数量
    function _calculateInteractionReward(uint8 actionType) internal pure returns (uint256) {
        if (actionType == 1) return 1 * 10**18;  // 点赞：1 SNT
        if (actionType == 2) return 2 * 10**18;  // 分享：2 SNT
        if (actionType == 3) return 3 * 10**18;  // 评论：3 SNT
        return 1 * 10**18; // 默认奖励
    }
    
    /// @notice 铸造代币
    /// @param to 接收者
    /// @param amount 数量
    /// @param reason 原因
    function _mint(address to, uint256 amount, string memory reason) internal {
        require(rewardPool >= amount, "Token: Insufficient reward pool");
        
        balanceOf[to] += amount;
        rewardPool -= amount;
        
        emit Mint(to, amount, reason);
        emit Transfer(address(0), to, amount);
    }
    
    // ✅ 管理功能
    
    /// @notice 设置社交网络合约地址
    /// @param contractAddress 合约地址
    function setSocialNetworkContract(address contractAddress) external onlyAdmin {
        socialNetworkContract = contractAddress;
    }
    
    /// @notice 补充奖励池
    /// @param amount 补充数量
    function replenishRewardPool(uint256 amount) external onlyAdmin {
        require(balanceOf[msg.sender] >= amount, "Token: Insufficient balance");
        
        balanceOf[msg.sender] -= amount;
        rewardPool += amount;
    }
    
    /// @notice 销毁代币
    /// @param amount 销毁数量
    function burn(uint256 amount) external {
        require(balanceOf[msg.sender] >= amount, "Token: Insufficient balance");
        
        balanceOf[msg.sender] -= amount;
        totalSupply -= amount;
        
        emit Burn(msg.sender, amount);
        emit Transfer(msg.sender, address(0), amount);
    }
}
```

### 核心技能掌握
1. **用户身份管理**：去中心化身份认证和资料管理
2. **社交关系网络**：关注、粉丝关系的链上实现
3. **内容发布系统**：多媒体内容的去中心化存储和管理
4. **声誉系统**：基于行为的用户声誉计算和激励
5. **代币经济学**：社交代币的发行、分发和激励机制

### 项目记录
- 实现了完整的去中心化社交网络核心功能
- 设计了基于声誉的用户等级系统
- 开发了社交代币激励机制

---

## 第二周：社区治理与DAO机制

### 课堂重点

#### 1. 社区治理合约
```solidity
/**
 * @title CommunityGovernance
 * @dev 社区治理DAO合约
 */
contract CommunityGovernance {
    // ✅ 状态变量
    
    /// @notice 提案计数器
    uint256 public proposalCounter;
    
    /// @notice 提案映射
    mapping(uint256 => Proposal) public proposals;
    
    /// @notice 投票记录
    mapping(uint256 => mapping(address => Vote)) public votes;
    
    /// @notice 治理代币合约
    IERC20 public governanceToken;
    
    /// @notice 最小提案门槛
    uint256 public proposalThreshold;
    
    /// @notice 投票期间（秒）
    uint256 public votingPeriod;
    
    /// @notice 执行延迟（秒）
    uint256 public executionDelay;
    
    /// @notice 法定人数要求
    uint256 public quorumVotes;
    
    // ✅ 结构体定义
    
    struct Proposal {
        uint256 id;
        address proposer;
        string title;
        string description;
        bytes[] actions;
        address[] targets;
        uint256[] values;
        uint256 startTime;
        uint256 endTime;
        uint256 forVotes;
        uint256 againstVotes;
        uint256 abstainVotes;
        ProposalState state;
        bool executed;
    }
    
    struct Vote {
        bool hasVoted;
        VoteType voteType;
        uint256 weight;
        string reason;
    }
    
    enum ProposalState {
        Pending,
        Active,
        Succeeded,
        Defeated,
        Queued,
        Executed,
        Canceled
    }
    
    enum VoteType {
        Against,
        For,
        Abstain
    }
    
    // ✅ 事件定义
    
    event ProposalCreated(
        uint256 indexed proposalId,
        address indexed proposer,
        string title,
        uint256 startTime,
        uint256 endTime
    );
    
    event VoteCast(
        address indexed voter,
        uint256 indexed proposalId,
        VoteType voteType,
        uint256 weight,
        string reason
    );
    
    event ProposalExecuted(
        uint256 indexed proposalId
    );
    
    event ProposalCanceled(
        uint256 indexed proposalId
    );
    
    // ✅ 修饰符
    
    modifier validProposal(uint256 proposalId) {
        require(proposalId < proposalCounter, "Governance: Invalid proposal");
        _;
    }
    
    // ✅ 构造函数
    
    constructor(
        address _governanceToken,
        uint256 _proposalThreshold,
        uint256 _votingPeriod,
        uint256 _executionDelay,
        uint256 _quorumVotes
    ) {
        governanceToken = IERC20(_governanceToken);
        proposalThreshold = _proposalThreshold;
        votingPeriod = _votingPeriod;
        executionDelay = _executionDelay;
        quorumVotes = _quorumVotes;
    }
    
    // ✅ 核心治理功能
    
    /// @notice 创建提案
    /// @param title 提案标题
    /// @param description 提案描述
    /// @param targets 目标合约地址数组
    /// @param values 调用值数组
    /// @param actions 调用数据数组
    function createProposal(
        string calldata title,
        string calldata description,
        address[] calldata targets,
        uint256[] calldata values,
        bytes[] calldata actions
    ) external returns (uint256) {
        require(
            governanceToken.balanceOf(msg.sender) >= proposalThreshold,
            "Governance: Insufficient tokens to propose"
        );
        require(targets.length == values.length, "Governance: Length mismatch");
        require(targets.length == actions.length, "Governance: Length mismatch");
        require(targets.length > 0, "Governance: Empty proposal");
        
        uint256 proposalId = proposalCounter++;
        uint256 startTime = block.timestamp;
        uint256 endTime = startTime + votingPeriod;
        
        proposals[proposalId] = Proposal({
            id: proposalId,
            proposer: msg.sender,
            title: title,
            description: description,
            actions: actions,
            targets: targets,
            values: values,
            startTime: startTime,
            endTime: endTime,
            forVotes: 0,
            againstVotes: 0,
            abstainVotes: 0,
            state: ProposalState.Active,
            executed: false
        });
        
        emit ProposalCreated(
            proposalId,
            msg.sender,
            title,
            startTime,
            endTime
        );
        
        return proposalId;
    }
    
    /// @notice 投票
    /// @param proposalId 提案ID
    /// @param voteType 投票类型
    /// @param reason 投票理由
    function vote(
        uint256 proposalId,
        VoteType voteType,
        string calldata reason
    ) external validProposal(proposalId) {
        Proposal storage proposal = proposals[proposalId];
        require(proposal.state == ProposalState.Active, "Governance: Proposal not active");
        require(block.timestamp <= proposal.endTime, "Governance: Voting ended");
        require(!votes[proposalId][msg.sender].hasVoted, "Governance: Already voted");
        
        uint256 weight = governanceToken.balanceOf(msg.sender);
        require(weight > 0, "Governance: No voting power");
        
        votes[proposalId][msg.sender] = Vote({
            hasVoted: true,
            voteType: voteType,
            weight: weight,
            reason: reason
        });
        
        if (voteType == VoteType.For) {
            proposal.forVotes += weight;
        } else if (voteType == VoteType.Against) {
            proposal.againstVotes += weight;
        } else {
            proposal.abstainVotes += weight;
        }
        
        emit VoteCast(msg.sender, proposalId, voteType, weight, reason);
    }
    
    /// @notice 执行提案
    /// @param proposalId 提案ID
    function executeProposal(
        uint256 proposalId
    ) external validProposal(proposalId) {
        Proposal storage proposal = proposals[proposalId];
        require(block.timestamp > proposal.endTime, "Governance: Voting not ended");
        require(!proposal.executed, "Governance: Already executed");
        require(proposal.state != ProposalState.Canceled, "Governance: Proposal canceled");
        
        // 检查是否达到法定人数
        uint256 totalVotes = proposal.forVotes + proposal.againstVotes + proposal.abstainVotes;
        require(totalVotes >= quorumVotes, "Governance: Quorum not reached");
        
        // 检查是否通过
        if (proposal.forVotes > proposal.againstVotes) {
            proposal.state = ProposalState.Succeeded;
            
            // 执行提案动作
            for (uint256 i = 0; i < proposal.targets.length; i++) {
                (bool success, ) = proposal.targets[i].call{
                    value: proposal.values[i]
                }(proposal.actions[i]);
                require(success, "Governance: Execution failed");
            }
            
            proposal.executed = true;
            proposal.state = ProposalState.Executed;
            
            emit ProposalExecuted(proposalId);
        } else {
            proposal.state = ProposalState.Defeated;
        }
    }
    
    /// @notice 取消提案
    /// @param proposalId 提案ID
    function cancelProposal(
        uint256 proposalId
    ) external validProposal(proposalId) {
        Proposal storage proposal = proposals[proposalId];
        require(
            msg.sender == proposal.proposer,
            "Governance: Only proposer can cancel"
        );
        require(
            proposal.state == ProposalState.Active || proposal.state == ProposalState.Pending,
            "Governance: Cannot cancel"
        );
        
        proposal.state = ProposalState.Canceled;
        
        emit ProposalCanceled(proposalId);
    }
    
    // ✅ 查询功能
    
    /// @notice 获取提案信息
    /// @param proposalId 提案ID
    /// @return 提案信息
    function getProposal(
        uint256 proposalId
    ) external view validProposal(proposalId) returns (Proposal memory) {
        return proposals[proposalId];
    }
    
    /// @notice 获取投票信息
    /// @param proposalId 提案ID
    /// @param voter 投票者地址
    /// @return 投票信息
    function getVote(
        uint256 proposalId,
        address voter
    ) external view returns (Vote memory) {
        return votes[proposalId][voter];
    }
    
    /// @notice 获取提案状态
    /// @param proposalId 提案ID
    /// @return 提案状态
    function getProposalState(
        uint256 proposalId
    ) external view validProposal(proposalId) returns (ProposalState) {
        return proposals[proposalId].state;
    }
}

// ERC20接口
interface IERC20 {
    function balanceOf(address account) external view returns (uint256);
    function transfer(address to, uint256 amount) external returns (bool);
}
```

### 核心技能掌握
1. **DAO治理机制**：去中心化自治组织的设计和实现
2. **提案系统**：社区提案的创建、投票和执行流程
3. **投票权重计算**：基于代币持有量的投票权分配
4. **法定人数机制**：确保治理决策的合法性和有效性
5. **执行机制**：自动化执行通过的治理提案

### 项目记录
- 实现了完整的DAO治理框架
- 设计了灵活的提案创建和投票机制
- 开发了自动化的提案执行系统

---

## 第三周：社交图谱与关系网络

### 课堂重点

#### 1. 社交图谱分析合约
```solidity
/**
 * @title SocialGraph
 * @dev 社交图谱分析和关系网络合约
 */
contract SocialGraph {
    // ✅ 状态变量
    
    /// @notice 用户关系映射
    mapping(address => mapping(address => RelationshipType)) public relationships;
    
    /// @notice 用户影响力分数
    mapping(address => uint256) public influenceScore;
    
    /// @notice 社交圈子
    mapping(uint256 => Circle) public circles;
    
    /// @notice 用户加入的圈子
    mapping(address => uint256[]) public userCircles;
    
    /// @notice 圈子计数器
    uint256 public circleCounter;
    
    /// @notice 推荐算法权重
    mapping(string => uint256) public algorithmWeights;
    
    // ✅ 结构体定义
    
    struct Circle {
        uint256 id;
        string name;
        string description;
        address creator;
        address[] members;
        uint256 createdTime;
        bool isPrivate;
        uint256 memberLimit;
        CircleType circleType;
    }
    
    enum RelationshipType {
        None,
        Following,
        Friend,
        Blocked,
        Muted
    }
    
    enum CircleType {
        General,
        Interest,
        Professional,
        Geographic,
        Temporary
    }
    
    // ✅ 事件定义
    
    event RelationshipUpdated(
        address indexed user1,
        address indexed user2,
        RelationshipType relationshipType
    );
    
    event CircleCreated(
        uint256 indexed circleId,
        address indexed creator,
        string name
    );
    
    event UserJoinedCircle(
        address indexed user,
        uint256 indexed circleId
    );
    
    event InfluenceScoreUpdated(
        address indexed user,
        uint256 oldScore,
        uint256 newScore
    );
    
    // ✅ 核心功能
    
    /// @notice 更新用户关系
    /// @param target 目标用户
    /// @param relationshipType 关系类型
    function updateRelationship(
        address target,
        RelationshipType relationshipType
    ) external {
        require(target != msg.sender, "Graph: Cannot relate to yourself");
        require(target != address(0), "Graph: Invalid target");
        
        RelationshipType oldRelation = relationships[msg.sender][target];
        relationships[msg.sender][target] = relationshipType;
        
        // 更新影响力分数
        if (relationshipType == RelationshipType.Following && oldRelation != RelationshipType.Following) {
            _updateInfluenceScore(target, 10);
        } else if (oldRelation == RelationshipType.Following && relationshipType != RelationshipType.Following) {
            _updateInfluenceScore(target, -10);
        }
        
        emit RelationshipUpdated(msg.sender, target, relationshipType);
    }
    
    /// @notice 创建社交圈子
    /// @param name 圈子名称
    /// @param description 圈子描述
    /// @param isPrivate 是否私有
    /// @param memberLimit 成员限制
    /// @param circleType 圈子类型
    function createCircle(
        string calldata name,
        string calldata description,
        bool isPrivate,
        uint256 memberLimit,
        CircleType circleType
    ) external returns (uint256) {
        require(bytes(name).length > 0, "Graph: Name required");
        require(memberLimit > 0, "Graph: Invalid member limit");
        
        uint256 circleId = circleCounter++;
        
        address[] memory initialMembers = new address[](1);
        initialMembers[0] = msg.sender;
        
        circles[circleId] = Circle({
            id: circleId,
            name: name,
            description: description,
            creator: msg.sender,
            members: initialMembers,
            createdTime: block.timestamp,
            isPrivate: isPrivate,
            memberLimit: memberLimit,
            circleType: circleType
        });
        
        userCircles[msg.sender].push(circleId);
        
        emit CircleCreated(circleId, msg.sender, name);
        
        return circleId;
    }
    
    /// @notice 加入圈子
    /// @param circleId 圈子ID
    function joinCircle(uint256 circleId) external {
        require(circleId < circleCounter, "Graph: Invalid circle");
        
        Circle storage circle = circles[circleId];
        require(circle.members.length < circle.memberLimit, "Graph: Circle full");
        require(!_isMemberOfCircle(msg.sender, circleId), "Graph: Already member");
        
        // 如果是私有圈子，需要创建者批准（简化实现）
        if (circle.isPrivate) {
            require(msg.sender == circle.creator, "Graph: Private circle");
        }
        
        circle.members.push(msg.sender);
        userCircles[msg.sender].push(circleId);
        
        emit UserJoinedCircle(msg.sender, circleId);
    }
    
    /// @notice 离开圈子
    /// @param circleId 圈子ID
    function leaveCircle(uint256 circleId) external {
        require(_isMemberOfCircle(msg.sender, circleId), "Graph: Not a member");
        
        Circle storage circle = circles[circleId];
        
        // 从圈子成员中移除
        for (uint256 i = 0; i < circle.members.length; i++) {
            if (circle.members[i] == msg.sender) {
                circle.members[i] = circle.members[circle.members.length - 1];
                circle.members.pop();
                break;
            }
        }
        
        // 从用户圈子列表中移除
        uint256[] storage userCircleList = userCircles[msg.sender];
        for (uint256 i = 0; i < userCircleList.length; i++) {
            if (userCircleList[i] == circleId) {
                userCircleList[i] = userCircleList[userCircleList.length - 1];
                userCircleList.pop();
                break;
            }
        }
    }
    
    /// @notice 计算用户间的关系强度
    /// @param user1 用户1
    /// @param user2 用户2
    /// @return 关系强度分数
    function calculateRelationshipStrength(
        address user1,
        address user2
    ) external view returns (uint256) {
        if (user1 == user2) return 0;
        
        uint256 strength = 0;
        
        // 直接关系权重
        RelationshipType relation1 = relationships[user1][user2];
        RelationshipType relation2 = relationships[user2][user1];
        
        if (relation1 == RelationshipType.Friend && relation2 == RelationshipType.Friend) {
            strength += 100; // 互为好友
        } else if (relation1 == RelationshipType.Following || relation2 == RelationshipType.Following) {
            strength += 50; // 单向关注
        }
        
        // 共同圈子权重
        uint256 commonCircles = _getCommonCirclesCount(user1, user2);
        strength += commonCircles * 20;
        
        // 影响力差异权重（影响力相近的用户关系更强）
        uint256 influence1 = influenceScore[user1];
        uint256 influence2 = influenceScore[user2];
        uint256 influenceDiff = influence1 > influence2 ? influence1 - influence2 : influence2 - influence1;
        if (influenceDiff < 100) {
            strength += 30;
        } else if (influenceDiff < 500) {
            strength += 10;
        }
        
        return strength;
    }
    
    /// @notice 获取用户推荐
    /// @param user 用户地址
    /// @param count 推荐数量
    /// @return 推荐用户列表
    function getUserRecommendations(
        address user,
        uint256 count
    ) external view returns (address[] memory) {
        // 简化的推荐算法实现
        address[] memory recommendations = new address[](count);
        uint256 foundCount = 0;
        
        // 基于共同圈子的推荐
        uint256[] memory userCircleList = userCircles[user];
        for (uint256 i = 0; i < userCircleList.length && foundCount < count; i++) {
            Circle memory circle = circles[userCircleList[i]];
            for (uint256 j = 0; j < circle.members.length && foundCount < count; j++) {
                address candidate = circle.members[j];
                if (candidate != user && relationships[user][candidate] == RelationshipType.None) {
                    recommendations[foundCount] = candidate;
                    foundCount++;
                }
            }
        }
        
        return recommendations;
    }
    
    // ✅ 辅助函数
    
    /// @notice 更新影响力分数
    /// @param user 用户地址
    /// @param change 分数变化
    function _updateInfluenceScore(address user, int256 change) internal {
        uint256 oldScore = influenceScore[user];
        
        if (change > 0) {
            influenceScore[user] += uint256(change);
        } else if (change < 0) {
            uint256 decrease = uint256(-change);
            if (influenceScore[user] > decrease) {
                influenceScore[user] -= decrease;
            } else {
                influenceScore[user] = 0;
            }
        }
        
        emit InfluenceScoreUpdated(user, oldScore, influenceScore[user]);
    }
    
    /// @notice 检查用户是否为圈子成员
    /// @param user 用户地址
    /// @param circleId 圈子ID
    /// @return 是否为成员
    function _isMemberOfCircle(
        address user,
        uint256 circleId
    ) internal view returns (bool) {
        Circle memory circle = circles[circleId];
        for (uint256 i = 0; i < circle.members.length; i++) {
            if (circle.members[i] == user) {
                return true;
            }
        }
        return false;
    }
    
    /// @notice 获取共同圈子数量
    /// @param user1 用户1
    /// @param user2 用户2
    /// @return 共同圈子数量
    function _getCommonCirclesCount(
        address user1,
        address user2
    ) internal view returns (uint256) {
        uint256 commonCount = 0;
        uint256[] memory circles1 = userCircles[user1];
        uint256[] memory circles2 = userCircles[user2];
        
        for (uint256 i = 0; i < circles1.length; i++) {
            for (uint256 j = 0; j < circles2.length; j++) {
                if (circles1[i] == circles2[j]) {
                    commonCount++;
                    break;
                }
            }
        }
        
        return commonCount;
    }
    
    // ✅ 查询功能
    
    /// @notice 获取用户关系
    /// @param user1 用户1
    /// @param user2 用户2
    /// @return 关系类型
    function getRelationship(
        address user1,
        address user2
    ) external view returns (RelationshipType) {
        return relationships[user1][user2];
    }
    
    /// @notice 获取圈子信息
    /// @param circleId 圈子ID
    /// @return 圈子信息
    function getCircle(uint256 circleId) external view returns (Circle memory) {
        return circles[circleId];
    }
    
    /// @notice 获取用户圈子列表
    /// @param user 用户地址
    /// @return 圈子ID列表
    function getUserCircles(address user) external view returns (uint256[] memory) {
        return userCircles[user];
    }
    
    /// @notice 获取用户影响力分数
    /// @param user 用户地址
    /// @return 影响力分数
    function getInfluenceScore(address user) external view returns (uint256) {
        return influenceScore[user];
    }
}
```

### 核心技能掌握
1. **社交图谱建模**：用户关系网络的数据结构设计
2. **关系强度计算**：基于多维度的用户关系量化
3. **社交圈子管理**：兴趣群体和社区的组织机制
4. **推荐算法**：基于社交关系的用户推荐系统
5. **影响力评估**：用户在社交网络中的影响力计算

### 项目记录
- 实现了复杂的社交关系建模系统
- 设计了多维度的关系强度计算算法
- 开发了基于社交图谱的推荐引擎

---

## 学习心得与总结

### 核心技术掌握

1. **去中心化社交架构**
   - 深入理解了去中心化社交网络的核心组件
   - 掌握了用户身份管理和内容发布的链上实现
   - 学会了设计可扩展的社交功能架构

2. **社区治理机制**
   - 全面了解了DAO治理的设计原理和实现方法
   - 实践了提案系统和投票机制的开发
   - 研究了不同治理模式的优缺点和适用场景

3. **社交代币经济**
   - 设计了完整的社交代币激励体系
   - 实现了基于行为的代币分发机制
   - 掌握了代币经济学在社交场景中的应用

4. **社交图谱分析**
   - 构建了复杂的用户关系网络模型
   - 实现了关系强度计算和推荐算法
   - 开发了社交圈子和社区管理功能

5. **用户体验优化**
   - 理解了去中心化应用的用户体验挑战
   - 学会了平衡去中心化和易用性的设计方法
   - 掌握了社交功能的交互设计原则

### 技术创新点

1. **多维度声誉系统**：结合用户行为、社交关系和内容质量的综合评价
2. **智能推荐引擎**：基于社交图谱和用户偏好的个性化推荐
3. **灵活治理框架**：支持多种治理模式的可配置DAO系统
4. **激励机制设计**：平衡用户参与度和代币经济可持续性

### 实践项目成果

- **去中心化社交平台**：完整实现了用户管理、内容发布、社交互动功能
- **社区治理系统**：开发了支持提案、投票、执行的完整DAO框架
- **社交代币系统**：实现了基于行为激励的代币经济模型
- **社交图谱引擎**：构建了关系分析和推荐系统
- **内容审核机制**：设计了去中心化的内容治理方案

### 未来发展方向

1. **隐私保护技术**：研究零知识证明在社交隐私中的应用
2. **跨平台互操作**：探索不同社交平台间的数据互通
3. **AI辅助治理**：结合人工智能优化社区治理效率
4. **移动端优化**：改善去中心化社交应用的移动体验

---

## 参考资源

### 技术文档
- [Lens Protocol Documentation](https://docs.lens.xyz/)
- [Farcaster Protocol](https://docs.farcaster.xyz/)
- [Arweave Social Protocol](https://arweave.org/)
- [IPFS Documentation](https://docs.ipfs.io/)

### 学术论文
- "Decentralized Social Networks: A Survey" (2022)
- "Blockchain-based Social Media: A Survey" (2021)
- "Token Economics in Decentralized Social Networks" (2023)
- "Privacy-Preserving Social Graphs on Blockchain" (2022)

### 开源项目
- [Lens Protocol](https://github.com/lens-protocol)
- [Farcaster](https://github.com/farcasterxyz)
- [Mastodon](https://github.com/mastodon/mastodon)
- [Diaspora](https://github.com/diaspora/diaspora)

### 工具和平台
- [The Graph](https://thegraph.com/)
- [Ceramic Network](https://ceramic.network/)
- [Gun.js](https://gun.eco/)
- [OrbitDB](https://orbitdb.org/)

---

**学习总结**：通过深入学习社交功能与社区治理，我全面掌握了去中心化社交网络的设计原理和实现方法。从用户身份管理到内容发布，从社区治理到代币激励，每个环节都体现了区块链技术在社交领域的创新应用。特别是在DAO治理机制的设计上，我深刻理解了去中心化决策的重要性和实现难点。

作为专注于社交功能与社区治理的学生，我将继续深入研究用户隐私保护、跨平台互操作性等前沿技术，为构建更加开放、公平、用户友好的去中心化社交生态贡献力量。

---

*最后更新时间：2024年12月*  
*文档版本：v1.0*