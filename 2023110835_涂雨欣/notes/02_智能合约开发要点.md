# æ™ºèƒ½åˆçº¦å¼€å‘è¦ç‚¹

**å­¦ç”Ÿ**: æ¶‚é›¨æ¬£ (2023110835)  
**å­¦ä¹ ç‰¹è‰²**: æ³¨é‡ç¤¾äº¤åŠŸèƒ½å’Œç¤¾åŒºæ²»ç†  
**é‡ç‚¹æ–¹å‘**: DAOæ²»ç†ä¸ç¤¾åŒºæœºåˆ¶  
**æ›´æ–°æ—¶é—´**: 2024å¹´12æœˆ19æ—¥

---

## ğŸ“‹ ç›®å½•

1. [DAOæ²»ç†åŸºç¡€](#DAOæ²»ç†åŸºç¡€)
2. [ç¤¾åŒºæ²»ç†æœºåˆ¶](#ç¤¾åŒºæ²»ç†æœºåˆ¶)
3. [æŠ•ç¥¨ç³»ç»Ÿè®¾è®¡](#æŠ•ç¥¨ç³»ç»Ÿè®¾è®¡)
4. [ç¤¾äº¤åŠŸèƒ½å®ç°](#ç¤¾äº¤åŠŸèƒ½å®ç°)
5. [æ¿€åŠ±æœºåˆ¶è®¾è®¡](#æ¿€åŠ±æœºåˆ¶è®¾è®¡)
6. [ç¤¾åŒºè‡ªæ²»å·¥å…·](#ç¤¾åŒºè‡ªæ²»å·¥å…·)

---

## ğŸ›ï¸ DAOæ²»ç†åŸºç¡€

### DAOæ¶æ„è®¾è®¡

```
DAOæ²»ç†æ¶æ„:
â”œâ”€â”€ æ²»ç†ä»£å¸
â”‚   â”œâ”€â”€ æŠ•ç¥¨æƒé‡
â”‚   â”œâ”€â”€ ææ¡ˆæƒé™
â”‚   â””â”€â”€ å¥–åŠ±åˆ†é…
â”œâ”€â”€ ææ¡ˆç³»ç»Ÿ
â”‚   â”œâ”€â”€ ææ¡ˆåˆ›å»º
â”‚   â”œâ”€â”€ è®¨è®ºé˜¶æ®µ
â”‚   â””â”€â”€ æŠ•ç¥¨æ‰§è¡Œ
â”œâ”€â”€ æ‰§è¡Œæœºåˆ¶
â”‚   â”œâ”€â”€ å¤šé‡ç­¾å
â”‚   â”œâ”€â”€ æ—¶é—´é”
â”‚   â””â”€â”€ è‡ªåŠ¨æ‰§è¡Œ
â””â”€â”€ ç›‘ç£æœºåˆ¶
    â”œâ”€â”€ é€æ˜åº¦
    â”œâ”€â”€ é—®è´£åˆ¶
    â””â”€â”€ äº‰è®®è§£å†³
```

### åŸºç¡€DAOåˆçº¦

```solidity
// DAOæ²»ç†æ ¸å¿ƒåˆçº¦
contract DAOGovernance {
    struct Proposal {
        uint256 id;
        address proposer;
        string title;
        string description;
        bytes callData;
        address target;
        uint256 value;
        uint256 startTime;
        uint256 endTime;
        uint256 forVotes;
        uint256 againstVotes;
        uint256 abstainVotes;
        bool executed;
        bool canceled;
        mapping(address => bool) hasVoted;
        mapping(address => VoteChoice) votes;
    }
    
    enum VoteChoice { Against, For, Abstain }
    enum ProposalState { Pending, Active, Canceled, Defeated, Succeeded, Queued, Expired, Executed }
    
    // çŠ¶æ€å˜é‡
    mapping(uint256 => Proposal) public proposals;
    uint256 public proposalCount;
    
    IERC20 public governanceToken;
    uint256 public votingDelay;      // ææ¡ˆåˆ›å»ºåˆ°æŠ•ç¥¨å¼€å§‹çš„å»¶è¿Ÿ
    uint256 public votingPeriod;     // æŠ•ç¥¨æŒç»­æ—¶é—´
    uint256 public proposalThreshold; // åˆ›å»ºææ¡ˆæ‰€éœ€çš„æœ€å°ä»£å¸æ•°é‡
    uint256 public quorum;           // æ³•å®šäººæ•°
    
    // äº‹ä»¶
    event ProposalCreated(
        uint256 indexed proposalId,
        address indexed proposer,
        string title,
        uint256 startTime,
        uint256 endTime
    );
    
    event VoteCast(
        address indexed voter,
        uint256 indexed proposalId,
        VoteChoice choice,
        uint256 weight,
        string reason
    );
    
    event ProposalExecuted(uint256 indexed proposalId);
    event ProposalCanceled(uint256 indexed proposalId);
    
    constructor(
        address _governanceToken,
        uint256 _votingDelay,
        uint256 _votingPeriod,
        uint256 _proposalThreshold,
        uint256 _quorum
    ) {
        governanceToken = IERC20(_governanceToken);
        votingDelay = _votingDelay;
        votingPeriod = _votingPeriod;
        proposalThreshold = _proposalThreshold;
        quorum = _quorum;
    }
    
    // åˆ›å»ºææ¡ˆ
    function propose(
        string calldata title,
        string calldata description,
        address target,
        uint256 value,
        bytes calldata callData
    ) external returns (uint256 proposalId) {
        require(
            governanceToken.balanceOf(msg.sender) >= proposalThreshold,
            "Insufficient tokens to propose"
        );
        
        proposalId = ++proposalCount;
        
        Proposal storage proposal = proposals[proposalId];
        proposal.id = proposalId;
        proposal.proposer = msg.sender;
        proposal.title = title;
        proposal.description = description;
        proposal.target = target;
        proposal.value = value;
        proposal.callData = callData;
        proposal.startTime = block.timestamp + votingDelay;
        proposal.endTime = proposal.startTime + votingPeriod;
        
        emit ProposalCreated(
            proposalId,
            msg.sender,
            title,
            proposal.startTime,
            proposal.endTime
        );
    }
    
    // æŠ•ç¥¨
    function castVote(
        uint256 proposalId,
        VoteChoice choice,
        string calldata reason
    ) external {
        Proposal storage proposal = proposals[proposalId];
        require(proposal.id != 0, "Proposal does not exist");
        require(block.timestamp >= proposal.startTime, "Voting not started");
        require(block.timestamp <= proposal.endTime, "Voting ended");
        require(!proposal.hasVoted[msg.sender], "Already voted");
        
        uint256 weight = governanceToken.balanceOf(msg.sender);
        require(weight > 0, "No voting power");
        
        proposal.hasVoted[msg.sender] = true;
        proposal.votes[msg.sender] = choice;
        
        if (choice == VoteChoice.For) {
            proposal.forVotes += weight;
        } else if (choice == VoteChoice.Against) {
            proposal.againstVotes += weight;
        } else {
            proposal.abstainVotes += weight;
        }
        
        emit VoteCast(msg.sender, proposalId, choice, weight, reason);
    }
    
    // æ‰§è¡Œææ¡ˆ
    function execute(uint256 proposalId) external {
        Proposal storage proposal = proposals[proposalId];
        require(proposal.id != 0, "Proposal does not exist");
        require(block.timestamp > proposal.endTime, "Voting not ended");
        require(!proposal.executed, "Already executed");
        require(!proposal.canceled, "Proposal canceled");
        
        ProposalState state = getProposalState(proposalId);
        require(state == ProposalState.Succeeded, "Proposal not succeeded");
        
        proposal.executed = true;
        
        // æ‰§è¡Œææ¡ˆ
        (bool success, ) = proposal.target.call{value: proposal.value}(proposal.callData);
        require(success, "Execution failed");
        
        emit ProposalExecuted(proposalId);
    }
    
    // è·å–ææ¡ˆçŠ¶æ€
    function getProposalState(uint256 proposalId) public view returns (ProposalState) {
        Proposal storage proposal = proposals[proposalId];
        require(proposal.id != 0, "Proposal does not exist");
        
        if (proposal.canceled) {
            return ProposalState.Canceled;
        } else if (proposal.executed) {
            return ProposalState.Executed;
        } else if (block.timestamp < proposal.startTime) {
            return ProposalState.Pending;
        } else if (block.timestamp <= proposal.endTime) {
            return ProposalState.Active;
        } else {
            uint256 totalVotes = proposal.forVotes + proposal.againstVotes + proposal.abstainVotes;
            if (totalVotes < quorum) {
                return ProposalState.Defeated;
            } else if (proposal.forVotes > proposal.againstVotes) {
                return ProposalState.Succeeded;
            } else {
                return ProposalState.Defeated;
            }
        }
    }
    
    // è·å–ææ¡ˆè¯¦æƒ…
    function getProposal(uint256 proposalId) external view returns (
        address proposer,
        string memory title,
        string memory description,
        uint256 startTime,
        uint256 endTime,
        uint256 forVotes,
        uint256 againstVotes,
        uint256 abstainVotes,
        bool executed
    ) {
        Proposal storage proposal = proposals[proposalId];
        return (
            proposal.proposer,
            proposal.title,
            proposal.description,
            proposal.startTime,
            proposal.endTime,
            proposal.forVotes,
            proposal.againstVotes,
            proposal.abstainVotes,
            proposal.executed
        );
    }
    
    // æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å·²æŠ•ç¥¨
    function hasVoted(uint256 proposalId, address voter) external view returns (bool) {
        return proposals[proposalId].hasVoted[voter];
    }
    
    // è·å–ç”¨æˆ·æŠ•ç¥¨é€‰æ‹©
    function getVote(uint256 proposalId, address voter) external view returns (VoteChoice) {
        return proposals[proposalId].votes[voter];
    }
}
```

### æ²»ç†ä»£å¸åˆçº¦

```solidity
// æ²»ç†ä»£å¸åˆçº¦
contract GovernanceToken is ERC20, ERC20Votes {
    constructor(
        string memory name,
        string memory symbol,
        uint256 initialSupply
    ) ERC20(name, symbol) ERC20Permit(name) {
        _mint(msg.sender, initialSupply);
    }
    
    // é‡å†™å¿…è¦çš„å‡½æ•°
    function _afterTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal override(ERC20, ERC20Votes) {
        super._afterTokenTransfer(from, to, amount);
    }
    
    function _mint(address to, uint256 amount) internal override(ERC20, ERC20Votes) {
        super._mint(to, amount);
    }
    
    function _burn(address account, uint256 amount) internal override(ERC20, ERC20Votes) {
        super._burn(account, amount);
    }
}
```

---

## ğŸ¤ ç¤¾åŒºæ²»ç†æœºåˆ¶

### å¤šå±‚æ²»ç†ç»“æ„

```solidity
// å¤šå±‚æ²»ç†åˆçº¦
contract MultiLayerGovernance {
    enum GovernanceLevel { Community, Council, Core }
    
    struct GovernanceLayer {
        string name;
        uint256 minTokens;        // å‚ä¸æ‰€éœ€æœ€å°ä»£å¸æ•°
        uint256 proposalThreshold; // ææ¡ˆé—¨æ§›
        uint256 quorum;           // æ³•å®šäººæ•°
        uint256 votingPeriod;     // æŠ•ç¥¨å‘¨æœŸ
        bool active;
    }
    
    struct LayerProposal {
        uint256 id;
        GovernanceLevel level;
        address proposer;
        string title;
        string description;
        bytes callData;
        address target;
        uint256 startTime;
        uint256 endTime;
        uint256 forVotes;
        uint256 againstVotes;
        bool executed;
        mapping(address => bool) hasVoted;
    }
    
    mapping(GovernanceLevel => GovernanceLayer) public governanceLayers;
    mapping(uint256 => LayerProposal) public layerProposals;
    mapping(GovernanceLevel => uint256) public proposalCounts;
    
    // æƒé™ç®¡ç†
    mapping(address => GovernanceLevel) public memberLevels;
    mapping(GovernanceLevel => mapping(address => bool)) public levelMembers;
    
    IERC20 public governanceToken;
    
    event LayerProposalCreated(
        uint256 indexed proposalId,
        GovernanceLevel indexed level,
        address indexed proposer,
        string title
    );
    
    event LayerVoteCast(
        uint256 indexed proposalId,
        GovernanceLevel indexed level,
        address indexed voter,
        bool support,
        uint256 weight
    );
    
    event MemberLevelChanged(
        address indexed member,
        GovernanceLevel oldLevel,
        GovernanceLevel newLevel
    );
    
    constructor(address _governanceToken) {
        governanceToken = IERC20(_governanceToken);
        
        // åˆå§‹åŒ–æ²»ç†å±‚çº§
        governanceLayers[GovernanceLevel.Community] = GovernanceLayer({
            name: "Community",
            minTokens: 100 * 10**18,
            proposalThreshold: 1000 * 10**18,
            quorum: 10000 * 10**18,
            votingPeriod: 7 days,
            active: true
        });
        
        governanceLayers[GovernanceLevel.Council] = GovernanceLayer({
            name: "Council",
            minTokens: 1000 * 10**18,
            proposalThreshold: 5000 * 10**18,
            quorum: 50000 * 10**18,
            votingPeriod: 5 days,
            active: true
        });
        
        governanceLayers[GovernanceLevel.Core] = GovernanceLayer({
            name: "Core",
            minTokens: 10000 * 10**18,
            proposalThreshold: 50000 * 10**18,
            quorum: 100000 * 10**18,
            votingPeriod: 3 days,
            active: true
        });
    }
    
    // åˆ›å»ºåˆ†å±‚ææ¡ˆ
    function createLayerProposal(
        GovernanceLevel level,
        string calldata title,
        string calldata description,
        address target,
        bytes calldata callData
    ) external returns (uint256 proposalId) {
        GovernanceLayer storage layer = governanceLayers[level];
        require(layer.active, "Governance level not active");
        require(
            governanceToken.balanceOf(msg.sender) >= layer.proposalThreshold,
            "Insufficient tokens for proposal"
        );
        require(
            memberLevels[msg.sender] >= level,
            "Insufficient governance level"
        );
        
        proposalId = ++proposalCounts[level];
        
        LayerProposal storage proposal = layerProposals[proposalId];
        proposal.id = proposalId;
        proposal.level = level;
        proposal.proposer = msg.sender;
        proposal.title = title;
        proposal.description = description;
        proposal.target = target;
        proposal.callData = callData;
        proposal.startTime = block.timestamp;
        proposal.endTime = block.timestamp + layer.votingPeriod;
        
        emit LayerProposalCreated(proposalId, level, msg.sender, title);
    }
    
    // åˆ†å±‚æŠ•ç¥¨
    function castLayerVote(
        uint256 proposalId,
        bool support
    ) external {
        LayerProposal storage proposal = layerProposals[proposalId];
        require(proposal.id != 0, "Proposal does not exist");
        require(block.timestamp <= proposal.endTime, "Voting ended");
        require(!proposal.hasVoted[msg.sender], "Already voted");
        require(
            memberLevels[msg.sender] >= proposal.level,
            "Insufficient governance level"
        );
        
        GovernanceLayer storage layer = governanceLayers[proposal.level];
        require(
            governanceToken.balanceOf(msg.sender) >= layer.minTokens,
            "Insufficient tokens to vote"
        );
        
        uint256 weight = governanceToken.balanceOf(msg.sender);
        proposal.hasVoted[msg.sender] = true;
        
        if (support) {
            proposal.forVotes += weight;
        } else {
            proposal.againstVotes += weight;
        }
        
        emit LayerVoteCast(proposalId, proposal.level, msg.sender, support, weight);
    }
    
    // è®¾ç½®æˆå‘˜æ²»ç†çº§åˆ«
    function setMemberLevel(
        address member,
        GovernanceLevel newLevel
    ) external {
        // ç®€åŒ–å®ç°ï¼šå®é™…åº”è¯¥æœ‰æƒé™æ§åˆ¶
        GovernanceLevel oldLevel = memberLevels[member];
        
        // ä»æ—§çº§åˆ«ç§»é™¤
        if (oldLevel != GovernanceLevel.Community) {
            levelMembers[oldLevel][member] = false;
        }
        
        // æ·»åŠ åˆ°æ–°çº§åˆ«
        memberLevels[member] = newLevel;
        levelMembers[newLevel][member] = true;
        
        emit MemberLevelChanged(member, oldLevel, newLevel);
    }
    
    // è·å–æ²»ç†å±‚çº§ä¿¡æ¯
    function getGovernanceLayer(GovernanceLevel level) 
        external view returns (GovernanceLayer memory) {
        return governanceLayers[level];
    }
    
    // æ£€æŸ¥æˆå‘˜çº§åˆ«
    function getMemberLevel(address member) external view returns (GovernanceLevel) {
        return memberLevels[member];
    }
    
    // æ£€æŸ¥æ˜¯å¦ä¸ºç‰¹å®šçº§åˆ«æˆå‘˜
    function isLevelMember(address member, GovernanceLevel level) 
        external view returns (bool) {
        return levelMembers[level][member];
    }
}
```

### å§”æ‰˜æŠ•ç¥¨ç³»ç»Ÿ

```solidity
// å§”æ‰˜æŠ•ç¥¨åˆçº¦
contract DelegatedVoting {
    struct Delegation {
        address delegate;     // è¢«å§”æ‰˜äºº
        uint256 amount;      // å§”æ‰˜æ•°é‡
        uint256 startTime;   // å§”æ‰˜å¼€å§‹æ—¶é—´
        uint256 endTime;     // å§”æ‰˜ç»“æŸæ—¶é—´
        bool active;         // æ˜¯å¦æ¿€æ´»
    }
    
    struct DelegateInfo {
        uint256 totalDelegated;  // æ€»å§”æ‰˜æ•°é‡
        uint256 delegatorCount;  // å§”æ‰˜äººæ•°é‡
        string profile;          // å§”æ‰˜äººç®€ä»‹
        bool acceptingDelegations; // æ˜¯å¦æ¥å—å§”æ‰˜
    }
    
    mapping(address => mapping(address => Delegation)) public delegations; // delegator => delegate => Delegation
    mapping(address => DelegateInfo) public delegates;
    mapping(address => address[]) public delegatorList; // delegate => delegators
    mapping(address => address[]) public delegateList;  // delegator => delegates
    
    IERC20 public governanceToken;
    uint256 public minDelegationAmount;
    uint256 public maxDelegationPeriod;
    
    event DelegationCreated(
        address indexed delegator,
        address indexed delegate,
        uint256 amount,
        uint256 endTime
    );
    
    event DelegationRevoked(
        address indexed delegator,
        address indexed delegate,
        uint256 amount
    );
    
    event DelegateProfileUpdated(
        address indexed delegate,
        string profile
    );
    
    constructor(
        address _governanceToken,
        uint256 _minDelegationAmount,
        uint256 _maxDelegationPeriod
    ) {
        governanceToken = IERC20(_governanceToken);
        minDelegationAmount = _minDelegationAmount;
        maxDelegationPeriod = _maxDelegationPeriod;
    }
    
    // åˆ›å»ºå§”æ‰˜
    function delegate(
        address _delegate,
        uint256 amount,
        uint256 duration
    ) external {
        require(_delegate != msg.sender, "Cannot delegate to self");
        require(_delegate != address(0), "Invalid delegate address");
        require(amount >= minDelegationAmount, "Amount below minimum");
        require(duration <= maxDelegationPeriod, "Duration too long");
        require(
            governanceToken.balanceOf(msg.sender) >= amount,
            "Insufficient balance"
        );
        require(
            delegates[_delegate].acceptingDelegations,
            "Delegate not accepting delegations"
        );
        
        // æ£€æŸ¥æ˜¯å¦å·²æœ‰å§”æ‰˜
        Delegation storage existingDelegation = delegations[msg.sender][_delegate];
        if (existingDelegation.active) {
            // æ›´æ–°ç°æœ‰å§”æ‰˜
            existingDelegation.amount += amount;
            existingDelegation.endTime = block.timestamp + duration;
        } else {
            // åˆ›å»ºæ–°å§”æ‰˜
            delegations[msg.sender][_delegate] = Delegation({
                delegate: _delegate,
                amount: amount,
                startTime: block.timestamp,
                endTime: block.timestamp + duration,
                active: true
            });
            
            // æ›´æ–°åˆ—è¡¨
            delegatorList[_delegate].push(msg.sender);
            delegateList[msg.sender].push(_delegate);
            delegates[_delegate].delegatorCount++;
        }
        
        // æ›´æ–°å§”æ‰˜æ€»é‡
        delegates[_delegate].totalDelegated += amount;
        
        // è½¬ç§»ä»£å¸åˆ°åˆçº¦ï¼ˆé”å®šï¼‰
        governanceToken.transferFrom(msg.sender, address(this), amount);
        
        emit DelegationCreated(msg.sender, _delegate, amount, block.timestamp + duration);
    }
    
    // æ’¤é”€å§”æ‰˜
    function revokeDelegation(address _delegate) external {
        Delegation storage delegation = delegations[msg.sender][_delegate];
        require(delegation.active, "No active delegation");
        
        uint256 amount = delegation.amount;
        
        // æ›´æ–°å§”æ‰˜ä¿¡æ¯
        delegation.active = false;
        delegates[_delegate].totalDelegated -= amount;
        delegates[_delegate].delegatorCount--;
        
        // è¿”è¿˜ä»£å¸
        governanceToken.transfer(msg.sender, amount);
        
        emit DelegationRevoked(msg.sender, _delegate, amount);
    }
    
    // è®¾ç½®å§”æ‰˜äººèµ„æ–™
    function setDelegateProfile(
        string calldata profile,
        bool acceptingDelegations
    ) external {
        delegates[msg.sender].profile = profile;
        delegates[msg.sender].acceptingDelegations = acceptingDelegations;
        
        emit DelegateProfileUpdated(msg.sender, profile);
    }
    
    // è·å–å§”æ‰˜æŠ•ç¥¨æƒé‡
    function getDelegatedVotingPower(address _delegate) 
        external view returns (uint256) {
        uint256 totalPower = governanceToken.balanceOf(_delegate);
        
        // åŠ ä¸Šå§”æ‰˜çš„æŠ•ç¥¨æƒ
        address[] memory delegators = delegatorList[_delegate];
        for (uint256 i = 0; i < delegators.length; i++) {
            Delegation memory delegation = delegations[delegators[i]][_delegate];
            if (delegation.active && block.timestamp <= delegation.endTime) {
                totalPower += delegation.amount;
            }
        }
        
        return totalPower;
    }
    
    // è·å–å§”æ‰˜ä¿¡æ¯
    function getDelegation(address delegator, address _delegate) 
        external view returns (Delegation memory) {
        return delegations[delegator][_delegate];
    }
    
    // è·å–å§”æ‰˜äººä¿¡æ¯
    function getDelegateInfo(address _delegate) 
        external view returns (DelegateInfo memory) {
        return delegates[_delegate];
    }
    
    // è·å–å§”æ‰˜äººåˆ—è¡¨
    function getDelegators(address _delegate) 
        external view returns (address[] memory) {
        return delegatorList[_delegate];
    }
    
    // è·å–è¢«å§”æ‰˜äººåˆ—è¡¨
    function getDelegates(address delegator) 
        external view returns (address[] memory) {
        return delegateList[delegator];
    }
    
    // æ¸…ç†è¿‡æœŸå§”æ‰˜
    function cleanupExpiredDelegations(address _delegate) external {
        address[] storage delegators = delegatorList[_delegate];
        
        for (uint256 i = 0; i < delegators.length; i++) {
            Delegation storage delegation = delegations[delegators[i]][_delegate];
            if (delegation.active && block.timestamp > delegation.endTime) {
                // å§”æ‰˜å·²è¿‡æœŸï¼Œè‡ªåŠ¨æ’¤é”€
                uint256 amount = delegation.amount;
                delegation.active = false;
                delegates[_delegate].totalDelegated -= amount;
                delegates[_delegate].delegatorCount--;
                
                // è¿”è¿˜ä»£å¸
                governanceToken.transfer(delegators[i], amount);
                
                emit DelegationRevoked(delegators[i], _delegate, amount);
            }
        }
    }
}
```

---

## ğŸ—³ï¸ æŠ•ç¥¨ç³»ç»Ÿè®¾è®¡

### é«˜çº§æŠ•ç¥¨æœºåˆ¶

```solidity
// é«˜çº§æŠ•ç¥¨ç³»ç»Ÿ
contract AdvancedVotingSystem {
    enum VotingType { Simple, Weighted, Quadratic, Ranked }
    enum VotingStatus { Pending, Active, Ended, Executed, Canceled }
    
    struct VotingConfig {
        VotingType votingType;
        uint256 startTime;
        uint256 endTime;
        uint256 minParticipation; // æœ€å°å‚ä¸ç‡
        uint256 passingThreshold; // é€šè¿‡é˜ˆå€¼
        bool allowDelegation;     // æ˜¯å¦å…è®¸å§”æ‰˜æŠ•ç¥¨
        bool isPrivate;          // æ˜¯å¦ç§å¯†æŠ•ç¥¨
    }
    
    struct Vote {
        address voter;
        uint256[] choices;       // æ”¯æŒå¤šé€‰å’Œæ’åº
        uint256 weight;
        uint256 timestamp;
        string reason;
        bool isDelegated;
        address originalVoter;   // åŸå§‹æŠ•ç¥¨äººï¼ˆå§”æ‰˜æƒ…å†µä¸‹ï¼‰
    }
    
    struct VotingSession {
        uint256 id;
        string title;
        string description;
        string[] options;
        VotingConfig config;
        VotingStatus status;
        mapping(address => Vote) votes;
        mapping(uint256 => uint256) optionVotes; // é€‰é¡¹ => ç¥¨æ•°
        address[] voters;
        uint256 totalParticipants;
        uint256 totalWeight;
    }
    
    mapping(uint256 => VotingSession) public votingSessions;
    uint256 public sessionCount;
    
    IERC20 public governanceToken;
    mapping(address => bool) public authorizedCreators;
    
    event VotingSessionCreated(
        uint256 indexed sessionId,
        string title,
        VotingType votingType,
        uint256 startTime,
        uint256 endTime
    );
    
    event VoteCasted(
        uint256 indexed sessionId,
        address indexed voter,
        uint256[] choices,
        uint256 weight
    );
    
    event VotingSessionEnded(
        uint256 indexed sessionId,
        uint256[] results
    );
    
    constructor(address _governanceToken) {
        governanceToken = IERC20(_governanceToken);
    }
    
    // åˆ›å»ºæŠ•ç¥¨ä¼šè¯
    function createVotingSession(
        string calldata title,
        string calldata description,
        string[] calldata options,
        VotingConfig calldata config
    ) external returns (uint256 sessionId) {
        require(authorizedCreators[msg.sender], "Not authorized to create voting");
        require(options.length >= 2, "At least 2 options required");
        require(config.endTime > config.startTime, "Invalid time range");
        require(config.startTime >= block.timestamp, "Start time in past");
        
        sessionId = ++sessionCount;
        
        VotingSession storage session = votingSessions[sessionId];
        session.id = sessionId;
        session.title = title;
        session.description = description;
        session.options = options;
        session.config = config;
        session.status = VotingStatus.Pending;
        
        emit VotingSessionCreated(
            sessionId,
            title,
            config.votingType,
            config.startTime,
            config.endTime
        );
    }
    
    // æŠ•ç¥¨
    function castVote(
        uint256 sessionId,
        uint256[] calldata choices,
        string calldata reason
    ) external {
        VotingSession storage session = votingSessions[sessionId];
        require(session.id != 0, "Session does not exist");
        require(block.timestamp >= session.config.startTime, "Voting not started");
        require(block.timestamp <= session.config.endTime, "Voting ended");
        require(session.votes[msg.sender].voter == address(0), "Already voted");
        
        // éªŒè¯é€‰æ‹©
        _validateChoices(session, choices);
        
        // è®¡ç®—æŠ•ç¥¨æƒé‡
        uint256 weight = _calculateVotingWeight(
            session.config.votingType,
            governanceToken.balanceOf(msg.sender)
        );
        require(weight > 0, "No voting power");
        
        // è®°å½•æŠ•ç¥¨
        session.votes[msg.sender] = Vote({
            voter: msg.sender,
            choices: choices,
            weight: weight,
            timestamp: block.timestamp,
            reason: reason,
            isDelegated: false,
            originalVoter: msg.sender
        });
        
        // æ›´æ–°ç»Ÿè®¡
        session.voters.push(msg.sender);
        session.totalParticipants++;
        session.totalWeight += weight;
        
        // æ›´æ–°é€‰é¡¹ç¥¨æ•°
        _updateOptionVotes(session, choices, weight);
        
        emit VoteCasted(sessionId, msg.sender, choices, weight);
    }
    
    // å§”æ‰˜æŠ•ç¥¨
    function castDelegatedVote(
        uint256 sessionId,
        address originalVoter,
        uint256[] calldata choices,
        string calldata reason
    ) external {
        VotingSession storage session = votingSessions[sessionId];
        require(session.config.allowDelegation, "Delegation not allowed");
        require(session.votes[originalVoter].voter == address(0), "Original voter already voted");
        
        // éªŒè¯å§”æ‰˜æƒé™ï¼ˆç®€åŒ–å®ç°ï¼‰
        require(_isDelegatedBy(originalVoter, msg.sender), "Not delegated");
        
        // éªŒè¯é€‰æ‹©
        _validateChoices(session, choices);
        
        // è®¡ç®—æŠ•ç¥¨æƒé‡
        uint256 weight = _calculateVotingWeight(
            session.config.votingType,
            governanceToken.balanceOf(originalVoter)
        );
        
        // è®°å½•å§”æ‰˜æŠ•ç¥¨
        session.votes[originalVoter] = Vote({
            voter: msg.sender,
            choices: choices,
            weight: weight,
            timestamp: block.timestamp,
            reason: reason,
            isDelegated: true,
            originalVoter: originalVoter
        });
        
        // æ›´æ–°ç»Ÿè®¡
        session.voters.push(originalVoter);
        session.totalParticipants++;
        session.totalWeight += weight;
        
        // æ›´æ–°é€‰é¡¹ç¥¨æ•°
        _updateOptionVotes(session, choices, weight);
        
        emit VoteCasted(sessionId, originalVoter, choices, weight);
    }
    
    // ç»“æŸæŠ•ç¥¨
    function endVoting(uint256 sessionId) external {
        VotingSession storage session = votingSessions[sessionId];
        require(session.id != 0, "Session does not exist");
        require(block.timestamp > session.config.endTime, "Voting period not ended");
        require(session.status == VotingStatus.Active || session.status == VotingStatus.Pending, "Invalid status");
        
        session.status = VotingStatus.Ended;
        
        // è®¡ç®—ç»“æœ
        uint256[] memory results = _calculateResults(session);
        
        emit VotingSessionEnded(sessionId, results);
    }
    
    // éªŒè¯é€‰æ‹©æœ‰æ•ˆæ€§
    function _validateChoices(
        VotingSession storage session,
        uint256[] calldata choices
    ) internal view {
        require(choices.length > 0, "No choices provided");
        
        if (session.config.votingType == VotingType.Simple) {
            require(choices.length == 1, "Simple voting allows only one choice");
            require(choices[0] < session.options.length, "Invalid choice");
        } else if (session.config.votingType == VotingType.Ranked) {
            require(choices.length <= session.options.length, "Too many choices");
            // æ£€æŸ¥æ’åºçš„å”¯ä¸€æ€§
            for (uint256 i = 0; i < choices.length; i++) {
                require(choices[i] < session.options.length, "Invalid choice");
                for (uint256 j = i + 1; j < choices.length; j++) {
                    require(choices[i] != choices[j], "Duplicate choice");
                }
            }
        }
    }
    
    // è®¡ç®—æŠ•ç¥¨æƒé‡
    function _calculateVotingWeight(
        VotingType votingType,
        uint256 tokenBalance
    ) internal pure returns (uint256) {
        if (votingType == VotingType.Simple) {
            return tokenBalance > 0 ? 1 : 0;
        } else if (votingType == VotingType.Weighted) {
            return tokenBalance;
        } else if (votingType == VotingType.Quadratic) {
            return _sqrt(tokenBalance);
        } else {
            return tokenBalance;
        }
    }
    
    // æ›´æ–°é€‰é¡¹ç¥¨æ•°
    function _updateOptionVotes(
        VotingSession storage session,
        uint256[] calldata choices,
        uint256 weight
    ) internal {
        if (session.config.votingType == VotingType.Ranked) {
            // æ’åºæŠ•ç¥¨ï¼šç¬¬ä¸€é€‰æ‹©è·å¾—å…¨éƒ¨æƒé‡ï¼Œåç»­é€‰æ‹©æƒé‡é€’å‡
            for (uint256 i = 0; i < choices.length; i++) {
                uint256 adjustedWeight = weight / (i + 1);
                session.optionVotes[choices[i]] += adjustedWeight;
            }
        } else {
            // å…¶ä»–æŠ•ç¥¨ç±»å‹ï¼šæ¯ä¸ªé€‰æ‹©è·å¾—ç›¸åŒæƒé‡
            for (uint256 i = 0; i < choices.length; i++) {
                session.optionVotes[choices[i]] += weight;
            }
        }
    }
    
    // è®¡ç®—æŠ•ç¥¨ç»“æœ
    function _calculateResults(
        VotingSession storage session
    ) internal view returns (uint256[] memory) {
        uint256[] memory results = new uint256[](session.options.length);
        
        for (uint256 i = 0; i < session.options.length; i++) {
            results[i] = session.optionVotes[i];
        }
        
        return results;
    }
    
    // æ£€æŸ¥å§”æ‰˜å…³ç³»ï¼ˆç®€åŒ–å®ç°ï¼‰
    function _isDelegatedBy(address delegator, address delegate) 
        internal pure returns (bool) {
        // å®é™…å®ç°åº”è¯¥æŸ¥è¯¢å§”æ‰˜åˆçº¦
        return true;
    }
    
    // å¹³æ–¹æ ¹è®¡ç®—ï¼ˆç®€åŒ–å®ç°ï¼‰
    function _sqrt(uint256 x) internal pure returns (uint256) {
        if (x == 0) return 0;
        uint256 z = (x + 1) / 2;
        uint256 y = x;
        while (z < y) {
            y = z;
            z = (x / z + z) / 2;
        }
        return y;
    }
    
    // è·å–æŠ•ç¥¨ä¼šè¯ä¿¡æ¯
    function getVotingSession(uint256 sessionId) 
        external view returns (
            string memory title,
            string memory description,
            string[] memory options,
            VotingConfig memory config,
            VotingStatus status,
            uint256 totalParticipants,
            uint256 totalWeight
        ) {
        VotingSession storage session = votingSessions[sessionId];
        return (
            session.title,
            session.description,
            session.options,
            session.config,
            session.status,
            session.totalParticipants,
            session.totalWeight
        );
    }
    
    // è·å–æŠ•ç¥¨ç»“æœ
    function getVotingResults(uint256 sessionId) 
        external view returns (uint256[] memory) {
        VotingSession storage session = votingSessions[sessionId];
        require(session.status == VotingStatus.Ended, "Voting not ended");
        
        uint256[] memory results = new uint256[](session.options.length);
        for (uint256 i = 0; i < session.options.length; i++) {
            results[i] = session.optionVotes[i];
        }
        
        return results;
    }
    
    // è·å–ç”¨æˆ·æŠ•ç¥¨
    function getUserVote(uint256 sessionId, address voter) 
        external view returns (Vote memory) {
        return votingSessions[sessionId].votes[voter];
    }
    
    // ç®¡ç†å‡½æ•°
    function addAuthorizedCreator(address creator) external {
        authorizedCreators[creator] = true;
    }
    
    function removeAuthorizedCreator(address creator) external {
        authorizedCreators[creator] = false;
    }
}
```

---

## ğŸ‘¥ ç¤¾äº¤åŠŸèƒ½å®ç°

### ç¤¾åŒºäº’åŠ¨ç³»ç»Ÿ

```solidity
// ç¤¾åŒºäº’åŠ¨åˆçº¦
contract CommunityInteraction {
    struct UserProfile {
        string username;
        string bio;
        string avatar;
        uint256 reputation;
        uint256 joinTime;
        bool verified;
        mapping(string => string) socialLinks;
    }
    
    struct Post {
        uint256 id;
        address author;
        string content;
        string[] tags;
        uint256 timestamp;
        uint256 likes;
        uint256 dislikes;
        uint256 shares;
        uint256 comments;
        bool pinned;
        mapping(address => bool) likedBy;
        mapping(address => bool) dislikedBy;
    }
    
    struct Comment {
        uint256 id;
        uint256 postId;
        address author;
        string content;
        uint256 timestamp;
        uint256 likes;
        uint256 parentCommentId; // 0 for top-level comments
        mapping(address => bool) likedBy;
    }
    
    mapping(address => UserProfile) public userProfiles;
    mapping(uint256 => Post) public posts;
    mapping(uint256 => Comment) public comments;
    mapping(string => uint256[]) public taggedPosts; // tag => post IDs
    
    uint256 public postCount;
    uint256 public commentCount;
    
    // å…³æ³¨ç³»ç»Ÿ
    mapping(address => mapping(address => bool)) public following;
    mapping(address => address[]) public followers;
    mapping(address => address[]) public followingList;
    mapping(address => uint256) public followerCount;
    mapping(address => uint256) public followingCount;
    
    event ProfileUpdated(address indexed user, string username);
    event PostCreated(uint256 indexed postId, address indexed author, string content);
    event PostLiked(uint256 indexed postId, address indexed user, bool liked);
    event CommentAdded(uint256 indexed commentId, uint256 indexed postId, address indexed author);
    event UserFollowed(address indexed follower, address indexed followed);
    event UserUnfollowed(address indexed follower, address indexed unfollowed);
    
    // åˆ›å»ºæˆ–æ›´æ–°ç”¨æˆ·èµ„æ–™
    function updateProfile(
        string calldata username,
        string calldata bio,
        string calldata avatar
    ) external {
        UserProfile storage profile = userProfiles[msg.sender];
        
        if (profile.joinTime == 0) {
            profile.joinTime = block.timestamp;
        }
        
        profile.username = username;
        profile.bio = bio;
        profile.avatar = avatar;
        
        emit ProfileUpdated(msg.sender, username);
    }
    
    // æ·»åŠ ç¤¾äº¤é“¾æ¥
    function addSocialLink(
        string calldata platform,
        string calldata url
    ) external {
        userProfiles[msg.sender].socialLinks[platform] = url;
    }
    
    // åˆ›å»ºå¸–å­
    function createPost(
        string calldata content,
        string[] calldata tags
    ) external returns (uint256 postId) {
        require(bytes(content).length > 0, "Content cannot be empty");
        require(bytes(userProfiles[msg.sender].username).length > 0, "Profile required");
        
        postId = ++postCount;
        
        Post storage post = posts[postId];
        post.id = postId;
        post.author = msg.sender;
        post.content = content;
        post.tags = tags;
        post.timestamp = block.timestamp;
        
        // æ·»åŠ æ ‡ç­¾ç´¢å¼•
        for (uint256 i = 0; i < tags.length; i++) {
            taggedPosts[tags[i]].push(postId);
        }
        
        emit PostCreated(postId, msg.sender, content);
    }
    
    // ç‚¹èµ/å–æ¶ˆç‚¹èµå¸–å­
    function likePost(uint256 postId, bool like) external {
        Post storage post = posts[postId];
        require(post.id != 0, "Post does not exist");
        require(post.author != msg.sender, "Cannot like own post");
        
        bool currentlyLiked = post.likedBy[msg.sender];
        bool currentlyDisliked = post.dislikedBy[msg.sender];
        
        if (like) {
            if (!currentlyLiked) {
                post.likedBy[msg.sender] = true;
                post.likes++;
                
                // å¦‚æœä¹‹å‰ç‚¹äº†è¸©ï¼Œå–æ¶ˆè¸©
                if (currentlyDisliked) {
                    post.dislikedBy[msg.sender] = false;
                    post.dislikes--;
                }
            }
        } else {
            if (!currentlyDisliked) {
                post.dislikedBy[msg.sender] = true;
                post.dislikes++;
                
                // å¦‚æœä¹‹å‰ç‚¹äº†èµï¼Œå–æ¶ˆèµ
                if (currentlyLiked) {
                    post.likedBy[msg.sender] = false;
                    post.likes--;
                }
            }
        }
        
        emit PostLiked(postId, msg.sender, like);
    }
    
    // æ·»åŠ è¯„è®º
    function addComment(
        uint256 postId,
        string calldata content,
        uint256 parentCommentId
    ) external returns (uint256 commentId) {
        require(posts[postId].id != 0, "Post does not exist");
        require(bytes(content).length > 0, "Content cannot be empty");
        
        if (parentCommentId > 0) {
            require(comments[parentCommentId].id != 0, "Parent comment does not exist");
            require(comments[parentCommentId].postId == postId, "Parent comment not in same post");
        }
        
        commentId = ++commentCount;
        
        Comment storage comment = comments[commentId];
        comment.id = commentId;
        comment.postId = postId;
        comment.author = msg.sender;
        comment.content = content;
        comment.timestamp = block.timestamp;
        comment.parentCommentId = parentCommentId;
        
        // æ›´æ–°å¸–å­è¯„è®ºæ•°
        posts[postId].comments++;
        
        emit CommentAdded(commentId, postId, msg.sender);
    }
    
    // ç‚¹èµè¯„è®º
    function likeComment(uint256 commentId) external {
        Comment storage comment = comments[commentId];
        require(comment.id != 0, "Comment does not exist");
        require(comment.author != msg.sender, "Cannot like own comment");
        require(!comment.likedBy[msg.sender], "Already liked");
        
        comment.likedBy[msg.sender] = true;
        comment.likes++;
    }
    
    // å…³æ³¨ç”¨æˆ·
    function followUser(address user) external {
        require(user != msg.sender, "Cannot follow yourself");
        require(!following[msg.sender][user], "Already following");
        
        following[msg.sender][user] = true;
        followers[user].push(msg.sender);
        followingList[msg.sender].push(user);
        
        followerCount[user]++;
        followingCount[msg.sender]++;
        
        emit UserFollowed(msg.sender, user);
    }
    
    // å–æ¶ˆå…³æ³¨ç”¨æˆ·
    function unfollowUser(address user) external {
        require(following[msg.sender][user], "Not following");
        
        following[msg.sender][user] = false;
        
        // ä»å…³æ³¨è€…åˆ—è¡¨ä¸­ç§»é™¤
        address[] storage userFollowers = followers[user];
        for (uint256 i = 0; i < userFollowers.length; i++) {
            if (userFollowers[i] == msg.sender) {
                userFollowers[i] = userFollowers[userFollowers.length - 1];
                userFollowers.pop();
                break;
            }
        }
        
        // ä»å…³æ³¨åˆ—è¡¨ä¸­ç§»é™¤
        address[] storage myFollowing = followingList[msg.sender];
        for (uint256 i = 0; i < myFollowing.length; i++) {
            if (myFollowing[i] == user) {
                myFollowing[i] = myFollowing[myFollowing.length - 1];
                myFollowing.pop();
                break;
            }
        }
        
        followerCount[user]--;
        followingCount[msg.sender]--;
        
        emit UserUnfollowed(msg.sender, user);
    }
    
    // è·å–ç”¨æˆ·èµ„æ–™
    function getUserProfile(address user) 
        external view returns (
            string memory username,
            string memory bio,
            string memory avatar,
            uint256 reputation,
            uint256 joinTime,
            bool verified
        ) {
        UserProfile storage profile = userProfiles[user];
        return (
            profile.username,
            profile.bio,
            profile.avatar,
            profile.reputation,
            profile.joinTime,
            profile.verified
        );
    }
    
    // è·å–å¸–å­ä¿¡æ¯
    function getPost(uint256 postId) 
        external view returns (
            address author,
            string memory content,
            string[] memory tags,
            uint256 timestamp,
            uint256 likes,
            uint256 dislikes,
            uint256 shares,
            uint256 comments
        ) {
        Post storage post = posts[postId];
        return (
            post.author,
            post.content,
            post.tags,
            post.timestamp,
            post.likes,
            post.dislikes,
            post.shares,
            post.comments
        );
    }
    
    // è·å–è¯„è®ºä¿¡æ¯
    function getComment(uint256 commentId) 
        external view returns (
            uint256 postId,
            address author,
            string memory content,
            uint256 timestamp,
            uint256 likes,
            uint256 parentCommentId
        ) {
        Comment storage comment = comments[commentId];
        return (
            comment.postId,
            comment.author,
            comment.content,
            comment.timestamp,
            comment.likes,
            comment.parentCommentId
        );
    }
    
    // è·å–æ ‡ç­¾ç›¸å…³å¸–å­
    function getPostsByTag(string calldata tag) 
        external view returns (uint256[] memory) {
        return taggedPosts[tag];
    }
    
    // è·å–å…³æ³¨è€…åˆ—è¡¨
    function getFollowers(address user) 
        external view returns (address[] memory) {
        return followers[user];
    }
    
    // è·å–å…³æ³¨åˆ—è¡¨
    function getFollowing(address user) 
        external view returns (address[] memory) {
        return followingList[user];
    }
    
    // æ£€æŸ¥æ˜¯å¦å…³æ³¨
    function isFollowing(address follower, address followed) 
        external view returns (bool) {
        return following[follower][followed];
    }
    
    // è·å–ç¤¾äº¤é“¾æ¥
    function getSocialLink(address user, string calldata platform) 
        external view returns (string memory) {
        return userProfiles[user].socialLinks[platform];
    }
}
```

---

## ğŸ¯ æ¿€åŠ±æœºåˆ¶è®¾è®¡

### è´¡çŒ®å¥–åŠ±ç³»ç»Ÿ

```solidity
// è´¡çŒ®å¥–åŠ±åˆçº¦
contract ContributionRewards {
    enum ContributionType {
        Proposal,
        Vote,
        Comment,
        CodeReview,
        Documentation,
        BugReport,
        Community
    }
    
    struct Contribution {
        uint256 id;
        address contributor;
        ContributionType contributionType;
        string description;
        uint256 timestamp;
        uint256 impact;      // å½±å“åŠ›è¯„åˆ†
        uint256 quality;     // è´¨é‡è¯„åˆ†
        uint256 reward;      // å¥–åŠ±æ•°é‡
        bool verified;       // æ˜¯å¦å·²éªŒè¯
        address[] reviewers; // è¯„å®¡è€…
        mapping(address => uint256) reviews; // è¯„å®¡è¯„åˆ†
    }
    
    struct RewardPool {
        uint256 totalPool;        // æ€»å¥–åŠ±æ± 
        uint256 distributedRewards; // å·²åˆ†å‘å¥–åŠ±
        uint256 currentPeriod;    // å½“å‰å‘¨æœŸ
        uint256 periodDuration;   // å‘¨æœŸæŒç»­æ—¶é—´
        uint256 lastDistribution; // ä¸Šæ¬¡åˆ†å‘æ—¶é—´
        mapping(ContributionType => uint256) typeWeights; // è´¡çŒ®ç±»å‹æƒé‡
    }
    
    struct UserStats {
        uint256 totalContributions;
        uint256 totalRewards;
        uint256 reputation;
        mapping(ContributionType => uint256) contributionCounts;
        mapping(ContributionType => uint256) contributionRewards;
    }
    
    mapping(uint256 => Contribution) public contributions;
    mapping(address => UserStats) public userStats;
    RewardPool public rewardPool;
    
    uint256 public contributionCount;
    IERC20 public rewardToken;
    
    // æƒé™ç®¡ç†
    mapping(address => bool) public reviewers;
    mapping(address => bool) public admins;
    
    event ContributionSubmitted(
        uint256 indexed contributionId,
        address indexed contributor,
        ContributionType contributionType,
        string description
    );
    
    event ContributionReviewed(
        uint256 indexed contributionId,
        address indexed reviewer,
        uint256 impact,
        uint256 quality
    );
    
    event RewardDistributed(
        uint256 indexed contributionId,
        address indexed contributor,
        uint256 reward
    );
    
    event RewardPoolUpdated(
        uint256 totalPool,
        uint256 currentPeriod
    );
    
    modifier onlyReviewer() {
        require(reviewers[msg.sender], "Not a reviewer");
        _;
    }
    
    modifier onlyAdmin() {
        require(admins[msg.sender], "Not an admin");
        _;
    }
    
    constructor(
        address _rewardToken,
        uint256 _periodDuration
    ) {
        rewardToken = IERC20(_rewardToken);
        rewardPool.periodDuration = _periodDuration;
        rewardPool.currentPeriod = 1;
        rewardPool.lastDistribution = block.timestamp;
        
        // è®¾ç½®é»˜è®¤æƒé‡
        rewardPool.typeWeights[ContributionType.Proposal] = 100;
        rewardPool.typeWeights[ContributionType.Vote] = 10;
        rewardPool.typeWeights[ContributionType.Comment] = 20;
        rewardPool.typeWeights[ContributionType.CodeReview] = 80;
        rewardPool.typeWeights[ContributionType.Documentation] = 60;
        rewardPool.typeWeights[ContributionType.BugReport] = 70;
        rewardPool.typeWeights[ContributionType.Community] = 40;
        
        admins[msg.sender] = true;
    }
    
    // æäº¤è´¡çŒ®
    function submitContribution(
        ContributionType contributionType,
        string calldata description
    ) external returns (uint256 contributionId) {
        contributionId = ++contributionCount;
        
        Contribution storage contribution = contributions[contributionId];
        contribution.id = contributionId;
        contribution.contributor = msg.sender;
        contribution.contributionType = contributionType;
        contribution.description = description;
        contribution.timestamp = block.timestamp;
        
        // æ›´æ–°ç”¨æˆ·ç»Ÿè®¡
        UserStats storage stats = userStats[msg.sender];
        stats.totalContributions++;
        stats.contributionRewards[contribution.contributionType] += reward;
        stats.reputation += reward / 100; // å£°èª‰å¢é•¿
        
        emit RewardDistributed(contributionId, contribution.contributor, reward);
    }
    
    // æ·»åŠ å¥–åŠ±åˆ°æ± å­
    function addRewardPool(uint256 amount) external onlyAdmin {
        rewardToken.transferFrom(msg.sender, address(this), amount);
        rewardPool.totalPool += amount;
        
        emit RewardPoolUpdated(rewardPool.totalPool, rewardPool.currentPeriod);
    }
    
    // å¼€å§‹æ–°å‘¨æœŸ
    function startNewPeriod() external onlyAdmin {
        require(
            block.timestamp >= rewardPool.lastDistribution + rewardPool.periodDuration,
            "Period not ended"
        );
        
        rewardPool.currentPeriod++;
        rewardPool.lastDistribution = block.timestamp;
        rewardPool.distributedRewards = 0; // é‡ç½®å·²åˆ†å‘å¥–åŠ±
        
        emit RewardPoolUpdated(rewardPool.totalPool, rewardPool.currentPeriod);
    }
    
    // è®¾ç½®è´¡çŒ®ç±»å‹æƒé‡
    function setContributionWeight(
        ContributionType contributionType,
        uint256 weight
    ) external onlyAdmin {
        rewardPool.typeWeights[contributionType] = weight;
    }
    
    // æ·»åŠ è¯„å®¡è€…
    function addReviewer(address reviewer) external onlyAdmin {
        reviewers[reviewer] = true;
    }
    
    // ç§»é™¤è¯„å®¡è€…
    function removeReviewer(address reviewer) external onlyAdmin {
        reviewers[reviewer] = false;
    }
    
    // è·å–è´¡çŒ®ä¿¡æ¯
    function getContribution(uint256 contributionId) 
        external view returns (
            address contributor,
            ContributionType contributionType,
            string memory description,
            uint256 timestamp,
            uint256 impact,
            uint256 quality,
            uint256 reward,
            bool verified
        ) {
        Contribution storage contribution = contributions[contributionId];
        return (
            contribution.contributor,
            contribution.contributionType,
            contribution.description,
            contribution.timestamp,
            contribution.impact,
            contribution.quality,
            contribution.reward,
            contribution.verified
        );
    }
    
    // è·å–ç”¨æˆ·ç»Ÿè®¡
    function getUserStats(address user) 
        external view returns (
            uint256 totalContributions,
            uint256 totalRewards,
            uint256 reputation
        ) {
        UserStats storage stats = userStats[user];
        return (
            stats.totalContributions,
            stats.totalRewards,
            stats.reputation
        );
    }
    
    // è·å–ç”¨æˆ·ç‰¹å®šç±»å‹è´¡çŒ®æ•°é‡
    function getUserContributionCount(
        address user,
        ContributionType contributionType
    ) external view returns (uint256) {
        return userStats[user].contributionCounts[contributionType];
    }
    
    // è·å–å¥–åŠ±æ± ä¿¡æ¯
    function getRewardPoolInfo() 
        external view returns (
            uint256 totalPool,
            uint256 distributedRewards,
            uint256 currentPeriod,
            uint256 lastDistribution
        ) {
        return (
            rewardPool.totalPool,
            rewardPool.distributedRewards,
            rewardPool.currentPeriod,
            rewardPool.lastDistribution
        );
    }
}
```

---

## ğŸ› ï¸ ç¤¾åŒºè‡ªæ²»å·¥å…·

### äº‰è®®è§£å†³æœºåˆ¶

```solidity
// äº‰è®®è§£å†³åˆçº¦
contract DisputeResolution {
    enum DisputeStatus { Open, UnderReview, Resolved, Closed }
    enum DisputeType { Governance, Technical, Community, Financial }
    
    struct Dispute {
        uint256 id;
        address complainant;
        address respondent;
        DisputeType disputeType;
        string title;
        string description;
        string evidence;
        uint256 createdAt;
        uint256 resolvedAt;
        DisputeStatus status;
        address[] arbitrators;
        mapping(address => bool) votes; // true = support complainant
        uint256 supportVotes;
        uint256 opposeVotes;
        string resolution;
        uint256 compensationAmount;
    }
    
    struct Arbitrator {
        address arbitratorAddress;
        string name;
        uint256 reputation;
        uint256 casesHandled;
        uint256 successRate;
        bool active;
        string[] specialties;
    }
    
    mapping(uint256 => Dispute) public disputes;
    mapping(address => Arbitrator) public arbitrators;
    address[] public arbitratorList;
    
    uint256 public disputeCount;
    uint256 public arbitrationFee;
    uint256 public minArbitrators;
    
    IERC20 public governanceToken;
    
    event DisputeCreated(
        uint256 indexed disputeId,
        address indexed complainant,
        address indexed respondent,
        DisputeType disputeType
    );
    
    event ArbitratorAssigned(
        uint256 indexed disputeId,
        address indexed arbitrator
    );
    
    event DisputeVoted(
        uint256 indexed disputeId,
        address indexed arbitrator,
        bool supportComplainant
    );
    
    event DisputeResolved(
        uint256 indexed disputeId,
        string resolution,
        uint256 compensationAmount
    );
    
    constructor(
        address _governanceToken,
        uint256 _arbitrationFee,
        uint256 _minArbitrators
    ) {
        governanceToken = IERC20(_governanceToken);
        arbitrationFee = _arbitrationFee;
        minArbitrators = _minArbitrators;
    }
    
    // åˆ›å»ºäº‰è®®
    function createDispute(
        address respondent,
        DisputeType disputeType,
        string calldata title,
        string calldata description,
        string calldata evidence
    ) external returns (uint256 disputeId) {
        require(respondent != msg.sender, "Cannot dispute with yourself");
        require(bytes(title).length > 0, "Title required");
        require(bytes(description).length > 0, "Description required");
        
        // æ”¶å–ä»²è£è´¹
        governanceToken.transferFrom(msg.sender, address(this), arbitrationFee);
        
        disputeId = ++disputeCount;
        
        Dispute storage dispute = disputes[disputeId];
        dispute.id = disputeId;
        dispute.complainant = msg.sender;
        dispute.respondent = respondent;
        dispute.disputeType = disputeType;
        dispute.title = title;
        dispute.description = description;
        dispute.evidence = evidence;
        dispute.createdAt = block.timestamp;
        dispute.status = DisputeStatus.Open;
        
        // è‡ªåŠ¨åˆ†é…ä»²è£å‘˜
        _assignArbitrators(disputeId);
        
        emit DisputeCreated(disputeId, msg.sender, respondent, disputeType);
    }
    
    // åˆ†é…ä»²è£å‘˜
    function _assignArbitrators(uint256 disputeId) internal {
        Dispute storage dispute = disputes[disputeId];
        
        // ç®€åŒ–å®ç°ï¼šéšæœºé€‰æ‹©æ´»è·ƒçš„ä»²è£å‘˜
        uint256 assignedCount = 0;
        for (uint256 i = 0; i < arbitratorList.length && assignedCount < minArbitrators; i++) {
            address arbitrator = arbitratorList[i];
            if (arbitrators[arbitrator].active && 
                arbitrator != dispute.complainant && 
                arbitrator != dispute.respondent) {
                dispute.arbitrators.push(arbitrator);
                assignedCount++;
                
                emit ArbitratorAssigned(disputeId, arbitrator);
            }
        }
        
        if (assignedCount >= minArbitrators) {
            dispute.status = DisputeStatus.UnderReview;
        }
    }
    
    // ä»²è£å‘˜æŠ•ç¥¨
    function voteOnDispute(
        uint256 disputeId,
        bool supportComplainant,
        string calldata reasoning
    ) external {
        Dispute storage dispute = disputes[disputeId];
        require(dispute.status == DisputeStatus.UnderReview, "Dispute not under review");
        require(_isArbitratorAssigned(disputeId, msg.sender), "Not assigned arbitrator");
        require(!_hasVoted(disputeId, msg.sender), "Already voted");
        
        dispute.votes[msg.sender] = supportComplainant;
        
        if (supportComplainant) {
            dispute.supportVotes++;
        } else {
            dispute.opposeVotes++;
        }
        
        emit DisputeVoted(disputeId, msg.sender, supportComplainant);
        
        // æ£€æŸ¥æ˜¯å¦æ‰€æœ‰ä»²è£å‘˜éƒ½å·²æŠ•ç¥¨
        if (dispute.supportVotes + dispute.opposeVotes == dispute.arbitrators.length) {
            _resolveDispute(disputeId);
        }
    }
    
    // è§£å†³äº‰è®®
    function _resolveDispute(uint256 disputeId) internal {
        Dispute storage dispute = disputes[disputeId];
        
        bool complainantWins = dispute.supportVotes > dispute.opposeVotes;
        
        if (complainantWins) {
            // ç”³è¯·äººèƒœè¯‰
            dispute.resolution = "Complainant wins";
            dispute.compensationAmount = arbitrationFee; // é€€è¿˜ä»²è£è´¹
            
            // è½¬ç§»è¡¥å¿é‡‘ç»™ç”³è¯·äºº
            governanceToken.transfer(dispute.complainant, dispute.compensationAmount);
        } else {
            // è¢«ç”³è¯·äººèƒœè¯‰
            dispute.resolution = "Respondent wins";
            dispute.compensationAmount = 0;
            
            // ä»²è£è´¹ä¸é€€è¿˜ï¼Œä½œä¸ºç³»ç»Ÿæ”¶å…¥
        }
        
        dispute.status = DisputeStatus.Resolved;
        dispute.resolvedAt = block.timestamp;
        
        // æ›´æ–°ä»²è£å‘˜ç»Ÿè®¡
        _updateArbitratorStats(disputeId, complainantWins);
        
        emit DisputeResolved(disputeId, dispute.resolution, dispute.compensationAmount);
    }
    
    // æ›´æ–°ä»²è£å‘˜ç»Ÿè®¡
    function _updateArbitratorStats(uint256 disputeId, bool complainantWins) internal {
        Dispute storage dispute = disputes[disputeId];
        
        for (uint256 i = 0; i < dispute.arbitrators.length; i++) {
            address arbitrator = dispute.arbitrators[i];
            Arbitrator storage arb = arbitrators[arbitrator];
            
            arb.casesHandled++;
            
            // å¦‚æœä»²è£å‘˜çš„æŠ•ç¥¨ä¸æœ€ç»ˆç»“æœä¸€è‡´ï¼Œå¢åŠ æˆåŠŸç‡
            bool votedCorrectly = dispute.votes[arbitrator] == complainantWins;
            if (votedCorrectly) {
                arb.successRate = (arb.successRate * (arb.casesHandled - 1) + 100) / arb.casesHandled;
            } else {
                arb.successRate = (arb.successRate * (arb.casesHandled - 1)) / arb.casesHandled;
            }
            
            // æ›´æ–°å£°èª‰
            if (votedCorrectly) {
                arb.reputation += 10;
            } else {
                arb.reputation = arb.reputation > 5 ? arb.reputation - 5 : 0;
            }
        }
    }
    
    // æ·»åŠ ä»²è£å‘˜
    function addArbitrator(
        address arbitratorAddress,
        string calldata name,
        string[] calldata specialties
    ) external {
        require(!arbitrators[arbitratorAddress].active, "Already an arbitrator");
        
        arbitrators[arbitratorAddress] = Arbitrator({
            arbitratorAddress: arbitratorAddress,
            name: name,
            reputation: 100, // åˆå§‹å£°èª‰
            casesHandled: 0,
            successRate: 0,
            active: true,
            specialties: specialties
        });
        
        arbitratorList.push(arbitratorAddress);
    }
    
    // æ£€æŸ¥æ˜¯å¦ä¸ºæŒ‡å®šä»²è£å‘˜
    function _isArbitratorAssigned(uint256 disputeId, address arbitrator) 
        internal view returns (bool) {
        Dispute storage dispute = disputes[disputeId];
        for (uint256 i = 0; i < dispute.arbitrators.length; i++) {
            if (dispute.arbitrators[i] == arbitrator) {
                return true;
            }
        }
        return false;
    }
    
    // æ£€æŸ¥æ˜¯å¦å·²æŠ•ç¥¨
    function _hasVoted(uint256 disputeId, address arbitrator) 
        internal view returns (bool) {
        Dispute storage dispute = disputes[disputeId];
        // ç®€åŒ–å®ç°ï¼šæ£€æŸ¥æŠ•ç¥¨è®°å½•
        return dispute.supportVotes + dispute.opposeVotes > 0;
    }
    
    // è·å–äº‰è®®ä¿¡æ¯
    function getDispute(uint256 disputeId) 
        external view returns (
            address complainant,
            address respondent,
            DisputeType disputeType,
            string memory title,
            string memory description,
            DisputeStatus status,
            uint256 supportVotes,
            uint256 opposeVotes
        ) {
        Dispute storage dispute = disputes[disputeId];
        return (
            dispute.complainant,
            dispute.respondent,
            dispute.disputeType,
            dispute.title,
            dispute.description,
            dispute.status,
            dispute.supportVotes,
            dispute.opposeVotes
        );
    }
    
    // è·å–ä»²è£å‘˜ä¿¡æ¯
    function getArbitrator(address arbitratorAddress) 
        external view returns (
            string memory name,
            uint256 reputation,
            uint256 casesHandled,
            uint256 successRate,
            bool active
        ) {
        Arbitrator storage arb = arbitrators[arbitratorAddress];
        return (
            arb.name,
            arb.reputation,
            arb.casesHandled,
            arb.successRate,
            arb.active
        );
    }
}
```

---

## ğŸ’¡ å­¦ä¹ å¿ƒå¾—ä¸æ€»ç»“

### DAOæ²»ç†è¦ç‚¹

1. **é€æ˜åº¦åŸåˆ™**
   - æ‰€æœ‰ææ¡ˆå’ŒæŠ•ç¥¨å…¬å¼€é€æ˜
   - å†³ç­–è¿‡ç¨‹å¯è¿½æº¯
   - èµ„é‡‘ä½¿ç”¨é€æ˜åŒ–

2. **å‚ä¸åº¦æ¿€åŠ±**
   - å¤šæ ·åŒ–çš„å‚ä¸æ–¹å¼
   - åˆç†çš„å¥–åŠ±æœºåˆ¶
   - é™ä½å‚ä¸é—¨æ§›

3. **æƒåŠ›åˆ¶è¡¡**
   - å¤šå±‚æ²»ç†ç»“æ„
   - å§”æ‰˜æŠ•ç¥¨æœºåˆ¶
   - äº‰è®®è§£å†³æœºåˆ¶

4. **ç¤¾åŒºå»ºè®¾**
   - ç”¨æˆ·å‹å¥½çš„äº¤äº’ç•Œé¢
   - ä¸°å¯Œçš„ç¤¾äº¤åŠŸèƒ½
   - æœ‰æ•ˆçš„æ²Ÿé€šæ¸ é“

### å®è·µå»ºè®®

1. **æ¸è¿›å¼æ²»ç†**ï¼šä»ç®€å•çš„æŠ•ç¥¨å¼€å§‹ï¼Œé€æ­¥å¢åŠ å¤æ‚åŠŸèƒ½
2. **ç¤¾åŒºä¼˜å…ˆ**ï¼šå§‹ç»ˆä»¥ç¤¾åŒºåˆ©ç›Šä¸ºå‡ºå‘ç‚¹è®¾è®¡æœºåˆ¶
3. **æŠ€æœ¯ä¸æ²»ç†ç»“åˆ**ï¼šç”¨æŠ€æœ¯æ‰‹æ®µä¿éšœæ²»ç†çš„å…¬å¹³æ€§
4. **æŒç»­ä¼˜åŒ–**ï¼šæ ¹æ®ç¤¾åŒºåé¦ˆä¸æ–­æ”¹è¿›æ²»ç†æœºåˆ¶

### æœªæ¥å‘å±•æ–¹å‘

1. **AIè¾…åŠ©æ²»ç†**ï¼šåˆ©ç”¨äººå·¥æ™ºèƒ½ä¼˜åŒ–å†³ç­–è¿‡ç¨‹
2. **è·¨é“¾æ²»ç†**ï¼šå®ç°å¤šé“¾ååŒæ²»ç†
3. **éšç§ä¿æŠ¤æŠ•ç¥¨**ï¼šé›¶çŸ¥è¯†è¯æ˜æŠ€æœ¯åº”ç”¨
4. **åŠ¨æ€æ²»ç†å‚æ•°**ï¼šæ ¹æ®ç¤¾åŒºå‘å±•è‡ªåŠ¨è°ƒæ•´å‚æ•°

---

**å­¦ä¹ æ€»ç»“**: DAOæ²»ç†æ˜¯åŒºå—é“¾æŠ€æœ¯åœ¨ç»„ç»‡ç®¡ç†é¢†åŸŸçš„é‡è¦åº”ç”¨ï¼Œéœ€è¦åœ¨å»ä¸­å¿ƒåŒ–ã€æ•ˆç‡å’Œå…¬å¹³æ€§ä¹‹é—´æ‰¾åˆ°å¹³è¡¡ã€‚é€šè¿‡åˆç†çš„æœºåˆ¶è®¾è®¡ï¼Œå¯ä»¥æ„å»ºä¸€ä¸ªçœŸæ­£ç”±ç¤¾åŒºé©±åŠ¨çš„è‡ªæ²»ç»„ç»‡ã€‚

**å®è·µæ–¹å‘**: é‡ç‚¹å…³æ³¨ç”¨æˆ·ä½“éªŒå’Œç¤¾åŒºå‚ä¸åº¦ï¼Œæ¢ç´¢åˆ›æ–°çš„æ²»ç†æ¨¡å¼å’Œæ¿€åŠ±æœºåˆ¶ï¼Œä¸ºWeb3æ—¶ä»£çš„ç»„ç»‡å½¢æ€è´¡çŒ®åŠ›é‡ã€‚ionCounts[contributionType]++;
        
        emit ContributionSubmitted(
            contributionId,
            msg.sender,
            contributionType,
            description
        );
    }
    
    // è¯„å®¡è´¡çŒ®
    function reviewContribution(
        uint256 contributionId,
        uint256 impact,
        uint256 quality
    ) external onlyReviewer {
        Contribution storage contribution = contributions[contributionId];
        require(contribution.id != 0, "Contribution does not exist");
        require(contribution.reviews[msg.sender] == 0, "Already reviewed");
        require(impact <= 100 && quality <= 100, "Score must be 0-100");
        
        contribution.reviews[msg.sender] = (impact + quality) / 2;
        contribution.reviewers.push(msg.sender);
        
        // æ›´æ–°å¹³å‡è¯„åˆ†
        _updateContributionScores(contributionId);
        
        emit ContributionReviewed(contributionId, msg.sender, impact, quality);
    }
    
    // æ›´æ–°è´¡çŒ®è¯„åˆ†
    function _updateContributionScores(uint256 contributionId) internal {
        Contribution storage contribution = contributions[contributionId];
        
        if (contribution.reviewers.length == 0) return;
        
        uint256 totalScore = 0;
        for (uint256 i = 0; i < contribution.reviewers.length; i++) {
            totalScore += contribution.reviews[contribution.reviewers[i]];
        }
        
        uint256 averageScore = totalScore / contribution.reviewers.length;
        contribution.impact = averageScore;
        contribution.quality = averageScore;
        
        // å¦‚æœæœ‰è¶³å¤Ÿçš„è¯„å®¡ï¼Œæ ‡è®°ä¸ºå·²éªŒè¯
        if (contribution.reviewers.length >= 3) {
            contribution.verified = true;
            _calculateReward(contributionId);
        }
    }
    
    // è®¡ç®—å¥–åŠ±
    function _calculateReward(uint256 contributionId) internal {
        Contribution storage contribution = contributions[contributionId];
        require(contribution.verified, "Contribution not verified");
        require(contribution.reward == 0, "Reward already calculated");
        
        // åŸºç¡€å¥–åŠ± = ç±»å‹æƒé‡ * è´¨é‡è¯„åˆ† * å½±å“åŠ›è¯„åˆ†
        uint256 baseReward = rewardPool.typeWeights[contribution.contributionType];
        uint256 qualityMultiplier = contribution.quality;
        uint256 impactMultiplier = contribution.impact;
        
        uint256 reward = (baseReward * qualityMultiplier * impactMultiplier) / 10000;
        
        // æ£€æŸ¥å¥–åŠ±æ± ä½™é¢
        uint256 availableRewards = rewardPool.totalPool - rewardPool.distributedRewards;
        if (reward > availableRewards) {
            reward = availableRewards;
        }
        
        contribution.reward = reward;
        
        // åˆ†å‘å¥–åŠ±
        if (reward > 0) {
            _distributeReward(contributionId, reward);
        }
    }
    
    // åˆ†å‘å¥–åŠ±
    function _distributeReward(uint256 contributionId, uint256 reward) internal {
        Contribution storage contribution = contributions[contributionId];
        
        // è½¬ç§»ä»£å¸
        rewardToken.transfer(contribution.contributor, reward);
        
        // æ›´æ–°ç»Ÿè®¡
        rewardPool.distributedRewards += reward;
        UserStats storage stats = userStats[contribution.contributor];
        stats.totalRewards += reward;
        stats.contribut