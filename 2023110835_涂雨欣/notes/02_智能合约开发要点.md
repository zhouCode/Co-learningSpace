# Êô∫ËÉΩÂêàÁ∫¶ÂºÄÂèëË¶ÅÁÇπ

**Â≠¶Áîü**: Ê∂ÇÈõ®Ê¨£ (2023110835)  
**Â≠¶‰π†ÁâπËâ≤**: Ê≥®ÈáçÁ§æ‰∫§ÂäüËÉΩÂíåÁ§æÂå∫Ê≤ªÁêÜ  
**ÈáçÁÇπÊñπÂêë**: DAOÊ≤ªÁêÜ‰∏éÁ§æÂå∫Êú∫Âà∂  
**Êõ¥Êñ∞Êó∂Èó¥**: 2024Âπ¥12Êúà19Êó•

---

## üìã ÁõÆÂΩï

1. [DAOÊ≤ªÁêÜÂü∫Á°Ä](#DAOÊ≤ªÁêÜÂü∫Á°Ä)
2. [Á§æÂå∫Ê≤ªÁêÜÊú∫Âà∂](#Á§æÂå∫Ê≤ªÁêÜÊú∫Âà∂)
3. [ÊäïÁ•®Á≥ªÁªüËÆæËÆ°](#ÊäïÁ•®Á≥ªÁªüËÆæËÆ°)
4. [Á§æ‰∫§ÂäüËÉΩÂÆûÁé∞](#Á§æ‰∫§ÂäüËÉΩÂÆûÁé∞)
5. [ÊøÄÂä±Êú∫Âà∂ËÆæËÆ°](#ÊøÄÂä±Êú∫Âà∂ËÆæËÆ°)
6. [Á§æÂå∫Ëá™Ê≤ªÂ∑•ÂÖ∑](#Á§æÂå∫Ëá™Ê≤ªÂ∑•ÂÖ∑)

---

## üèõÔ∏è DAOÊ≤ªÁêÜÂü∫Á°Ä

### DAOÊû∂ÊûÑËÆæËÆ°

```
DAOÊ≤ªÁêÜÊû∂ÊûÑ:
‚îú‚îÄ‚îÄ Ê≤ªÁêÜ‰ª£Â∏Å
‚îÇ   ‚îú‚îÄ‚îÄ ÊäïÁ•®ÊùÉÈáç
‚îÇ   ‚îú‚îÄ‚îÄ ÊèêÊ°àÊùÉÈôê
‚îÇ   ‚îî‚îÄ‚îÄ Â•ñÂä±ÂàÜÈÖç
‚îú‚îÄ‚îÄ ÊèêÊ°àÁ≥ªÁªü
‚îÇ   ‚îú‚îÄ‚îÄ ÊèêÊ°àÂàõÂª∫
‚îÇ   ‚îú‚îÄ‚îÄ ËÆ®ËÆ∫Èò∂ÊÆµ
‚îÇ   ‚îî‚îÄ‚îÄ ÊäïÁ•®ÊâßË°å
‚îú‚îÄ‚îÄ ÊâßË°åÊú∫Âà∂
‚îÇ   ‚îú‚îÄ‚îÄ Â§öÈáçÁ≠æÂêç
‚îÇ   ‚îú‚îÄ‚îÄ Êó∂Èó¥ÈîÅ
‚îÇ   ‚îî‚îÄ‚îÄ Ëá™Âä®ÊâßË°å
‚îî‚îÄ‚îÄ ÁõëÁù£Êú∫Âà∂
    ‚îú‚îÄ‚îÄ ÈÄèÊòéÂ∫¶
    ‚îú‚îÄ‚îÄ ÈóÆË¥£Âà∂
    ‚îî‚îÄ‚îÄ ‰∫âËÆÆËß£ÂÜ≥
```

### Âü∫Á°ÄDAOÂêàÁ∫¶

```solidity
// DAOÊ≤ªÁêÜÊ†∏ÂøÉÂêàÁ∫¶
contract DAOGovernance {
    struct Proposal {
        uint256 id;
        address proposer;
        string title;
        string description;
        bytes callData;
        address target;
        uint256 value;
        uint256 startTime;
        uint256 endTime;
        uint256 forVotes;
        uint256 againstVotes;
        uint256 abstainVotes;
        bool executed;
        bool canceled;
        mapping(address => bool) hasVoted;
        mapping(address => VoteChoice) votes;
    }
    
    enum VoteChoice { Against, For, Abstain }
    enum ProposalState { Pending, Active, Canceled, Defeated, Succeeded, Queued, Expired, Executed }
    
    // Áä∂ÊÄÅÂèòÈáè
    mapping(uint256 => Proposal) public proposals;
    uint256 public proposalCount;
    
    IERC20 public governanceToken;
    uint256 public votingDelay;      // ÊèêÊ°àÂàõÂª∫Âà∞ÊäïÁ•®ÂºÄÂßãÁöÑÂª∂Ëøü
    uint256 public votingPeriod;     // ÊäïÁ•®ÊåÅÁª≠Êó∂Èó¥
    uint256 public proposalThreshold; // ÂàõÂª∫ÊèêÊ°àÊâÄÈúÄÁöÑÊúÄÂ∞è‰ª£Â∏ÅÊï∞Èáè
    uint256 public quorum;           // Ê≥ïÂÆö‰∫∫Êï∞
    
    // ‰∫ã‰ª∂
    event ProposalCreated(
        uint256 indexed proposalId,
        address indexed proposer,
        string title,
        uint256 startTime,
        uint256 endTime
    );
    
    event VoteCast(
        address indexed voter,
        uint256 indexed proposalId,
        VoteChoice choice,
        uint256 weight,
        string reason
    );
    
    event ProposalExecuted(uint256 indexed proposalId);
    event ProposalCanceled(uint256 indexed proposalId);
    
    constructor(
        address _governanceToken,
        uint256 _votingDelay,
        uint256 _votingPeriod,
        uint256 _proposalThreshold,
        uint256 _quorum
    ) {
        governanceToken = IERC20(_governanceToken);
        votingDelay = _votingDelay;
        votingPeriod = _votingPeriod;
        proposalThreshold = _proposalThreshold;
        quorum = _quorum;
    }
    
    // ÂàõÂª∫ÊèêÊ°à
    function propose(
        string calldata title,
        string calldata description,
        address target,
        uint256 value,
        bytes calldata callData
    ) external returns (uint256 proposalId) {
        require(
            governanceToken.balanceOf(msg.sender) >= proposalThreshold,
            "Insufficient tokens to propose"
        );
        
        proposalId = ++proposalCount;
        
        Proposal storage proposal = proposals[proposalId];
        proposal.id = proposalId;
        proposal.proposer = msg.sender;
        proposal.title = title;
        proposal.description = description;
        proposal.target = target;
        proposal.value = value;
        proposal.callData = callData;
        proposal.startTime = block.timestamp + votingDelay;
        proposal.endTime = proposal.startTime + votingPeriod;
        
        emit ProposalCreated(
            proposalId,
            msg.sender,
            title,
            proposal.startTime,
            proposal.endTime
        );
    }
    
    // ÊäïÁ•®
    function castVote(
        uint256 proposalId,
        VoteChoice choice,
        string calldata reason
    ) external {
        Proposal storage proposal = proposals[proposalId];
        require(proposal.id != 0, "Proposal does not exist");
        require(block.timestamp >= proposal.startTime, "Voting not started");
        require(block.timestamp <= proposal.endTime, "Voting ended");
        require(!proposal.hasVoted[msg.sender], "Already voted");
        
        uint256 weight = governanceToken.balanceOf(msg.sender);
        require(weight > 0, "No voting power");
        
        proposal.hasVoted[msg.sender] = true;
        proposal.votes[msg.sender] = choice;
        
        if (choice == VoteChoice.For) {
            proposal.forVotes += weight;
        } else if (choice == VoteChoice.Against) {
            proposal.againstVotes += weight;
        } else {
            proposal.abstainVotes += weight;
        }
        
        emit VoteCast(msg.sender, proposalId, choice, weight, reason);
    }
    
    // ÊâßË°åÊèêÊ°à
    function execute(uint256 proposalId) external {
        Proposal storage proposal = proposals[proposalId];
        require(proposal.id != 0, "Proposal does not exist");
        require(block.timestamp > proposal.endTime, "Voting not ended");
        require(!proposal.executed, "Already executed");
        require(!proposal.canceled, "Proposal canceled");
        
        ProposalState state = getProposalState(proposalId);
        require(state == ProposalState.Succeeded, "Proposal not succeeded");
        
        proposal.executed = true;
        
        // ÊâßË°åÊèêÊ°à
        (bool success, ) = proposal.target.call{value: proposal.value}(proposal.callData);
        require(success, "Execution failed");
        
        emit ProposalExecuted(proposalId);
    }
    
    // Ëé∑ÂèñÊèêÊ°àÁä∂ÊÄÅ
    function getProposalState(uint256 proposalId) public view returns (ProposalState) {
        Proposal storage proposal = proposals[proposalId];
        require(proposal.id != 0, "Proposal does not exist");
        
        if (proposal.canceled) {
            return ProposalState.Canceled;
        } else if (proposal.executed) {
            return ProposalState.Executed;
        } else if (block.timestamp < proposal.startTime) {
            return ProposalState.Pending;
        } else if (block.timestamp <= proposal.endTime) {
            return ProposalState.Active;
        } else {
            uint256 totalVotes = proposal.forVotes + proposal.againstVotes + proposal.abstainVotes;
            if (totalVotes < quorum) {
                return ProposalState.Defeated;
            } else if (proposal.forVotes > proposal.againstVotes) {
                return ProposalState.Succeeded;
            } else {
                return ProposalState.Defeated;
            }
        }
    }
    
    // Ëé∑ÂèñÊèêÊ°àËØ¶ÊÉÖ
    function getProposal(uint256 proposalId) external view returns (
        address proposer,
        string memory title,
        string memory description,
        uint256 startTime,
        uint256 endTime,
        uint256 forVotes,
        uint256 againstVotes,
        uint256 abstainVotes,
        bool executed
    ) {
        Proposal storage proposal = proposals[proposalId];
        return (
            proposal.proposer,
            proposal.title,
            proposal.description,
            proposal.startTime,
            proposal.endTime,
            proposal.forVotes,
            proposal.againstVotes,
            proposal.abstainVotes,
            proposal.executed
        );
    }
    
    // Ê£ÄÊü•Áî®Êà∑ÊòØÂê¶Â∑≤ÊäïÁ•®
    function hasVoted(uint256 proposalId, address voter) external view returns (bool) {
        return proposals[proposalId].hasVoted[voter];
    }
    
    // Ëé∑ÂèñÁî®Êà∑ÊäïÁ•®ÈÄâÊã©
    function getVote(uint256 proposalId, address voter) external view returns (VoteChoice) {
        return proposals[proposalId].votes[voter];
    }
}
```

### Ê≤ªÁêÜ‰ª£Â∏ÅÂêàÁ∫¶

```solidity
// Ê≤ªÁêÜ‰ª£Â∏ÅÂêàÁ∫¶
contract GovernanceToken is ERC20, ERC20Votes {
    constructor(
        string memory name,
        string memory symbol,
        uint256 initialSupply
    ) ERC20(name, symbol) ERC20Permit(name) {
        _mint(msg.sender, initialSupply);
    }
    
    // ÈáçÂÜôÂøÖË¶ÅÁöÑÂáΩÊï∞
    function _afterTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal override(ERC20, ERC20Votes) {
        super._afterTokenTransfer(from, to, amount);
    }
    
    function _mint(address to, uint256 amount) internal override(ERC20, ERC20Votes) {
        super._mint(to, amount);
    }
    
    function _burn(address account, uint256 amount) internal override(ERC20, ERC20Votes) {
        super._burn(account, amount);
    }
}
```

---

## ü§ù Á§æÂå∫Ê≤ªÁêÜÊú∫Âà∂

### Â§öÂ±ÇÊ≤ªÁêÜÁªìÊûÑ

```solidity
// Â§öÂ±ÇÊ≤ªÁêÜÂêàÁ∫¶
contract MultiLayerGovernance {
    enum GovernanceLevel { Community, Council, Core }
    
    struct GovernanceLayer {
        string name;
        uint256 minTokens;        // ÂèÇ‰∏éÊâÄÈúÄÊúÄÂ∞è‰ª£Â∏ÅÊï∞
        uint256 proposalThreshold; // ÊèêÊ°àÈó®Êßõ
        uint256 quorum;           // Ê≥ïÂÆö‰∫∫Êï∞
        uint256 votingPeriod;     // ÊäïÁ•®Âë®Êúü
        bool active;
    }
    
    struct LayerProposal {
        uint256 id;
        GovernanceLevel level;
        address proposer;
        string title;
        string description;
        bytes callData;
        address target;
        uint256 startTime;
        uint256 endTime;
        uint256 forVotes;
        uint256 againstVotes;
        bool executed;
        mapping(address => bool) hasVoted;
    }
    
    mapping(GovernanceLevel => GovernanceLayer) public governanceLayers;
    mapping(uint256 => LayerProposal) public layerProposals;
    mapping(GovernanceLevel => uint256) public proposalCounts;
    
    // ÊùÉÈôêÁÆ°ÁêÜ
    mapping(address => GovernanceLevel) public memberLevels;
    mapping(GovernanceLevel => mapping(address => bool)) public levelMembers;
    
    IERC20 public governanceToken;
    
    event LayerProposalCreated(
        uint256 indexed proposalId,
        GovernanceLevel indexed level,
        address indexed proposer,
        string title
    );
    
    event LayerVoteCast(
        uint256 indexed proposalId,
        GovernanceLevel indexed level,
        address indexed voter,
        bool support,
        uint256 weight
    );
    
    event MemberLevelChanged(
        address indexed member,
        GovernanceLevel oldLevel,
        GovernanceLevel newLevel
    );
    
    constructor(address _governanceToken) {
        governanceToken = IERC20(_governanceToken);
        
        // ÂàùÂßãÂåñÊ≤ªÁêÜÂ±ÇÁ∫ß
        governanceLayers[GovernanceLevel.Community] = GovernanceLayer({
            name: "Community",
            minTokens: 100 * 10**18,
            proposalThreshold: 1000 * 10**18,
            quorum: 10000 * 10**18,
            votingPeriod: 7 days,
            active: true
        });
        
        governanceLayers[GovernanceLevel.Council] = GovernanceLayer({
            name: "Council",
            minTokens: 1000 * 10**18,
            proposalThreshold: 5000 * 10**18,
            quorum: 50000 * 10**18,
            votingPeriod: 5 days,
            active: true
        });
        
        governanceLayers[GovernanceLevel.Core] = GovernanceLayer({
            name: "Core",
            minTokens: 10000 * 10**18,
            proposalThreshold: 50000 * 10**18,
            quorum: 100000 * 10**18,
            votingPeriod: 3 days,
            active: true
        });
    }
    
    // ÂàõÂª∫ÂàÜÂ±ÇÊèêÊ°à
    function createLayerProposal(
        GovernanceLevel level,
        string calldata title,
        string calldata description,
        address target,
        bytes calldata callData
    ) external returns (uint256 proposalId) {
        GovernanceLayer storage layer = governanceLayers[level];
        require(layer.active, "Governance level not active");
        require(
            governanceToken.balanceOf(msg.sender) >= layer.proposalThreshold,
            "Insufficient tokens for proposal"
        );
        require(
            memberLevels[msg.sender] >= level,
            "Insufficient governance level"
        );
        
        proposalId = ++proposalCounts[level];
        
        LayerProposal storage proposal = layerProposals[proposalId];
        proposal.id = proposalId;
        proposal.level = level;
        proposal.proposer = msg.sender;
        proposal.title = title;
        proposal.description = description;
        proposal.target = target;
        proposal.callData = callData;
        proposal.startTime = block.timestamp;
        proposal.endTime = block.timestamp + layer.votingPeriod;
        
        emit LayerProposalCreated(proposalId, level, msg.sender, title);
    }
    
    // ÂàÜÂ±ÇÊäïÁ•®
    function castLayerVote(
        uint256 proposalId,
        bool support
    ) external {
        LayerProposal storage proposal = layerProposals[proposalId];
        require(proposal.id != 0, "Proposal does not exist");
        require(block.timestamp <= proposal.endTime, "Voting ended");
        require(!proposal.hasVoted[msg.sender], "Already voted");
        require(
            memberLevels[msg.sender] >= proposal.level,
            "Insufficient governance level"
        );
        
        GovernanceLayer storage layer = governanceLayers[proposal.level];
        require(
            governanceToken.balanceOf(msg.sender) >= layer.minTokens,
            "Insufficient tokens to vote"
        );
        
        uint256 weight = governanceToken.balanceOf(msg.sender);
        proposal.hasVoted[msg.sender] = true;
        
        if (support) {
            proposal.forVotes += weight;
        } else {
            proposal.againstVotes += weight;
        }
        
        emit LayerVoteCast(proposalId, proposal.level, msg.sender, support, weight);
    }
    
    // ËÆæÁΩÆÊàêÂëòÊ≤ªÁêÜÁ∫ßÂà´
    function setMemberLevel(
        address member,
        GovernanceLevel newLevel
    ) external {
        // ÁÆÄÂåñÂÆûÁé∞ÔºöÂÆûÈôÖÂ∫îËØ•ÊúâÊùÉÈôêÊéßÂà∂
        GovernanceLevel oldLevel = memberLevels[member];
        
        // ‰ªéÊóßÁ∫ßÂà´ÁßªÈô§
        if (oldLevel != GovernanceLevel.Community) {
            levelMembers[oldLevel][member] = false;
        }
        
        // Ê∑ªÂä†Âà∞Êñ∞Á∫ßÂà´
        memberLevels[member] = newLevel;
        levelMembers[newLevel][member] = true;
        
        emit MemberLevelChanged(member, oldLevel, newLevel);
    }
    
    // Ëé∑ÂèñÊ≤ªÁêÜÂ±ÇÁ∫ß‰ø°ÊÅØ
    function getGovernanceLayer(GovernanceLevel level) 
        external view returns (GovernanceLayer memory) {
        return governanceLayers[level];
    }
    
    // Ê£ÄÊü•ÊàêÂëòÁ∫ßÂà´
    function getMemberLevel(address member) external view returns (GovernanceLevel) {
        return memberLevels[member];
    }
    
    // Ê£ÄÊü•ÊòØÂê¶‰∏∫ÁâπÂÆöÁ∫ßÂà´ÊàêÂëò
    function isLevelMember(address member, GovernanceLevel level) 
        external view returns (bool) {
        return levelMembers[level][member];
    }
}
```

### ÂßîÊâòÊäïÁ•®Á≥ªÁªü

```solidity
// ÂßîÊâòÊäïÁ•®ÂêàÁ∫¶
contract DelegatedVoting {
    struct Delegation {
        address delegate;     // Ë¢´ÂßîÊâò‰∫∫
        uint256 amount;      // ÂßîÊâòÊï∞Èáè
        uint256 startTime;   // ÂßîÊâòÂºÄÂßãÊó∂Èó¥
        uint256 endTime;     // ÂßîÊâòÁªìÊùüÊó∂Èó¥
        bool active;         // ÊòØÂê¶ÊøÄÊ¥ª
    }
    
    struct DelegateInfo {
        uint256 totalDelegated;  // ÊÄªÂßîÊâòÊï∞Èáè
        uint256 delegatorCount;  // ÂßîÊâò‰∫∫Êï∞Èáè
        string profile;          // ÂßîÊâò‰∫∫ÁÆÄ‰ªã
        bool acceptingDelegations; // ÊòØÂê¶Êé•ÂèóÂßîÊâò
    }
    
    mapping(address => mapping(address => Delegation)) public delegations; // delegator => delegate => Delegation
    mapping(address => DelegateInfo) public delegates;
    mapping(address => address[]) public delegatorList; // delegate => delegators
    mapping(address => address[]) public delegateList;  // delegator => delegates
    
    IERC20 public governanceToken;
    uint256 public minDelegationAmount;
    uint256 public maxDelegationPeriod;
    
    event DelegationCreated(
        address indexed delegator,
        address indexed delegate,
        uint256 amount,
        uint256 endTime
    );
    
    event DelegationRevoked(
        address indexed delegator,
        address indexed delegate,
        uint256 amount
    );
    
    event DelegateProfileUpdated(
        address indexed delegate,
        string profile
    );
    
    constructor(
        address _governanceToken,
        uint256 _minDelegationAmount,
        uint256 _maxDelegationPeriod
    ) {
        governanceToken = IERC20(_governanceToken);
        minDelegationAmount = _minDelegationAmount;
        maxDelegationPeriod = _maxDelegationPeriod;
    }
    
    // ÂàõÂª∫ÂßîÊâò
    function delegate(
        address _delegate,
        uint256 amount,
        uint256 duration
    ) external {
        require(_delegate != msg.sender, "Cannot delegate to self");
        require(_delegate != address(0), "Invalid delegate address");
        require(amount >= minDelegationAmount, "Amount below minimum");
        require(duration <= maxDelegationPeriod, "Duration too long");
        require(
            governanceToken.balanceOf(msg.sender) >= amount,
            "Insufficient balance"
        );
        require(
            delegates[_delegate].acceptingDelegations,
            "Delegate not accepting delegations"
        );
        
        // Ê£ÄÊü•ÊòØÂê¶Â∑≤ÊúâÂßîÊâò
        Delegation storage existingDelegation = delegations[msg.sender][_delegate];
        if (existingDelegation.active) {
            // Êõ¥Êñ∞Áé∞ÊúâÂßîÊâò
            existingDelegation.amount += amount;
            existingDelegation.endTime = block.timestamp + duration;
        } else {
            // ÂàõÂª∫Êñ∞ÂßîÊâò
            delegations[msg.sender][_delegate] = Delegation({
                delegate: _delegate,
                amount: amount,
                startTime: block.timestamp,
                endTime: block.timestamp + duration,
                active: true
            });
            
            // Êõ¥Êñ∞ÂàóË°®
            delegatorList[_delegate].push(msg.sender);
            delegateList[msg.sender].push(_delegate);
            delegates[_delegate].delegatorCount++;
        }
        
        // Êõ¥Êñ∞ÂßîÊâòÊÄªÈáè
        delegates[_delegate].totalDelegated += amount;
        
        // ËΩ¨Áßª‰ª£Â∏ÅÂà∞ÂêàÁ∫¶ÔºàÈîÅÂÆöÔºâ
        governanceToken.transferFrom(msg.sender, address(this), amount);
        
        emit DelegationCreated(msg.sender, _delegate, amount, block.timestamp + duration);
    }
    
    // Êí§ÈîÄÂßîÊâò
    function revokeDelegation(address _delegate) external {
        Delegation storage delegation = delegations[msg.sender][_delegate];
        require(delegation.active, "No active delegation");
        
        uint256 amount = delegation.amount;
        
        // Êõ¥Êñ∞ÂßîÊâò‰ø°ÊÅØ
        delegation.active = false;
        delegates[_delegate].totalDelegated -= amount;
        delegates[_delegate].delegatorCount--;
        
        // ËøîËøò‰ª£Â∏Å
        governanceToken.transfer(msg.sender, amount);
        
        emit DelegationRevoked(msg.sender, _delegate, amount);
    }
    
    // ËÆæÁΩÆÂßîÊâò‰∫∫ËµÑÊñô
    function setDelegateProfile(
        string calldata profile,
        bool acceptingDelegations
    ) external {
        delegates[msg.sender].profile = profile;
        delegates[msg.sender].acceptingDelegations = acceptingDelegations;
        
        emit DelegateProfileUpdated(msg.sender, profile);
    }
    
    // Ëé∑ÂèñÂßîÊâòÊäïÁ•®ÊùÉÈáç
    function getDelegatedVotingPower(address _delegate) 
        external view returns (uint256) {
        uint256 totalPower = governanceToken.balanceOf(_delegate);
        
        // Âä†‰∏äÂßîÊâòÁöÑÊäïÁ•®ÊùÉ
        address[] memory delegators = delegatorList[_delegate];
        for (uint256 i = 0; i < delegators.length; i++) {
            Delegation memory delegation = delegations[delegators[i]][_delegate];
            if (delegation.active && block.timestamp <= delegation.endTime) {
                totalPower += delegation.amount;
            }
        }
        
        return totalPower;
    }
    
    // Ëé∑ÂèñÂßîÊâò‰ø°ÊÅØ
    function getDelegation(address delegator, address _delegate) 
        external view returns (Delegation memory) {
        return delegations[delegator][_delegate];
    }
    
    // Ëé∑ÂèñÂßîÊâò‰∫∫‰ø°ÊÅØ
    function getDelegateInfo(address _delegate) 
        external view returns (DelegateInfo memory) {
        return delegates[_delegate];
    }
    
    // Ëé∑ÂèñÂßîÊâò‰∫∫ÂàóË°®
    function getDelegators(address _delegate) 
        external view returns (address[] memory) {
        return delegatorList[_delegate];
    }
    
    // Ëé∑ÂèñË¢´ÂßîÊâò‰∫∫ÂàóË°®
    function getDelegates(address delegator) 
        external view returns (address[] memory) {
        return delegateList[delegator];
    }
    
    // Ê∏ÖÁêÜËøáÊúüÂßîÊâò
    function cleanupExpiredDelegations(address _delegate) external {
        address[] storage delegators = delegatorList[_delegate];
        
        for (uint256 i = 0; i < delegators.length; i++) {
            Delegation storage delegation = delegations[delegators[i]][_delegate];
            if (delegation.active && block.timestamp > delegation.endTime) {
                // ÂßîÊâòÂ∑≤ËøáÊúüÔºåËá™Âä®Êí§ÈîÄ
                uint256 amount = delegation.amount;
                delegation.active = false;
                delegates[_delegate].totalDelegated -= amount;
                delegates[_delegate].delegatorCount--;
                
                // ËøîËøò‰ª£Â∏Å
                governanceToken.transfer(delegators[i], amount);
                
                emit DelegationRevoked(delegators[i], _delegate, amount);
            }
        }
    }
}
```

---

## üó≥Ô∏è ÊäïÁ•®Á≥ªÁªüËÆæËÆ°

### È´òÁ∫ßÊäïÁ•®Êú∫Âà∂

```solidity
// È´òÁ∫ßÊäïÁ•®Á≥ªÁªü
contract AdvancedVotingSystem {
    enum VotingType { Simple, Weighted, Quadratic, Ranked }
    enum VotingStatus { Pending, Active, Ended, Executed, Canceled }
    
    struct VotingConfig {
        VotingType votingType;
        uint256 startTime;
        uint256 endTime;
        uint256 minParticipation; // ÊúÄÂ∞èÂèÇ‰∏éÁéá
        uint256 passingThreshold; // ÈÄöËøáÈòàÂÄº
        bool allowDelegation;     // ÊòØÂê¶ÂÖÅËÆ∏ÂßîÊâòÊäïÁ•®
        bool isPrivate;          // ÊòØÂê¶ÁßÅÂØÜÊäïÁ•®
    }
    
    struct Vote {
        address voter;
        uint256[] choices;       // ÊîØÊåÅÂ§öÈÄâÂíåÊéíÂ∫è
        uint256 weight;
        uint256 timestamp;
        string reason;
        bool isDelegated;
        address originalVoter;   // ÂéüÂßãÊäïÁ•®‰∫∫ÔºàÂßîÊâòÊÉÖÂÜµ‰∏ãÔºâ
    }
    
    struct VotingSession {
        uint256 id;
        string title;
        string description;
        string[] options;
        VotingConfig config;
        VotingStatus status;
        mapping(address => Vote) votes;
        mapping(uint256 => uint256) optionVotes; // ÈÄâÈ°π => Á•®Êï∞
        address[] voters;
        uint256 totalParticipants;
        uint256 totalWeight;
    }
    
    mapping(uint256 => VotingSession) public votingSessions;
    uint256 public sessionCount;
    
    IERC20 public governanceToken;
    mapping(address => bool) public authorizedCreators;
    
    event VotingSessionCreated(
        uint256 indexed sessionId,
        string title,
        VotingType votingType,
        uint256 startTime,
        uint256 endTime
    );
    
    event VoteCasted(
        uint256 indexed sessionId,
        address indexed voter,
        uint256[] choices,
        uint256 weight
    );
    
    event VotingSessionEnded(
        uint256 indexed sessionId,
        uint256[] results
    );
    
    constructor(address _governanceToken) {
        governanceToken = IERC20(_governanceToken);
    }
    
    // ÂàõÂª∫ÊäïÁ•®‰ºöËØù
    function createVotingSession(
        string calldata title,
        string calldata description,
        string[] calldata options,
        VotingConfig calldata config
    ) external returns (uint256 sessionId) {
        require(authorizedCreators[msg.sender], "Not authorized to create voting");
        require(options.length >= 2, "At least 2 options required");
        require(config.endTime > config.startTime, "Invalid time range");
        require(config.startTime >= block.timestamp, "Start time in past");
        
        sessionId = ++sessionCount;
        
        VotingSession storage session = votingSessions[sessionId];
        session.id = sessionId;
        session.title = title;
        session.description = description;
        session.options = options;
        session.config = config;
        session.status = VotingStatus.Pending;
        
        emit VotingSessionCreated(
            sessionId,
            title,
            config.votingType,
            config.startTime,
            config.endTime
        );
    }
    
    // ÊäïÁ•®
    function castVote(
        uint256 sessionId,
        uint256[] calldata choices,
        string calldata reason
    ) external {
        VotingSession storage session = votingSessions[sessionId];
        require(session.id != 0, "Session does not exist");
        require(block.timestamp >= session.config.startTime, "Voting not started");
        require(block.timestamp <= session.config.endTime, "Voting ended");
        require(session.votes[msg.sender].voter == address(0), "Already voted");
        
        // È™åËØÅÈÄâÊã©
        _validateChoices(session, choices);
        
        // ËÆ°ÁÆóÊäïÁ•®ÊùÉÈáç
        uint256 weight = _calculateVotingWeight(
            session.config.votingType,
            governanceToken.balanceOf(msg.sender)
        );
        require(weight > 0, "No voting power");
        
        // ËÆ∞ÂΩïÊäïÁ•®
        session.votes[msg.sender] = Vote({
            voter: msg.sender,
            choices: choices,
            weight: weight,
            timestamp: block.timestamp,
            reason: reason,
            isDelegated: false,
            originalVoter: msg.sender
        });
        
        // Êõ¥Êñ∞ÁªüËÆ°
        session.voters.push(msg.sender);
        session.totalParticipants++;
        session.totalWeight += weight;
        
        // Êõ¥Êñ∞ÈÄâÈ°πÁ•®Êï∞
        _updateOptionVotes(session, choices, weight);
        
        emit VoteCasted(sessionId, msg.sender, choices, weight);
    }
    
    // ÂßîÊâòÊäïÁ•®
    function castDelegatedVote(
        uint256 sessionId,
        address originalVoter,
        uint256[] calldata choices,
        string calldata reason
    ) external {
        VotingSession storage session = votingSessions[sessionId];
        require(session.config.allowDelegation, "Delegation not allowed");
        require(session.votes[originalVoter].voter == address(0), "Original voter already voted");
        
        // È™åËØÅÂßîÊâòÊùÉÈôêÔºàÁÆÄÂåñÂÆûÁé∞Ôºâ
        require(_isDelegatedBy(originalVoter, msg.sender), "Not delegated");
        
        // È™åËØÅÈÄâÊã©
        _validateChoices(session, choices);
        
        // ËÆ°ÁÆóÊäïÁ•®ÊùÉÈáç
        uint256 weight = _calculateVotingWeight(
            session.config.votingType,
            governanceToken.balanceOf(originalVoter)
        );
        
        // ËÆ∞ÂΩïÂßîÊâòÊäïÁ•®
        session.votes[originalVoter] = Vote({
            voter: msg.sender,
            choices: choices,
            weight: weight,
            timestamp: block.timestamp,
            reason: reason,
            isDelegated: true,
            originalVoter: originalVoter
        });
        
        // Êõ¥Êñ∞ÁªüËÆ°
        session.voters.push(originalVoter);
        session.totalParticipants++;
        session.totalWeight += weight;
        
        // Êõ¥Êñ∞ÈÄâÈ°πÁ•®Êï∞
        _updateOptionVotes(session, choices, weight);
        
        emit VoteCasted(sessionId, originalVoter, choices, weight);
    }
    
    // ÁªìÊùüÊäïÁ•®
    function endVoting(uint256 sessionId) external {
        VotingSession storage session = votingSessions[sessionId];
        require(session.id != 0, "Session does not exist");
        require(block.timestamp > session.config.endTime, "Voting period not ended");
        require(session.status == VotingStatus.Active || session.status == VotingStatus.Pending, "Invalid status");
        
        session.status = VotingStatus.Ended;
        
        // ËÆ°ÁÆóÁªìÊûú
        uint256[] memory results = _calculateResults(session);
        
        emit VotingSessionEnded(sessionId, results);
    }
    
    // È™åËØÅÈÄâÊã©ÊúâÊïàÊÄß
    function _validateChoices(
        VotingSession storage session,
        uint256[] calldata choices
    ) internal view {
        require(choices.length > 0, "No choices provided");
        
        if (session.config.votingType == VotingType.Simple) {
            require(choices.length == 1, "Simple voting allows only one choice");
            require(choices[0] < session.options.length, "Invalid choice");
        } else if (session.config.votingType == VotingType.Ranked) {
            require(choices.length <= session.options.length, "Too many choices");
            // Ê£ÄÊü•ÊéíÂ∫èÁöÑÂîØ‰∏ÄÊÄß
            for (uint256 i = 0; i < choices.length; i++) {
                require(choices[i] < session.options.length, "Invalid choice");
                for (uint256 j = i + 1; j < choices.length; j++) {
                    require(choices[i] != choices[j], "Duplicate choice");
                }
            }
        }
    }
    
    // ËÆ°ÁÆóÊäïÁ•®ÊùÉÈáç
    function _calculateVotingWeight(
        VotingType votingType,
        uint256 tokenBalance
    ) internal pure returns (uint256) {
        if (votingType == VotingType.Simple) {
            return tokenBalance > 0 ? 1 : 0;
        } else if (votingType == VotingType.Weighted) {
            return tokenBalance;
        } else if (votingType == VotingType.Quadratic) {
            return _sqrt(tokenBalance);
        } else {
            return tokenBalance;
        }
    }
    
    // Êõ¥Êñ∞ÈÄâÈ°πÁ•®Êï∞
    function _updateOptionVotes(
        VotingSession storage session,
        uint256[] calldata choices,
        uint256 weight
    ) internal {
        if (session.config.votingType == VotingType.Ranked) {
            // ÊéíÂ∫èÊäïÁ•®ÔºöÁ¨¨‰∏ÄÈÄâÊã©Ëé∑ÂæóÂÖ®ÈÉ®ÊùÉÈáçÔºåÂêéÁª≠ÈÄâÊã©ÊùÉÈáçÈÄíÂáè
            for (uint256 i = 0; i < choices.length; i++) {
                uint256 adjustedWeight = weight / (i + 1);
                session.optionVotes[choices[i]] += adjustedWeight;
            }
        } else {
            // ÂÖ∂‰ªñÊäïÁ•®Á±ªÂûãÔºöÊØè‰∏™ÈÄâÊã©Ëé∑ÂæóÁõ∏ÂêåÊùÉÈáç
            for (uint256 i = 0; i < choices.length; i++) {
                session.optionVotes[choices[i]] += weight;
            }
        }
    }
    
    // ËÆ°ÁÆóÊäïÁ•®ÁªìÊûú
    function _calculateResults(
        VotingSession storage session
    ) internal view returns (uint256[] memory) {
        uint256[] memory results = new uint256[](session.options.length);
        
        for (uint256 i = 0; i < session.options.length; i++) {
            results[i] = session.optionVotes[i];
        }
        
        return results;
    }
    
    // Ê£ÄÊü•ÂßîÊâòÂÖ≥Á≥ªÔºàÁÆÄÂåñÂÆûÁé∞Ôºâ
    function _isDelegatedBy(address delegator, address delegate) 
        internal pure returns (bool) {
        // ÂÆûÈôÖÂÆûÁé∞Â∫îËØ•Êü•ËØ¢ÂßîÊâòÂêàÁ∫¶
        return true;
    }
    
    // Âπ≥ÊñπÊ†πËÆ°ÁÆóÔºàÁÆÄÂåñÂÆûÁé∞Ôºâ
    function _sqrt(uint256 x) internal pure returns (uint256) {
        if (x == 0) return 0;
        uint256 z = (x + 1) / 2;
        uint256 y = x;
        while (z < y) {
            y = z;
            z = (x / z + z) / 2;
        }
        return y;
    }
    
    // Ëé∑ÂèñÊäïÁ•®‰ºöËØù‰ø°ÊÅØ
    function getVotingSession(uint256 sessionId) 
        external view returns (
            string memory title,
            string memory description,
            string[] memory options,
            VotingConfig memory config,
            VotingStatus status,
            uint256 totalParticipants,
            uint256 totalWeight
        ) {
        VotingSession storage session = votingSessions[sessionId];
        return (
            session.title,
            session.description,
            session.options,
            session.config,
            session.status,
            session.totalParticipants,
            session.totalWeight
        );
    }
    
    // Ëé∑ÂèñÊäïÁ•®ÁªìÊûú
    function getVotingResults(uint256 sessionId) 
        external view returns (uint256[] memory) {
        VotingSession storage session = votingSessions[sessionId];
        require(session.status == VotingStatus.Ended, "Voting not ended");
        
        uint256[] memory results = new uint256[](session.options.length);
        for (uint256 i = 0; i < session.options.length; i++) {
            results[i] = session.optionVotes[i];
        }
        
        return results;
    }
    
    // Ëé∑ÂèñÁî®Êà∑ÊäïÁ•®
    function getUserVote(uint256 sessionId, address voter) 
        external view returns (Vote memory) {
        return votingSessions[sessionId].votes[voter];
    }
    
    // ÁÆ°ÁêÜÂáΩÊï∞
    function addAuthorizedCreator(address creator) external {
        authorizedCreators[creator] = true;
    }
    
    function removeAuthorizedCreator(address creator) external {
        authorizedCreators[creator] = false;
    }
}
```

---

## üë• Á§æ‰∫§ÂäüËÉΩÂÆûÁé∞

### Á§æÂå∫‰∫íÂä®Á≥ªÁªü

```solidity
// Á§æÂå∫‰∫íÂä®ÂêàÁ∫¶
contract CommunityInteraction {
    struct UserProfile {
        string username;
        string bio;
        string avatar;
        uint256 reputation;
        uint256 joinTime;
        bool verified;
        mapping(string => string) socialLinks;
    }
    
    struct Post {
        uint256 id;
        address author;
        string content;
        string[] tags;
        uint256 timestamp;
        uint256 likes;
        uint256 dislikes;
        uint256 shares;
        uint256 comments;
        bool pinned;
        mapping(address => bool) likedBy;
        mapping(address => bool) dislikedBy;
    }
    
    struct Comment {
        uint256 id;
        uint256 postId;
        address author;
        string content;
        uint256 timestamp;
        uint256 likes;
        uint256 parentCommentId; // 0 for top-level comments
        mapping(address => bool) likedBy;
    }
    
    mapping(address => UserProfile) public userProfiles;
    mapping(uint256 => Post) public posts;
    mapping(uint256 => Comment) public comments;
    mapping(string => uint256[]) public taggedPosts; // tag => post IDs
    
    uint256 public postCount;
    uint256 public commentCount;
    
    // ÂÖ≥Ê≥®Á≥ªÁªü
    mapping(address => mapping(address => bool)) public following;
    mapping(address => address[]) public followers;
    mapping(address => address[]) public followingList;
    mapping(address => uint256) public followerCount;
    mapping(address => uint256) public followingCount;
    
    event ProfileUpdated(address indexed user, string username);
    event PostCreated(uint256 indexed postId, address indexed author, string content);
    event PostLiked(uint256 indexed postId, address indexed user, bool liked);
    event CommentAdded(uint256 indexed commentId, uint256 indexed postId, address indexed author);
    event UserFollowed(address indexed follower, address indexed followed);
    event UserUnfollowed(address indexed follower, address indexed unfollowed);
    
    // ÂàõÂª∫ÊàñÊõ¥Êñ∞Áî®Êà∑ËµÑÊñô
    function updateProfile(
        string calldata username,
        string calldata bio,
        string calldata avatar
    ) external {
        UserProfile storage profile = userProfiles[msg.sender];
        
        if (profile.joinTime == 0) {
            profile.joinTime = block.timestamp;
        }
        
        profile.username = username;
        profile.bio = bio;
        profile.avatar = avatar;
        
        emit ProfileUpdated(msg.sender, username);
    }
    
    // Ê∑ªÂä†Á§æ‰∫§ÈìæÊé•
    function addSocialLink(
        string calldata platform,
        string calldata url
    ) external {
        userProfiles[msg.sender].socialLinks[platform] = url;
    }
    
    // ÂàõÂª∫Â∏ñÂ≠ê
    function createPost(
        string calldata content,
        string[] calldata tags
    ) external returns (uint256 postId) {
        require(bytes(content).length > 0, "Content cannot be empty");
        require(bytes(userProfiles[msg.sender].username).length > 0, "Profile required");
        
        postId = ++postCount;
        
        Post storage post = posts[postId];
        post.id = postId;
        post.author = msg.sender;
        post.content = content;
        post.tags = tags;
        post.timestamp = block.timestamp;
        
        // Ê∑ªÂä†Ê†áÁ≠æÁ¥¢Âºï
        for (uint256 i = 0; i < tags.length; i++) {
            taggedPosts[tags[i]].push(postId);
        }
        
        emit PostCreated(postId, msg.sender, content);
    }
    
    // ÁÇπËµû/ÂèñÊ∂àÁÇπËµûÂ∏ñÂ≠ê
    function likePost(uint256 postId, bool like) external {
        Post storage post = posts[postId];
        require(post.id != 0, "Post does not exist");
        require(post.author != msg.sender, "Cannot like own post");
        
        bool currentlyLiked = post.likedBy[msg.sender];
        bool currentlyDisliked = post.dislikedBy[msg.sender];
        
        if (like) {
            if (!currentlyLiked) {
                post.likedBy[msg.sender] = true;
                post.likes++;
                
                // Â¶ÇÊûú‰πãÂâçÁÇπ‰∫ÜË∏©ÔºåÂèñÊ∂àË∏©
                if (currentlyDisliked) {
                    post.dislikedBy[msg.sender] = false;
                    post.dislikes--;
                }
            }
        } else {
            if (!currentlyDisliked) {
                post.dislikedBy[msg.sender] = true;
                post.dislikes++;
                
                // Â¶ÇÊûú‰πãÂâçÁÇπ‰∫ÜËµûÔºåÂèñÊ∂àËµû
                if (currentlyLiked) {
                    post.likedBy[msg.sender] = false;
                    post.likes--;
                }
            }
        }
        
        emit PostLiked(postId, msg.sender, like);
    }
    
    // Ê∑ªÂä†ËØÑËÆ∫
    function addComment(
        uint256 postId,
        string calldata content,
        uint256 parentCommentId
    ) external returns (uint256 commentId) {
        require(posts[postId].id != 0, "Post does not exist");
        require(bytes(content).length > 0, "Content cannot be empty");
        
        if (parentCommentId > 0) {
            require(comments[parentCommentId].id != 0, "Parent comment does not exist");
            require(comments[parentCommentId].postId == postId, "Parent comment not in same post");
        }
        
        commentId = ++commentCount;
        
        Comment storage comment = comments[commentId];
        comment.id = commentId;
        comment.postId = postId;
        comment.author = msg.sender;
        comment.content = content;
        comment.timestamp = block.timestamp;
        comment.parentCommentId = parentCommentId;
        
        // Êõ¥Êñ∞Â∏ñÂ≠êËØÑËÆ∫Êï∞
        posts[postId].comments++;
        
        emit CommentAdded(commentId, postId, msg.sender);
    }
    
    // ÁÇπËµûËØÑËÆ∫
    function likeComment(uint256 commentId) external {
        Comment storage comment = comments[commentId];
        require(comment.id != 0, "Comment does not exist");
        require(comment.author != msg.sender, "Cannot like own comment");
        require(!comment.likedBy[msg.sender], "Already liked");
        
        comment.likedBy[msg.sender] = true;
        comment.likes++;
    }
    
    // ÂÖ≥Ê≥®Áî®Êà∑
    function followUser(address user) external {
        require(user != msg.sender, "Cannot follow yourself");
        require(!following[msg.sender][user], "Already following");
        
        following[msg.sender][user] = true;
        followers[user].push(msg.sender);
        followingList[msg.sender].push(user);
        
        followerCount[user]++;
        followingCount[msg.sender]++;
        
        emit UserFollowed(msg.sender, user);
    }
    
    // ÂèñÊ∂àÂÖ≥Ê≥®Áî®Êà∑
    function unfollowUser(address user) external {
        require(following[msg.sender][user], "Not following");
        
        following[msg.sender][user] = false;
        
        // ‰ªéÂÖ≥Ê≥®ËÄÖÂàóË°®‰∏≠ÁßªÈô§
        address[] storage userFollowers = followers[user];
        for (uint256 i = 0; i < userFollowers.length; i++) {
            if (userFollowers[i] == msg.sender) {
                userFollowers[i] = userFollowers[userFollowers.length - 1];
                userFollowers.pop();
                break;
            }
        }
        
        // ‰ªéÂÖ≥Ê≥®ÂàóË°®‰∏≠ÁßªÈô§
        address[] storage myFollowing = followingList[msg.sender];
        for (uint256 i = 0; i < myFollowing.length; i++) {
            if (myFollowing[i] == user) {
                myFollowing[i] = myFollowing[myFollowing.length - 1];
                myFollowing.pop();
                break;
            }
        }
        
        followerCount[user]--;
        followingCount[msg.sender]--;
        
        emit UserUnfollowed(msg.sender, user);
    }
    
    // Ëé∑ÂèñÁî®Êà∑ËµÑÊñô
    function getUserProfile(address user) 
        external view returns (
            string memory username,
            string memory bio,
            string memory avatar,
            uint256 reputation,
            uint256 joinTime,
            bool verified
        ) {
        UserProfile storage profile = userProfiles[user];
        return (
            profile.username,
            profile.bio,
            profile.avatar,
            profile.reputation,
            profile.joinTime,
            profile.verified
        );
    }
    
    // Ëé∑ÂèñÂ∏ñÂ≠ê‰ø°ÊÅØ
    function getPost(uint256 postId) 
        external view returns (
            address author,
            string memory content,
            string[] memory tags,
            uint256 timestamp,
            uint256 likes,
            uint256 dislikes,
            uint256 shares,
            uint256 comments
        ) {
        Post storage post = posts[postId];
        return (
            post.author,
            post.content,
            post.tags,
            post.timestamp,
            post.likes,
            post.dislikes,
            post.shares,
            post.comments
        );
    }
    
    // Ëé∑ÂèñËØÑËÆ∫‰ø°ÊÅØ
    function getComment(uint256 commentId) 
        external view returns (
            uint256 postId,
            address author,
            string memory content,
            uint256 timestamp,
            uint256 likes,
            uint256 parentCommentId
        ) {
        Comment storage comment = comments[commentId];
        return (
            comment.postId,
            comment.author,
            comment.content,
            comment.timestamp,
            comment.likes,
            comment.parentCommentId
        );
    }
    
    // Ëé∑ÂèñÊ†áÁ≠æÁõ∏ÂÖ≥Â∏ñÂ≠ê
    function getPostsByTag(string calldata tag) 
        external view returns (uint256[] memory) {
        return taggedPosts[tag];
    }
    
    // Ëé∑ÂèñÂÖ≥Ê≥®ËÄÖÂàóË°®
    function getFollowers(address user) 
        external view returns (address[] memory) {
        return followers[user];
    }
    
    // Ëé∑ÂèñÂÖ≥Ê≥®ÂàóË°®
    function getFollowing(address user) 
        external view returns (address[] memory) {
        return followingList[user];
    }
    
    // Ê£ÄÊü•ÊòØÂê¶ÂÖ≥Ê≥®
    function isFollowing(address follower, address followed) 
        external view returns (bool) {
        return following[follower][followed];
    }
    
    // Ëé∑ÂèñÁ§æ‰∫§ÈìæÊé•
    function getSocialLink(address user, string calldata platform) 
        external view returns (string memory) {
        return userProfiles[user].socialLinks[platform];
    }
}
```

---

## üéØ ÊøÄÂä±Êú∫Âà∂ËÆæËÆ°

### Ë¥°ÁåÆÂ•ñÂä±Á≥ªÁªü

```solidity
// Ë¥°ÁåÆÂ•ñÂä±ÂêàÁ∫¶
contract ContributionRewards {
    enum ContributionType {
        Proposal,
        Vote,
        Comment,
        CodeReview,
        Documentation,
        BugReport,
        Community
    }
    
    struct Contribution {
        uint256 id;
        address contributor;
        ContributionType contributionType;
        string description;
        uint256 timestamp;
        uint256 impact;      // ÂΩ±ÂìçÂäõËØÑÂàÜ
        uint256 quality;     // Ë¥®ÈáèËØÑÂàÜ
        uint256 reward;      // Â•ñÂä±Êï∞Èáè
        bool verified;       // ÊòØÂê¶Â∑≤È™åËØÅ
        address[] reviewers; // ËØÑÂÆ°ËÄÖ
        mapping(address => uint256) reviews; // ËØÑÂÆ°ËØÑÂàÜ
    }
    
    struct RewardPool {
        uint256 totalPool;        // ÊÄªÂ•ñÂä±Ê±†
        uint256 distributedRewards; // Â∑≤ÂàÜÂèëÂ•ñÂä±
        uint256 currentPeriod;    // ÂΩìÂâçÂë®Êúü
        uint256 periodDuration;   // Âë®ÊúüÊåÅÁª≠Êó∂Èó¥
        uint256 lastDistribution; // ‰∏äÊ¨°ÂàÜÂèëÊó∂Èó¥
        mapping(ContributionType => uint256) typeWeights; // Ë¥°ÁåÆÁ±ªÂûãÊùÉÈáç
    }
    
    struct UserStats {
        uint256 totalContributions;
        uint256 totalRewards;
        uint256 reputation;
        mapping(ContributionType => uint256) contributionCounts;
        mapping(ContributionType => uint256) contributionRewards;
    }
    
    mapping(uint256 => Contribution) public contributions;
    mapping(address => UserStats) public userStats;
    RewardPool public rewardPool;
    
    uint256 public contributionCount;
    IERC20 public rewardToken;
    
    // ÊùÉÈôêÁÆ°ÁêÜ
    mapping(address => bool) public reviewers;
    mapping(address => bool) public admins;
    
    event ContributionSubmitted(
        uint256 indexed contributionId,
        address indexed contributor,
        ContributionType contributionType,
        string description
    );
    
    event ContributionReviewed(
        uint256 indexed contributionId,
        address indexed reviewer,
        uint256 impact,
        uint256 quality
    );
    
    event RewardDistributed(
        uint256 indexed contributionId,
        address indexed contributor,
        uint256 reward
    );
    
    event RewardPoolUpdated(
        uint256 totalPool,
        uint256 currentPeriod
    );
    
    modifier onlyReviewer() {
        require(reviewers[msg.sender], "Not a reviewer");
        _;
    }
    
    modifier onlyAdmin() {
        require(admins[msg.sender], "Not an admin");
        _;
    }
    
    constructor(
        address _rewardToken,
        uint256 _periodDuration
    ) {
        rewardToken = IERC20(_rewardToken);
        rewardPool.periodDuration = _periodDuration;
        rewardPool.currentPeriod = 1;
        rewardPool.lastDistribution = block.timestamp;
        
        // ËÆæÁΩÆÈªòËÆ§ÊùÉÈáç
        rewardPool.typeWeights[ContributionType.Proposal] = 100;
        rewardPool.typeWeights[ContributionType.Vote] = 10;
        rewardPool.typeWeights[ContributionType.Comment] = 20;
        rewardPool.typeWeights[ContributionType.CodeReview] = 80;
        rewardPool.typeWeights[ContributionType.Documentation] = 60;
        rewardPool.typeWeights[ContributionType.BugReport] = 70;
        rewardPool.typeWeights[ContributionType.Community] = 40;
        
        admins[msg.sender] = true;
    }
    
    // Êèê‰∫§Ë¥°ÁåÆ
    function submitContribution(
        ContributionType contributionType,
        string calldata description
    ) external returns (uint256 contributionId) {
        contributionId = ++contributionCount;
        
        Contribution storage contribution = contributions[contributionId];
        contribution.id = contributionId;
        contribution.contributor = msg.sender;
        contribution.contributionType = contributionType;
        contribution.description = description;
        contribution.timestamp = block.timestamp;
        
        // Êõ¥Êñ∞Áî®Êà∑ÁªüËÆ°
        UserStats storage stats = userStats[msg.sender];
        stats.totalContributions++;
        stats.contributionRewards[contribution.contributionType] += reward;
        stats.reputation += reward / 100; // Â£∞Ë™âÂ¢ûÈïø
        
        emit RewardDistributed(contributionId, contribution.contributor, reward);
    }
    
    // Ê∑ªÂä†Â•ñÂä±Âà∞Ê±†Â≠ê
    function addRewardPool(uint256 amount) external onlyAdmin {
        rewardToken.transferFrom(msg.sender, address(this), amount);
        rewardPool.totalPool += amount;
        
        emit RewardPoolUpdated(rewardPool.totalPool, rewardPool.currentPeriod);
    }
    
    // ÂºÄÂßãÊñ∞Âë®Êúü
    function startNewPeriod() external onlyAdmin {
        require(
            block.timestamp >= rewardPool.lastDistribution + rewardPool.periodDuration,
            "Period not ended"
        );
        
        rewardPool.currentPeriod++;
        rewardPool.lastDistribution = block.timestamp;
        rewardPool.distributedRewards = 0; // ÈáçÁΩÆÂ∑≤ÂàÜÂèëÂ•ñÂä±
        
        emit RewardPoolUpdated(rewardPool.totalPool, rewardPool.currentPeriod);
    }
    
    // ËÆæÁΩÆË¥°ÁåÆÁ±ªÂûãÊùÉÈáç
    function setContributionWeight(
        ContributionType contributionType,
        uint256 weight
    ) external onlyAdmin {
        rewardPool.typeWeights[contributionType] = weight;
    }
    
    // Ê∑ªÂä†ËØÑÂÆ°ËÄÖ
    function addReviewer(address reviewer) external onlyAdmin {
        reviewers[reviewer] = true;
    }
    
    // ÁßªÈô§ËØÑÂÆ°ËÄÖ
    function removeReviewer(address reviewer) external onlyAdmin {
        reviewers[reviewer] = false;
    }
    
    // Ëé∑ÂèñË¥°ÁåÆ‰ø°ÊÅØ
    function getContribution(uint256 contributionId) 
        external view returns (
            address contributor,
            ContributionType contributionType,
            string memory description,
            uint256 timestamp,
            uint256 impact,
            uint256 quality,
            uint256 reward,
            bool verified
        ) {
        Contribution storage contribution = contributions[contributionId];
        return (
            contribution.contributor,
            contribution.contributionType,
            contribution.description,
            contribution.timestamp,
            contribution.impact,
            contribution.quality,
            contribution.reward,
            contribution.verified
        );
    }
    
    // Ëé∑ÂèñÁî®Êà∑ÁªüËÆ°
    function getUserStats(address user) 
        external view returns (
            uint256 totalContributions,
            uint256 totalRewards,
            uint256 reputation
        ) {
        UserStats storage stats = userStats[user];
        return (
            stats.totalContributions,
            stats.totalRewards,
            stats.reputation
        );
    }
    
    // Ëé∑ÂèñÁî®Êà∑ÁâπÂÆöÁ±ªÂûãË¥°ÁåÆÊï∞Èáè
    function getUserContributionCount(
        address user,
        ContributionType contributionType
    ) external view returns (uint256) {
        return userStats[user].contributionCounts[contributionType];
    }
    
    // Ëé∑ÂèñÂ•ñÂä±Ê±†‰ø°ÊÅØ
    function getRewardPoolInfo() 
        external view returns (
            uint256 totalPool,
            uint256 distributedRewards,
            uint256 currentPeriod,
            uint256 lastDistribution
        ) {
        return (
            rewardPool.totalPool,
            rewardPool.distributedRewards,
            rewardPool.currentPeriod,
            rewardPool.lastDistribution
        );
    }
}
```

---

## üõ†Ô∏è Á§æÂå∫Ëá™Ê≤ªÂ∑•ÂÖ∑

### ‰∫âËÆÆËß£ÂÜ≥Êú∫Âà∂

```solidity
// ‰∫âËÆÆËß£ÂÜ≥ÂêàÁ∫¶
contract DisputeResolution {
    enum DisputeStatus { Open, UnderReview, Resolved, Closed }
    enum DisputeType { Governance, Technical, Community, Financial }
    
    struct Dispute {
        uint256 id;
        address complainant;
        address respondent;
        DisputeType disputeType;
        string title;
        string description;
        string evidence;
        uint256 createdAt;
        uint256 resolvedAt;
        DisputeStatus status;
        address[] arbitrators;
        mapping(address => bool) votes; // true = support complainant
        uint256 supportVotes;
        uint256 opposeVotes;
        string resolution;
        uint256 compensationAmount;
    }
    
    struct Arbitrator {
        address arbitratorAddress;
        string name;
        uint256 reputation;
        uint256 casesHandled;
        uint256 successRate;
        bool active;
        string[] specialties;
    }
    
    mapping(uint256 => Dispute) public disputes;
    mapping(address => Arbitrator) public arbitrators;
    address[] public arbitratorList;
    
    uint256 public disputeCount;
    uint256 public arbitrationFee;
    uint256 public minArbitrators;
    
    IERC20 public governanceToken;
    
    event DisputeCreated(
        uint256 indexed disputeId,
        address indexed complainant,
        address indexed respondent,
        DisputeType disputeType
    );
    
    event ArbitratorAssigned(
        uint256 indexed disputeId,
        address indexed arbitrator
    );
    
    event DisputeVoted(
        uint256 indexed disputeId,
        address indexed arbitrator,
        bool supportComplainant
    );
    
    event DisputeResolved(
        uint256 indexed disputeId,
        string resolution,
        uint256 compensationAmount
    );
    
    constructor(
        address _governanceToken,
        uint256 _arbitrationFee,
        uint256 _minArbitrators
    ) {
        governanceToken = IERC20(_governanceToken);
        arbitrationFee = _arbitrationFee;
        minArbitrators = _minArbitrators;
    }
    
    // ÂàõÂª∫‰∫âËÆÆ
    function createDispute(
        address respondent,
        DisputeType disputeType,
        string calldata title,
        string calldata description,
        string calldata evidence
    ) external returns (uint256 disputeId) {
        require(respondent != msg.sender, "Cannot dispute with yourself");
        require(bytes(title).length > 0, "Title required");
        require(bytes(description).length > 0, "Description required");
        
        // Êî∂Âèñ‰ª≤Ë£ÅË¥π
        governanceToken.transferFrom(msg.sender, address(this), arbitrationFee);
        
        disputeId = ++disputeCount;
        
        Dispute storage dispute = disputes[disputeId];
        dispute.id = disputeId;
        dispute.complainant = msg.sender;
        dispute.respondent = respondent;
        dispute.disputeType = disputeType;
        dispute.title = title;
        dispute.description = description;
        dispute.evidence = evidence;
        dispute.createdAt = block.timestamp;
        dispute.status = DisputeStatus.Open;
        
        // Ëá™Âä®ÂàÜÈÖç‰ª≤Ë£ÅÂëò
        _assignArbitrators(disputeId);
        
        emit DisputeCreated(disputeId, msg.sender, respondent, disputeType);
    }
    
    // ÂàÜÈÖç‰ª≤Ë£ÅÂëò
    function _assignArbitrators(uint256 disputeId) internal {
        Dispute storage dispute = disputes[disputeId];
        
        // ÁÆÄÂåñÂÆûÁé∞ÔºöÈöèÊú∫ÈÄâÊã©Ê¥ªË∑ÉÁöÑ‰ª≤Ë£ÅÂëò
        uint256 assignedCount = 0;
        for (uint256 i = 0; i < arbitratorList.length && assignedCount < minArbitrators; i++) {
            address arbitrator = arbitratorList[i];
            if (arbitrators[arbitrator].active && 
                arbitrator != dispute.complainant && 
                arbitrator != dispute.respondent) {
                dispute.arbitrators.push(arbitrator);
                assignedCount++;
                
                emit ArbitratorAssigned(disputeId, arbitrator);
            }
        }
        
        if (assignedCount >= minArbitrators) {
            dispute.status = DisputeStatus.UnderReview;
        }
    }
    
    // ‰ª≤Ë£ÅÂëòÊäïÁ•®
    function voteOnDispute(
        uint256 disputeId,
        bool supportComplainant,
        string calldata reasoning
    ) external {
        Dispute storage dispute = disputes[disputeId];
        require(dispute.status == DisputeStatus.UnderReview, "Dispute not under review");
        require(_isArbitratorAssigned(disputeId, msg.sender), "Not assigned arbitrator");
        require(!_hasVoted(disputeId, msg.sender), "Already voted");
        
        dispute.votes[msg.sender] = supportComplainant;
        
        if (supportComplainant) {
            dispute.supportVotes++;
        } else {
            dispute.opposeVotes++;
        }
        
        emit DisputeVoted(disputeId, msg.sender, supportComplainant);
        
        // Ê£ÄÊü•ÊòØÂê¶ÊâÄÊúâ‰ª≤Ë£ÅÂëòÈÉΩÂ∑≤ÊäïÁ•®
        if (dispute.supportVotes + dispute.opposeVotes == dispute.arbitrators.length) {
            _resolveDispute(disputeId);
        }
    }
    
    // Ëß£ÂÜ≥‰∫âËÆÆ
    function _resolveDispute(uint256 disputeId) internal {
        Dispute storage dispute = disputes[disputeId];
        
        bool complainantWins = dispute.supportVotes > dispute.opposeVotes;
        
        if (complainantWins) {
            // Áî≥ËØ∑‰∫∫ËÉúËØâ
            dispute.resolution = "Complainant wins";
            dispute.compensationAmount = arbitrationFee; // ÈÄÄËøò‰ª≤Ë£ÅË¥π
            
            // ËΩ¨ÁßªË°•ÂÅøÈáëÁªôÁî≥ËØ∑‰∫∫
            governanceToken.transfer(dispute.complainant, dispute.compensationAmount);
        } else {
            // Ë¢´Áî≥ËØ∑‰∫∫ËÉúËØâ
            dispute.resolution = "Respondent wins";
            dispute.compensationAmount = 0;
            
            // ‰ª≤Ë£ÅË¥π‰∏çÈÄÄËøòÔºå‰Ωú‰∏∫Á≥ªÁªüÊî∂ÂÖ•
        }
        
        dispute.status = DisputeStatus.Resolved;
        dispute.resolvedAt = block.timestamp;
        
        // Êõ¥Êñ∞‰ª≤Ë£ÅÂëòÁªüËÆ°
        _updateArbitratorStats(disputeId, complainantWins);
        
        emit DisputeResolved(disputeId, dispute.resolution, dispute.compensationAmount);
    }
    
    // Êõ¥Êñ∞‰ª≤Ë£ÅÂëòÁªüËÆ°
    function _updateArbitratorStats(uint256 disputeId, bool complainantWins) internal {
        Dispute storage dispute = disputes[disputeId];
        
        for (uint256 i = 0; i < dispute.arbitrators.length; i++) {
            address arbitrator = dispute.arbitrators[i];
            Arbitrator storage arb = arbitrators[arbitrator];
            
            arb.casesHandled++;
            
            // Â¶ÇÊûú‰ª≤Ë£ÅÂëòÁöÑÊäïÁ•®‰∏éÊúÄÁªàÁªìÊûú‰∏ÄËá¥ÔºåÂ¢ûÂä†ÊàêÂäüÁéá
            bool votedCorrectly = dispute.votes[arbitrator] == complainantWins;
            if (votedCorrectly) {
                arb.successRate = (arb.successRate * (arb.casesHandled - 1) + 100) / arb.casesHandled;
            } else {
                arb.successRate = (arb.successRate * (arb.casesHandled - 1)) / arb.casesHandled;
            }
            
            // Êõ¥Êñ∞Â£∞Ë™â
            if (votedCorrectly) {
                arb.reputation += 10;
            } else {
                arb.reputation = arb.reputation > 5 ? arb.reputation - 5 : 0;
            }
        }
    }
    
    // Ê∑ªÂä†‰ª≤Ë£ÅÂëò
    function addArbitrator(
        address arbitratorAddress,
        string calldata name,
        string[] calldata specialties
    ) external {
        require(!arbitrators[arbitratorAddress].active, "Already an arbitrator");
        
        arbitrators[arbitratorAddress] = Arbitrator({
            arbitratorAddress: arbitratorAddress,
            name: name,
            reputation: 100, // ÂàùÂßãÂ£∞Ë™â
            casesHandled: 0,
            successRate: 0,
            active: true,
            specialties: specialties
        });
        
        arbitratorList.push(arbitratorAddress);
    }
    
    // Ê£ÄÊü•ÊòØÂê¶‰∏∫ÊåáÂÆö‰ª≤Ë£ÅÂëò
    function _isArbitratorAssigned(uint256 disputeId, address arbitrator) 
        internal view returns (bool) {
        Dispute storage dispute = disputes[disputeId];
        for (uint256 i = 0; i < dispute.arbitrators.length; i++) {
            if (dispute.arbitrators[i] == arbitrator) {
                return true;
            }
        }
        return false;
    }
    
    // Ê£ÄÊü•ÊòØÂê¶Â∑≤ÊäïÁ•®
    function _hasVoted(uint256 disputeId, address arbitrator) 
        internal view returns (bool) {
        Dispute storage dispute = disputes[disputeId];
        // ÁÆÄÂåñÂÆûÁé∞ÔºöÊ£ÄÊü•ÊäïÁ•®ËÆ∞ÂΩï
        return dispute.supportVotes + dispute.opposeVotes > 0;
    }
    
    // Ëé∑Âèñ‰∫âËÆÆ‰ø°ÊÅØ
    function getDispute(uint256 disputeId) 
        external view returns (
            address complainant,
            address respondent,
            DisputeType disputeType,
            string memory title,
            string memory description,
            DisputeStatus status,
            uint256 supportVotes,
            uint256 opposeVotes
        ) {
        Dispute storage dispute = disputes[disputeId];
        return (
            dispute.complainant,
            dispute.respondent,
            dispute.disputeType,
            dispute.title,
            dispute.description,
            dispute.status,
            dispute.supportVotes,
            dispute.opposeVotes
        );
    }
    
    // Ëé∑Âèñ‰ª≤Ë£ÅÂëò‰ø°ÊÅØ
    function getArbitrator(address arbitratorAddress) 
        external view returns (
            string memory name,
            uint256 reputation,
            uint256 casesHandled,
            uint256 successRate,
            bool active
        ) {
        Arbitrator storage arb = arbitrators[arbitratorAddress];
        return (
            arb.name,
            arb.reputation,
            arb.casesHandled,
            arb.successRate,
            arb.active
        );
    }
}
```

---

## üí° Â≠¶‰π†ÂøÉÂæó‰∏éÊÄªÁªì

### DAOÊ≤ªÁêÜË¶ÅÁÇπ

1. **ÈÄèÊòéÂ∫¶ÂéüÂàô**
   - ÊâÄÊúâÊèêÊ°àÂíåÊäïÁ•®ÂÖ¨ÂºÄÈÄèÊòé
   - ÂÜ≥Á≠ñËøáÁ®ãÂèØËøΩÊ∫Ø
   - ËµÑÈáë‰ΩøÁî®ÈÄèÊòéÂåñ

2. **ÂèÇ‰∏éÂ∫¶ÊøÄÂä±**
   - Â§öÊ†∑ÂåñÁöÑÂèÇ‰∏éÊñπÂºè
   - ÂêàÁêÜÁöÑÂ•ñÂä±Êú∫Âà∂
   - Èôç‰ΩéÂèÇ‰∏éÈó®Êßõ

3. **ÊùÉÂäõÂà∂Ë°°**
   - Â§öÂ±ÇÊ≤ªÁêÜÁªìÊûÑ
   - ÂßîÊâòÊäïÁ•®Êú∫Âà∂
   - ‰∫âËÆÆËß£ÂÜ≥Êú∫Âà∂

4. **Á§æÂå∫Âª∫ËÆæ**
   - Áî®Êà∑ÂèãÂ•ΩÁöÑ‰∫§‰∫íÁïåÈù¢
   - ‰∏∞ÂØåÁöÑÁ§æ‰∫§ÂäüËÉΩ
   - ÊúâÊïàÁöÑÊ≤üÈÄöÊ∏†ÈÅì

### ÂÆûË∑µÂª∫ËÆÆ

1. **Ê∏êËøõÂºèÊ≤ªÁêÜ**Ôºö‰ªéÁÆÄÂçïÁöÑÊäïÁ•®ÂºÄÂßãÔºåÈÄêÊ≠•Â¢ûÂä†Â§çÊùÇÂäüËÉΩ
2. **Á§æÂå∫‰ºòÂÖà**ÔºöÂßãÁªà‰ª•Á§æÂå∫Âà©Áõä‰∏∫Âá∫ÂèëÁÇπËÆæËÆ°Êú∫Âà∂
3. **ÊäÄÊúØ‰∏éÊ≤ªÁêÜÁªìÂêà**ÔºöÁî®ÊäÄÊúØÊâãÊÆµ‰øùÈöúÊ≤ªÁêÜÁöÑÂÖ¨Âπ≥ÊÄß
4. **ÊåÅÁª≠‰ºòÂåñ**ÔºöÊ†πÊçÆÁ§æÂå∫ÂèçÈ¶à‰∏çÊñ≠ÊîπËøõÊ≤ªÁêÜÊú∫Âà∂

### Êú™Êù•ÂèëÂ±ïÊñπÂêë

1. **AIËæÖÂä©Ê≤ªÁêÜ**ÔºöÂà©Áî®‰∫∫Â∑•Êô∫ËÉΩ‰ºòÂåñÂÜ≥Á≠ñËøáÁ®ã
2. **Ë∑®ÈìæÊ≤ªÁêÜ**ÔºöÂÆûÁé∞Â§öÈìæÂçèÂêåÊ≤ªÁêÜ
3. **ÈöêÁßÅ‰øùÊä§ÊäïÁ•®**ÔºöÈõ∂Áü•ËØÜËØÅÊòéÊäÄÊúØÂ∫îÁî®
4. **Âä®ÊÄÅÊ≤ªÁêÜÂèÇÊï∞**ÔºöÊ†πÊçÆÁ§æÂå∫ÂèëÂ±ïËá™Âä®Ë∞ÉÊï¥ÂèÇÊï∞

---

**Â≠¶‰π†ÊÄªÁªì**: DAOÊ≤ªÁêÜÊòØÂå∫ÂùóÈìæÊäÄÊúØÂú®ÁªÑÁªáÁÆ°ÁêÜÈ¢ÜÂüüÁöÑÈáçË¶ÅÂ∫îÁî®ÔºåÈúÄË¶ÅÂú®Âéª‰∏≠ÂøÉÂåñ„ÄÅÊïàÁéáÂíåÂÖ¨Âπ≥ÊÄß‰πãÈó¥ÊâæÂà∞Âπ≥Ë°°„ÄÇÈÄöËøáÂêàÁêÜÁöÑÊú∫Âà∂ËÆæËÆ°ÔºåÂèØ‰ª•ÊûÑÂª∫‰∏Ä‰∏™ÁúüÊ≠£Áî±Á§æÂå∫È©±Âä®ÁöÑËá™Ê≤ªÁªÑÁªá„ÄÇ

**ÂÆûË∑µÊñπÂêë**: ÈáçÁÇπÂÖ≥Ê≥®Áî®Êà∑‰ΩìÈ™åÂíåÁ§æÂå∫ÂèÇ‰∏éÂ∫¶ÔºåÊé¢Á¥¢ÂàõÊñ∞ÁöÑÊ≤ªÁêÜÊ®°ÂºèÂíåÊøÄÂä±Êú∫Âà∂Ôºå‰∏∫Web3Êó∂‰ª£ÁöÑÁªÑÁªáÂΩ¢ÊÄÅË¥°ÁåÆÂäõÈáè„ÄÇionCounts[contributionType]++;
        
        emit ContributionSubmitted(
            contributionId,
            msg.sender,
            contributionType,
            description
        );
    }
    
    // ËØÑÂÆ°Ë¥°ÁåÆ
    function reviewContribution(
        uint256 contributionId,
        uint256 impact,
        uint256 quality
    ) external onlyReviewer {
        Contribution storage contribution = contributions[contributionId];
        require(contribution.id != 0, "Contribution does not exist");
        require(contribution.reviews[msg.sender] == 0, "Already reviewed");
        require(impact <= 100 && quality <= 100, "Score must be 0-100");
        
        contribution.reviews[msg.sender] = (impact + quality) / 2;
        contribution.reviewers.push(msg.sender);
        
        // Êõ¥Êñ∞Âπ≥ÂùáËØÑÂàÜ
        _updateContributionScores(contributionId);
        
        emit ContributionReviewed(contributionId, msg.sender, impact, quality);
    }
    
    // Êõ¥Êñ∞Ë¥°ÁåÆËØÑÂàÜ
    function _updateContributionScores(uint256 contributionId) internal {
        Contribution storage contribution = contributions[contributionId];
        
        if (contribution.reviewers.length == 0) return;
        
        uint256 totalScore = 0;
        for (uint256 i = 0; i < contribution.reviewers.length; i++) {
            totalScore += contribution.reviews[contribution.reviewers[i]];
        }
        
        uint256 averageScore = totalScore / contribution.reviewers.length;
        contribution.impact = averageScore;
        contribution.quality = averageScore;
        
        // Â¶ÇÊûúÊúâË∂≥Â§üÁöÑËØÑÂÆ°ÔºåÊ†áËÆ∞‰∏∫Â∑≤È™åËØÅ
        if (contribution.reviewers.length >= 3) {
            contribution.verified = true;
            _calculateReward(contributionId);
        }
    }
    
    // ËÆ°ÁÆóÂ•ñÂä±
    function _calculateReward(uint256 contributionId) internal {
        Contribution storage contribution = contributions[contributionId];
        require(contribution.verified, "Contribution not verified");
        require(contribution.reward == 0, "Reward already calculated");
        
        // Âü∫Á°ÄÂ•ñÂä± = Á±ªÂûãÊùÉÈáç * Ë¥®ÈáèËØÑÂàÜ * ÂΩ±ÂìçÂäõËØÑÂàÜ
        uint256 baseReward = rewardPool.typeWeights[contribution.contributionType];
        uint256 qualityMultiplier = contribution.quality;
        uint256 impactMultiplier = contribution.impact;
        
        uint256 reward = (baseReward * qualityMultiplier * impactMultiplier) / 10000;
        
        // Ê£ÄÊü•Â•ñÂä±Ê±†‰ΩôÈ¢ù
        uint256 availableRewards = rewardPool.totalPool - rewardPool.distributedRewards;
        if (reward > availableRewards) {
            reward = availableRewards;
        }
        
        contribution.reward = reward;
        
        // ÂàÜÂèëÂ•ñÂä±
        if (reward > 0) {
            _distributeReward(contributionId, reward);
        }
    }
    
    // ÂàÜÂèëÂ•ñÂä±
    function _distributeReward(uint256 contributionId, uint256 reward) internal {
        Contribution storage contribution = contributions[contributionId];
        
        // ËΩ¨Áßª‰ª£Â∏Å
        rewardToken.transfer(contribution.contributor, reward);
        
        // Êõ¥Êñ∞ÁªüËÆ°
        rewardPool.distributedRewards += reward;
        UserStats storage stats = userStats[contribution.contributor];
        stats.totalRewards += reward;
        stats.contribut