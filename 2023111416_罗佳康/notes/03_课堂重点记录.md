# 课堂重点记录

> **学习者**: 罗佳康  
> **学号**: 2023110555  
> **学习特色**: 注重实际应用和项目实践  
> **代码风格**: 实用主义、项目导向  
> **笔记重点**: 实际项目开发和部署  
> **项目代码**: PracticalDApp.sol - 实用去中心化应用  
> **记录时间**: 2024年春季学期

---

## 📚 第一周：DApp架构设计与实现

### 课堂主题：从零到一构建去中心化应用
**时间**: 2024年3月4日  
**重点内容**:

#### 1. DApp架构设计原则
- **前后端分离**: 智能合约作为后端，Web3前端交互
- **模块化设计**: 合约功能模块化，便于维护和升级
- **用户体验优先**: 简化交互流程，提升用户友好性
- **安全性考虑**: 多层安全防护，保护用户资产

#### 2. 实用去中心化应用系统
```solidity
// PracticalDApp.sol - 实用去中心化应用
pragma solidity ^0.8.19;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/security/Pausable.sol";
import "@openzeppelin/contracts/utils/math/SafeMath.sol";

/**
 * @title PracticalDApp
 * @author 罗佳康
 * @notice 实用的去中心化应用，集成多种常用功能
 * @dev 包含代币管理、投票治理、奖励分发等核心功能
 */
contract PracticalDApp is ERC20, Ownable, ReentrancyGuard, Pausable {
    using SafeMath for uint256;
    
    // ✅ 核心状态变量
    
    /// @notice 应用版本号
    string public constant VERSION = "1.0.0";
    
    /// @notice 最大供应量
    uint256 public constant MAX_SUPPLY = 1000000 * 10**18;
    
    /// @notice 用户信息结构
    struct UserInfo {
        uint256 balance;           // 用户余额
        uint256 stakingAmount;     // 质押金额
        uint256 rewardDebt;        // 奖励债务
        uint256 lastActionTime;    // 最后操作时间
        bool isActive;             // 是否活跃用户
        uint256 referralCount;     // 推荐人数
        address referrer;          // 推荐人
    }
    
    /// @notice 用户信息映射
    mapping(address => UserInfo) public userInfo;
    
    /// @notice 活跃用户列表
    address[] public activeUsers;
    
    /// @notice 质押池信息
    struct StakingPool {
        uint256 totalStaked;       // 总质押量
        uint256 rewardPerSecond;   // 每秒奖励
        uint256 lastRewardTime;    // 最后奖励时间
        uint256 accRewardPerShare; // 累积每股奖励
        bool isActive;             // 池子是否活跃
    }
    
    /// @notice 质押池
    StakingPool public stakingPool;
    
    /// @notice 治理提案结构
    struct Proposal {
        uint256 id;                // 提案ID
        address proposer;          // 提案人
        string title;              // 提案标题
        string description;        // 提案描述
        uint256 startTime;         // 开始时间
        uint256 endTime;           // 结束时间
        uint256 forVotes;          // 赞成票数
        uint256 againstVotes;      // 反对票数
        bool executed;             // 是否已执行
        mapping(address => bool) hasVoted; // 是否已投票
        mapping(address => bool) voteChoice; // 投票选择
    }
    
    /// @notice 提案映射
    mapping(uint256 => Proposal) public proposals;
    
    /// @notice 提案计数器
    uint256 public proposalCount;
    
    /// @notice 最小投票权重
    uint256 public constant MIN_VOTING_POWER = 100 * 10**18;
    
    /// @notice 提案执行延迟（秒）
    uint256 public constant EXECUTION_DELAY = 2 days;
    
    // ✅ 事件定义
    
    /// @notice 用户注册事件
    event UserRegistered(
        address indexed user,
        address indexed referrer,
        uint256 timestamp
    );
    
    /// @notice 质押事件
    event Staked(
        address indexed user,
        uint256 amount,
        uint256 timestamp
    );
    
    /// @notice 取消质押事件
    event Unstaked(
        address indexed user,
        uint256 amount,
        uint256 reward,
        uint256 timestamp
    );
    
    /// @notice 奖励领取事件
    event RewardClaimed(
        address indexed user,
        uint256 amount,
        uint256 timestamp
    );
    
    /// @notice 提案创建事件
    event ProposalCreated(
        uint256 indexed proposalId,
        address indexed proposer,
        string title,
        uint256 startTime,
        uint256 endTime
    );
    
    /// @notice 投票事件
    event Voted(
        uint256 indexed proposalId,
        address indexed voter,
        bool choice,
        uint256 votingPower,
        uint256 timestamp
    );
    
    /// @notice 提案执行事件
    event ProposalExecuted(
        uint256 indexed proposalId,
        bool success,
        uint256 timestamp
    );
    
    // ✅ 修饰符
    
    /// @notice 检查用户是否已注册
    modifier onlyRegistered() {
        require(userInfo[msg.sender].isActive, "User not registered");
        _;
    }
    
    /// @notice 检查提案是否存在
    modifier proposalExists(uint256 proposalId) {
        require(proposalId > 0 && proposalId <= proposalCount, "Proposal does not exist");
        _;
    }
    
    /// @notice 检查投票权限
    modifier canVote(uint256 proposalId) {
        require(!proposals[proposalId].hasVoted[msg.sender], "Already voted");
        require(balanceOf(msg.sender) >= MIN_VOTING_POWER, "Insufficient voting power");
        require(
            block.timestamp >= proposals[proposalId].startTime &&
            block.timestamp <= proposals[proposalId].endTime,
            "Voting period not active"
        );
        _;
    }
    
    // ✅ 构造函数
    
    constructor(
        string memory name,
        string memory symbol,
        uint256 initialSupply
    ) ERC20(name, symbol) {
        require(initialSupply <= MAX_SUPPLY, "Initial supply exceeds maximum");
        
        _mint(msg.sender, initialSupply);
        
        // 初始化质押池
        stakingPool = StakingPool({
            totalStaked: 0,
            rewardPerSecond: 1 * 10**15, // 0.001 tokens per second
            lastRewardTime: block.timestamp,
            accRewardPerShare: 0,
            isActive: true
        });
        
        // 注册部署者为第一个用户
        _registerUser(msg.sender, address(0));
    }
    
    // ✅ 用户管理功能
    
    /// @notice 用户注册
    /// @param referrer 推荐人地址
    function registerUser(address referrer) external {
        require(!userInfo[msg.sender].isActive, "User already registered");
        require(referrer != msg.sender, "Cannot refer yourself");
        
        if (referrer != address(0)) {
            require(userInfo[referrer].isActive, "Invalid referrer");
        }
        
        _registerUser(msg.sender, referrer);
    }
    
    /// @notice 内部注册函数
    /// @param user 用户地址
    /// @param referrer 推荐人地址
    function _registerUser(address user, address referrer) internal {
        userInfo[user] = UserInfo({
            balance: 0,
            stakingAmount: 0,
            rewardDebt: 0,
            lastActionTime: block.timestamp,
            isActive: true,
            referralCount: 0,
            referrer: referrer
        });
        
        activeUsers.push(user);
        
        // 更新推荐人信息
        if (referrer != address(0)) {
            userInfo[referrer].referralCount = userInfo[referrer].referralCount.add(1);
            
            // 给推荐人奖励
            uint256 referralReward = 10 * 10**18; // 10 tokens
            if (totalSupply().add(referralReward) <= MAX_SUPPLY) {
                _mint(referrer, referralReward);
            }
        }
        
        emit UserRegistered(user, referrer, block.timestamp);
    }
    
    /// @notice 获取用户详细信息
    /// @param user 用户地址
    /// @return 用户信息结构体
    function getUserInfo(address user) external view returns (
        uint256 balance,
        uint256 stakingAmount,
        uint256 pendingReward,
        uint256 lastActionTime,
        bool isActive,
        uint256 referralCount,
        address referrer
    ) {
        UserInfo memory info = userInfo[user];
        return (
            info.balance,
            info.stakingAmount,
            _calculatePendingReward(user),
            info.lastActionTime,
            info.isActive,
            info.referralCount,
            info.referrer
        );
    }
    
    // ✅ 质押功能
    
    /// @notice 质押代币
    /// @param amount 质押数量
    function stake(uint256 amount) external onlyRegistered whenNotPaused nonReentrant {
        require(amount > 0, "Amount must be greater than 0");
        require(balanceOf(msg.sender) >= amount, "Insufficient balance");
        require(stakingPool.isActive, "Staking pool not active");
        
        // 更新池子奖励
        _updatePool();
        
        UserInfo storage user = userInfo[msg.sender];
        
        // 如果用户已有质押，先领取奖励
        if (user.stakingAmount > 0) {
            uint256 pending = user.stakingAmount.mul(stakingPool.accRewardPerShare).div(1e12).sub(user.rewardDebt);
            if (pending > 0) {
                _safeRewardTransfer(msg.sender, pending);
                emit RewardClaimed(msg.sender, pending, block.timestamp);
            }
        }
        
        // 转移代币到合约
        _transfer(msg.sender, address(this), amount);
        
        // 更新用户和池子信息
        user.stakingAmount = user.stakingAmount.add(amount);
        user.rewardDebt = user.stakingAmount.mul(stakingPool.accRewardPerShare).div(1e12);
        user.lastActionTime = block.timestamp;
        
        stakingPool.totalStaked = stakingPool.totalStaked.add(amount);
        
        emit Staked(msg.sender, amount, block.timestamp);
    }
    
    /// @notice 取消质押
    /// @param amount 取消质押数量
    function unstake(uint256 amount) external onlyRegistered nonReentrant {
        UserInfo storage user = userInfo[msg.sender];
        require(user.stakingAmount >= amount, "Insufficient staked amount");
        require(amount > 0, "Amount must be greater than 0");
        
        // 更新池子奖励
        _updatePool();
        
        // 计算待领取奖励
        uint256 pending = user.stakingAmount.mul(stakingPool.accRewardPerShare).div(1e12).sub(user.rewardDebt);
        
        // 更新用户信息
        user.stakingAmount = user.stakingAmount.sub(amount);
        user.rewardDebt = user.stakingAmount.mul(stakingPool.accRewardPerShare).div(1e12);
        user.lastActionTime = block.timestamp;
        
        // 更新池子信息
        stakingPool.totalStaked = stakingPool.totalStaked.sub(amount);
        
        // 转移代币回用户
        _transfer(address(this), msg.sender, amount);
        
        // 发放奖励
        if (pending > 0) {
            _safeRewardTransfer(msg.sender, pending);
        }
        
        emit Unstaked(msg.sender, amount, pending, block.timestamp);
    }
    
    /// @notice 领取奖励
    function claimReward() external onlyRegistered nonReentrant {
        _updatePool();
        
        UserInfo storage user = userInfo[msg.sender];
        uint256 pending = user.stakingAmount.mul(stakingPool.accRewardPerShare).div(1e12).sub(user.rewardDebt);
        
        require(pending > 0, "No pending reward");
        
        user.rewardDebt = user.stakingAmount.mul(stakingPool.accRewardPerShare).div(1e12);
        user.lastActionTime = block.timestamp;
        
        _safeRewardTransfer(msg.sender, pending);
        
        emit RewardClaimed(msg.sender, pending, block.timestamp);
    }
    
    /// @notice 更新质押池奖励
    function _updatePool() internal {
        if (block.timestamp <= stakingPool.lastRewardTime) {
            return;
        }
        
        if (stakingPool.totalStaked == 0) {
            stakingPool.lastRewardTime = block.timestamp;
            return;
        }
        
        uint256 timeElapsed = block.timestamp.sub(stakingPool.lastRewardTime);
        uint256 reward = timeElapsed.mul(stakingPool.rewardPerSecond);
        
        // 铸造奖励代币（如果不超过最大供应量）
        if (totalSupply().add(reward) <= MAX_SUPPLY) {
            _mint(address(this), reward);
            stakingPool.accRewardPerShare = stakingPool.accRewardPerShare.add(
                reward.mul(1e12).div(stakingPool.totalStaked)
            );
        }
        
        stakingPool.lastRewardTime = block.timestamp;
    }
    
    /// @notice 安全的奖励转移
    /// @param to 接收地址
    /// @param amount 转移数量
    function _safeRewardTransfer(address to, uint256 amount) internal {
        uint256 contractBalance = balanceOf(address(this));
        if (amount > contractBalance) {
            _transfer(address(this), to, contractBalance);
        } else {
            _transfer(address(this), to, amount);
        }
    }
    
    /// @notice 计算待领取奖励
    /// @param user 用户地址
    /// @return 待领取奖励数量
    function _calculatePendingReward(address user) internal view returns (uint256) {
        UserInfo memory userInfoData = userInfo[user];
        uint256 accRewardPerShare = stakingPool.accRewardPerShare;
        
        if (block.timestamp > stakingPool.lastRewardTime && stakingPool.totalStaked != 0) {
            uint256 timeElapsed = block.timestamp.sub(stakingPool.lastRewardTime);
            uint256 reward = timeElapsed.mul(stakingPool.rewardPerSecond);
            accRewardPerShare = accRewardPerShare.add(reward.mul(1e12).div(stakingPool.totalStaked));
        }
        
        return userInfoData.stakingAmount.mul(accRewardPerShare).div(1e12).sub(userInfoData.rewardDebt);
    }
    
    // ✅ 治理功能
    
    /// @notice 创建提案
    /// @param title 提案标题
    /// @param description 提案描述
    /// @param votingPeriod 投票期间（秒）
    /// @return 提案ID
    function createProposal(
        string calldata title,
        string calldata description,
        uint256 votingPeriod
    ) external onlyRegistered returns (uint256) {
        require(bytes(title).length > 0, "Title cannot be empty");
        require(bytes(description).length > 0, "Description cannot be empty");
        require(votingPeriod >= 1 days && votingPeriod <= 30 days, "Invalid voting period");
        require(balanceOf(msg.sender) >= MIN_VOTING_POWER, "Insufficient tokens to create proposal");
        
        proposalCount = proposalCount.add(1);
        uint256 proposalId = proposalCount;
        
        Proposal storage proposal = proposals[proposalId];
        proposal.id = proposalId;
        proposal.proposer = msg.sender;
        proposal.title = title;
        proposal.description = description;
        proposal.startTime = block.timestamp;
        proposal.endTime = block.timestamp.add(votingPeriod);
        proposal.forVotes = 0;
        proposal.againstVotes = 0;
        proposal.executed = false;
        
        emit ProposalCreated(
            proposalId,
            msg.sender,
            title,
            proposal.startTime,
            proposal.endTime
        );
        
        return proposalId;
    }
    
    /// @notice 投票
    /// @param proposalId 提案ID
    /// @param support 是否支持（true为支持，false为反对）
    function vote(
        uint256 proposalId,
        bool support
    ) external onlyRegistered proposalExists(proposalId) canVote(proposalId) {
        Proposal storage proposal = proposals[proposalId];
        uint256 votingPower = balanceOf(msg.sender);
        
        proposal.hasVoted[msg.sender] = true;
        proposal.voteChoice[msg.sender] = support;
        
        if (support) {
            proposal.forVotes = proposal.forVotes.add(votingPower);
        } else {
            proposal.againstVotes = proposal.againstVotes.add(votingPower);
        }
        
        emit Voted(proposalId, msg.sender, support, votingPower, block.timestamp);
    }
    
    /// @notice 执行提案
    /// @param proposalId 提案ID
    function executeProposal(uint256 proposalId) external proposalExists(proposalId) {
        Proposal storage proposal = proposals[proposalId];
        
        require(!proposal.executed, "Proposal already executed");
        require(block.timestamp > proposal.endTime, "Voting period not ended");
        require(
            block.timestamp >= proposal.endTime.add(EXECUTION_DELAY),
            "Execution delay not passed"
        );
        
        bool success = proposal.forVotes > proposal.againstVotes;
        proposal.executed = true;
        
        if (success) {
            // 这里可以添加具体的执行逻辑
            // 例如：参数更新、资金分配等
            _executeProposalLogic(proposalId);
        }
        
        emit ProposalExecuted(proposalId, success, block.timestamp);
    }
    
    /// @notice 执行提案逻辑（可扩展）
    /// @param proposalId 提案ID
    function _executeProposalLogic(uint256 proposalId) internal {
        // 根据提案内容执行相应逻辑
        // 这里是示例实现，实际应用中需要根据具体需求定制
        
        // 示例：如果是奖励率调整提案
        if (keccak256(bytes(proposals[proposalId].title)) == keccak256(bytes("Increase Reward Rate"))) {
            stakingPool.rewardPerSecond = stakingPool.rewardPerSecond.mul(110).div(100); // 增加10%
        }
    }
    
    /// @notice 获取提案信息
    /// @param proposalId 提案ID
    /// @return 提案详细信息
    function getProposal(uint256 proposalId) external view proposalExists(proposalId) returns (
        uint256 id,
        address proposer,
        string memory title,
        string memory description,
        uint256 startTime,
        uint256 endTime,
        uint256 forVotes,
        uint256 againstVotes,
        bool executed
    ) {
        Proposal storage proposal = proposals[proposalId];
        return (
            proposal.id,
            proposal.proposer,
            proposal.title,
            proposal.description,
            proposal.startTime,
            proposal.endTime,
            proposal.forVotes,
            proposal.againstVotes,
            proposal.executed
        );
    }
    
    /// @notice 检查用户是否已对提案投票
    /// @param proposalId 提案ID
    /// @param voter 投票者地址
    /// @return 是否已投票和投票选择
    function getVoteStatus(uint256 proposalId, address voter) 
        external 
        view 
        proposalExists(proposalId) 
        returns (bool hasVoted, bool voteChoice) 
    {
        Proposal storage proposal = proposals[proposalId];
        return (proposal.hasVoted[voter], proposal.voteChoice[voter]);
    }
    
    // ✅ 管理员功能
    
    /// @notice 暂停合约
    function pause() external onlyOwner {
        _pause();
    }
    
    /// @notice 恢复合约
    function unpause() external onlyOwner {
        _unpause();
    }
    
    /// @notice 更新质押池奖励率
    /// @param newRewardPerSecond 新的每秒奖励
    function updateRewardRate(uint256 newRewardPerSecond) external onlyOwner {
        _updatePool();
        stakingPool.rewardPerSecond = newRewardPerSecond;
    }
    
    /// @notice 紧急提取（仅限紧急情况）
    /// @param token 代币地址
    /// @param amount 提取数量
    function emergencyWithdraw(address token, uint256 amount) external onlyOwner {
        if (token == address(0)) {
            payable(owner()).transfer(amount);
        } else {
            IERC20(token).transfer(owner(), amount);
        }
    }
    
    // ✅ 查询功能
    
    /// @notice 获取活跃用户数量
    /// @return 活跃用户数量
    function getActiveUserCount() external view returns (uint256) {
        return activeUsers.length;
    }
    
    /// @notice 获取质押池信息
    /// @return 质押池详细信息
    function getStakingPoolInfo() external view returns (
        uint256 totalStaked,
        uint256 rewardPerSecond,
        uint256 lastRewardTime,
        uint256 accRewardPerShare,
        bool isActive
    ) {
        return (
            stakingPool.totalStaked,
            stakingPool.rewardPerSecond,
            stakingPool.lastRewardTime,
            stakingPool.accRewardPerShare,
            stakingPool.isActive
        );
    }
    
    /// @notice 获取用户待领取奖励
    /// @param user 用户地址
    /// @return 待领取奖励数量
    function getPendingReward(address user) external view returns (uint256) {
        return _calculatePendingReward(user);
    }
    
    /// @notice 批量获取用户信息
    /// @param users 用户地址数组
    /// @return 用户信息数组
    function getBatchUserInfo(address[] calldata users) 
        external 
        view 
        returns (UserInfo[] memory) 
    {
        UserInfo[] memory infos = new UserInfo[](users.length);
        for (uint256 i = 0; i < users.length; i++) {
            infos[i] = userInfo[users[i]];
        }
        return infos;
    }
    
    /// @notice 获取合约统计信息
    /// @return 统计信息
    function getContractStats() external view returns (
        uint256 totalUsers,
        uint256 totalStaked,
        uint256 totalProposals,
        uint256 contractBalance
    ) {
        return (
            activeUsers.length,
            stakingPool.totalStaked,
            proposalCount,
            balanceOf(address(this))
        );
    }
    
    // ✅ 接收ETH功能
    
    /// @notice 接收ETH
    receive() external payable {
        // 可以在这里添加ETH接收逻辑
    }
    
    /// @notice 回退函数
    fallback() external payable {
        // 处理未知函数调用
    }
}
```

**实用设计**: 集成多种常用DApp功能，注重用户体验

---

## 📚 第二周：前端集成与Web3交互

### 课堂主题：构建用户友好的DApp前端
**时间**: 2024年3月11日  
**重点内容**:

#### 1. Web3前端技术栈
- **React + TypeScript**: 现代化前端框架
- **ethers.js**: 以太坊交互库
- **Web3Modal**: 钱包连接管理
- **Material-UI**: 组件库和设计系统

#### 2. DApp前端实现
```typescript
// DAppInterface.tsx - DApp前端接口
import React, { useState, useEffect, useCallback } from 'react';
import { ethers } from 'ethers';
import Web3Modal from 'web3modal';
import WalletConnectProvider from '@walletconnect/web3-provider';
import {
  Container,
  Grid,
  Card,
  CardContent,
  Typography,
  Button,
  TextField,
  Box,
  Tabs,
  Tab,
  Alert,
  CircularProgress,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  Paper,
  Chip,
  LinearProgress
} from '@mui/material';
import { styled } from '@mui/material/styles';

// 合约ABI（简化版）
const CONTRACT_ABI = [
  "function registerUser(address referrer) external",
  "function stake(uint256 amount) external",
  "function unstake(uint256 amount) external",
  "function claimReward() external",
  "function createProposal(string title, string description, uint256 votingPeriod) external returns (uint256)",
  "function vote(uint256 proposalId, bool support) external",
  "function getUserInfo(address user) external view returns (uint256, uint256, uint256, uint256, bool, uint256, address)",
  "function getPendingReward(address user) external view returns (uint256)",
  "function getStakingPoolInfo() external view returns (uint256, uint256, uint256, uint256, bool)",
  "function getProposal(uint256 proposalId) external view returns (uint256, address, string, string, uint256, uint256, uint256, uint256, bool)",
  "function balanceOf(address account) external view returns (uint256)",
  "function proposalCount() external view returns (uint256)",
  "event UserRegistered(address indexed user, address indexed referrer, uint256 timestamp)",
  "event Staked(address indexed user, uint256 amount, uint256 timestamp)",
  "event Unstaked(address indexed user, uint256 amount, uint256 reward, uint256 timestamp)",
  "event RewardClaimed(address indexed user, uint256 amount, uint256 timestamp)",
  "event ProposalCreated(uint256 indexed proposalId, address indexed proposer, string title, uint256 startTime, uint256 endTime)",
  "event Voted(uint256 indexed proposalId, address indexed voter, bool choice, uint256 votingPower, uint256 timestamp)"
];

// 合约地址（需要根据实际部署地址修改）
const CONTRACT_ADDRESS = "0x1234567890123456789012345678901234567890";

// 样式组件
const StyledCard = styled(Card)(({ theme }) => ({
  height: '100%',
  display: 'flex',
  flexDirection: 'column',
  transition: 'transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out',
  '&:hover': {
    transform: 'translateY(-4px)',
    boxShadow: theme.shadows[8],
  },
}));

const GradientButton = styled(Button)(({ theme }) => ({
  background: 'linear-gradient(45deg, #FE6B8B 30%, #FF8E53 90%)',
  border: 0,
  borderRadius: 3,
  boxShadow: '0 3px 5px 2px rgba(255, 105, 135, .3)',
  color: 'white',
  height: 48,
  padding: '0 30px',
  '&:hover': {
    background: 'linear-gradient(45deg, #FE6B8B 60%, #FF8E53 100%)',
  },
}));

// 接口定义
interface UserInfo {
  balance: string;
  stakingAmount: string;
  pendingReward: string;
  lastActionTime: string;
  isActive: boolean;
  referralCount: string;
  referrer: string;
}

interface StakingPoolInfo {
  totalStaked: string;
  rewardPerSecond: string;
  lastRewardTime: string;
  accRewardPerShare: string;
  isActive: boolean;
}

interface Proposal {
  id: string;
  proposer: string;
  title: string;
  description: string;
  startTime: string;
  endTime: string;
  forVotes: string;
  againstVotes: string;
  executed: boolean;
}

// 主组件
const DAppInterface: React.FC = () => {
  // 状态管理
  const [provider, setProvider] = useState<ethers.providers.Web3Provider | null>(null);
  const [signer, setSigner] = useState<ethers.Signer | null>(null);
  const [contract, setContract] = useState<ethers.Contract | null>(null);
  const [account, setAccount] = useState<string>('');
  const [userInfo, setUserInfo] = useState<UserInfo | null>(null);
  const [stakingPoolInfo, setStakingPoolInfo] = useState<StakingPoolInfo | null>(null);
  const [proposals, setProposals] = useState<Proposal[]>([]);
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<string>('');
  const [success, setSuccess] = useState<string>('');
  const [tabValue, setTabValue] = useState<number>(0);
  
  // 表单状态
  const [stakeAmount, setStakeAmount] = useState<string>('');
  const [unstakeAmount, setUnstakeAmount] = useState<string>('');
  const [referrerAddress, setReferrerAddress] = useState<string>('');
  const [proposalTitle, setProposalTitle] = useState<string>('');
  const [proposalDescription, setProposalDescription] = useState<string>('');
  const [votingPeriod, setVotingPeriod] = useState<string>('7');
  
  // 对话框状态
  const [openRegisterDialog, setOpenRegisterDialog] = useState<boolean>(false);
  const [openProposalDialog, setOpenProposalDialog] = useState<boolean>(false);
  
  // Web3Modal配置
  const providerOptions = {
    walletconnect: {
      package: WalletConnectProvider,
      options: {
        infuraId: "YOUR_INFURA_ID" // 替换为实际的Infura ID
      }
    }
  };
  
  const web3Modal = new Web3Modal({
    network: "mainnet",
    cacheProvider: true,
    providerOptions
  });
  
  // 连接钱包
  const connectWallet = useCallback(async () => {
    try {
      setLoading(true);
      const instance = await web3Modal.connect();
      const provider = new ethers.providers.Web3Provider(instance);
      const signer = provider.getSigner();
      const address = await signer.getAddress();
      
      setProvider(provider);
      setSigner(signer);
      setAccount(address);
      
      // 初始化合约
      const contract = new ethers.Contract(CONTRACT_ADDRESS, CONTRACT_ABI, signer);
      setContract(contract);
      
      // 加载用户数据
      await loadUserData(contract, address);
      
      setSuccess('钱包连接成功！');
    } catch (error) {
      console.error('连接钱包失败:', error);
      setError('连接钱包失败，请重试');
    } finally {
      setLoading(false);
    }
  }, []);
  
  // 断开钱包连接
  const disconnectWallet = useCallback(async () => {
    web3Modal.clearCachedProvider();
    setProvider(null);
    setSigner(null);
    setContract(null);
    setAccount('');
    setUserInfo(null);
    setStakingPoolInfo(null);
    setProposals([]);
  }, []);
  
  // 加载用户数据
  const loadUserData = useCallback(async (contract: ethers.Contract, address: string) => {
    try {
      // 获取用户信息
      const userInfoResult = await contract.getUserInfo(address);
      const userInfo: UserInfo = {
        balance: ethers.utils.formatEther(await contract.balanceOf(address)),
        stakingAmount: ethers.utils.formatEther(userInfoResult[1]),
        pendingReward: ethers.utils.formatEther(userInfoResult[2]),
        lastActionTime: new Date(userInfoResult[3].toNumber() * 1000).toLocaleString(),
        isActive: userInfoResult[4],
        referralCount: userInfoResult[5].toString(),
        referrer: userInfoResult[6]
      };
      setUserInfo(userInfo);
      
      // 获取质押池信息
      const poolInfoResult = await contract.getStakingPoolInfo();
      const stakingPoolInfo: StakingPoolInfo = {
        totalStaked: ethers.utils.formatEther(poolInfoResult[0]),
        rewardPerSecond: ethers.utils.formatEther(poolInfoResult[1]),
        lastRewardTime: new Date(poolInfoResult[2].toNumber() * 1000).toLocaleString(),
        accRewardPerShare: poolInfoResult[3].toString(),
        isActive: poolInfoResult[4]
      };
      setStakingPoolInfo(stakingPoolInfo);
      
      // 获取提案列表
      await loadProposals(contract);
      
    } catch (error) {
      console.error('加载用户数据失败:', error);
      setError('加载数据失败');
    }
  }, []);
  
  // 加载提案列表
  const loadProposals = useCallback(async (contract: ethers.Contract) => {
    try {
      const proposalCount = await contract.proposalCount();
      const proposalList: Proposal[] = [];
      
      for (let i = 1; i <= proposalCount.toNumber(); i++) {
        const proposalResult = await contract.getProposal(i);
        const proposal: Proposal = {
          id: proposalResult[0].toString(),
          proposer: proposalResult[1],
          title: proposalResult[2],
          description: proposalResult[3],
          startTime: new Date(proposalResult[4].toNumber() * 1000).toLocaleString(),
          endTime: new Date(proposalResult[5].toNumber() * 1000).toLocaleString(),
          forVotes: ethers.utils.formatEther(proposalResult[6]),
          againstVotes: ethers.utils.formatEther(proposalResult[7]),
          executed: proposalResult[8]
        };
        proposalList.push(proposal);
      }
      
      setProposals(proposalList.reverse()); // 最新的在前面
    } catch (error) {
      console.error('加载提案失败:', error);
    }
  }, []);
  
  // 用户注册
  const registerUser = useCallback(async () => {
    if (!contract) return;
    
    try {
      setLoading(true);
      const referrer = referrerAddress || ethers.constants.AddressZero;
      const tx = await contract.registerUser(referrer);
      await tx.wait();
      
      setSuccess('用户注册成功！');
      setOpenRegisterDialog(false);
      setReferrerAddress('');
      
      // 重新加载用户数据
      await loadUserData(contract, account);
    } catch (error: any) {
      console.error('注册失败:', error);
      setError(error.reason || '注册失败，请重试');
    } finally {
      setLoading(false);
    }
  }, [contract, account, referrerAddress, loadUserData]);
  
  // 质押代币
  const stakeTokens = useCallback(async () => {
    if (!contract || !stakeAmount) return;
    
    try {
      setLoading(true);
      const amount = ethers.utils.parseEther(stakeAmount);
      const tx = await contract.stake(amount);
      await tx.wait();
      
      setSuccess(`成功质押 ${stakeAmount} 代币！`);
      setStakeAmount('');
      
      // 重新加载用户数据
      await loadUserData(contract, account);
    } catch (error: any) {
      console.error('质押失败:', error);
      setError(error.reason || '质押失败，请重试');
    } finally {
      setLoading(false);
    }
  }, [contract, account, stakeAmount, loadUserData]);
  
  // 取消质押
  const unstakeTokens = useCallback(async () => {
    if (!contract || !unstakeAmount) return;
    
    try {
      setLoading(true);
      const amount = ethers.utils.parseEther(unstakeAmount);
      const tx = await contract.unstake(amount);
      await tx.wait();
      
      setSuccess(`成功取消质押 ${unstakeAmount} 代币！`);
      setUnstakeAmount('');
      
      // 重新加载用户数据
      await loadUserData(contract, account);
    } catch (error: any) {
      console.error('取消质押失败:', error);
      setError(error.reason || '取消质押失败，请重试');
    } finally {
      setLoading(false);
    }
  }, [contract, account, unstakeAmount, loadUserData]);
  
  // 领取奖励
  const claimRewards = useCallback(async () => {
    if (!contract) return;
    
    try {
      setLoading(true);
      const tx = await contract.claimReward();
      await tx.wait();
      
      setSuccess('奖励领取成功！');
      
      // 重新加载用户数据
      await loadUserData(contract, account);
    } catch (error: any) {
      console.error('领取奖励失败:', error);
      setError(error.reason || '领取奖励失败，请重试');
    } finally {
      setLoading(false);
    }
  }, [contract, account, loadUserData]);
  
  // 创建提案
  const createProposal = useCallback(async () => {
    if (!contract || !proposalTitle || !proposalDescription) return;
    
    try {
      setLoading(true);
      const votingPeriodSeconds = parseInt(votingPeriod) * 24 * 60 * 60; // 转换为秒
      const tx = await contract.createProposal(proposalTitle, proposalDescription, votingPeriodSeconds);
      await tx.wait();
      
      setSuccess('提案创建成功！');
      setOpenProposalDialog(false);
      setProposalTitle('');
      setProposalDescription('');
      setVotingPeriod('7');
      
      // 重新加载提案数据
      await loadProposals(contract);
    } catch (error: any) {
      console.error('创建提案失败:', error);
      setError(error.reason || '创建提案失败，请重试');
    } finally {
      setLoading(false);
    }
  }, [contract, proposalTitle, proposalDescription, votingPeriod, loadProposals]);
  
  // 投票
  const voteOnProposal = useCallback(async (proposalId: string, support: boolean) => {
    if (!contract) return;
    
    try {
      setLoading(true);
      const tx = await contract.vote(proposalId, support);
      await tx.wait();
      
      setSuccess(`投票成功！您${support ? '支持' : '反对'}该提案`);
      
      // 重新加载提案数据
      await loadProposals(contract);
    } catch (error: any) {
      console.error('投票失败:', error);
      setError(error.reason || '投票失败，请重试');
    } finally {
      setLoading(false);
    }
  }, [contract, loadProposals]);
  
  // 清除消息
  const clearMessages = useCallback(() => {
    setError('');
    setSuccess('');
  }, []);
  
  // 页面加载时检查缓存的提供者
  useEffect(() => {
    if (web3Modal.cachedProvider) {
      connectWallet();
    }
  }, [connectWallet]);
  
  // 监听账户变化
  useEffect(() => {
    if (provider) {
      const handleAccountsChanged = (accounts: string[]) => {
        if (accounts.length === 0) {
          disconnectWallet();
        } else {
          setAccount(accounts[0]);
          if (contract) {
            loadUserData(contract, accounts[0]);
          }
        }
      };
      
      const handleChainChanged = () => {
        window.location.reload();
      };
      
      provider.provider.on('accountsChanged', handleAccountsChanged);
      provider.provider.on('chainChanged', handleChainChanged);
      
      return () => {
        provider.provider.removeListener('accountsChanged', handleAccountsChanged);
        provider.provider.removeListener('chainChanged', handleChainChanged);
      };
    }
  }, [provider, contract, loadUserData, disconnectWallet]);
  
  // 渲染钱包连接按钮
  const renderWalletConnection = () => {
    if (!account) {
      return (
        <Box display="flex" justifyContent="center" mb={4}>
          <GradientButton
            onClick={connectWallet}
            disabled={loading}
            size="large"
          >
            {loading ? <CircularProgress size={24} color="inherit" /> : '连接钱包'}
          </GradientButton>
        </Box>
      );
    }
    
    return (
      <Box display="flex" justifyContent="space-between" alignItems="center" mb={4}>
        <Typography variant="h6">
          已连接: {account.slice(0, 6)}...{account.slice(-4)}
        </Typography>
        <Button onClick={disconnectWallet} variant="outlined">
          断开连接
        </Button>
      </Box>
    );
  };
  
  // 渲染用户信息卡片
  const renderUserInfoCard = () => {
    if (!userInfo) return null;
    
    return (
      <StyledCard>
        <CardContent>
          <Typography variant="h6" gutterBottom>
            用户信息
          </Typography>
          <Grid container spacing={2}>
            <Grid item xs={6}>
              <Typography variant="body2" color="textSecondary">
                代币余额
              </Typography>
              <Typography variant="h6">
                {parseFloat(userInfo.balance).toFixed(4)} 代币
              </Typography>
            </Grid>
            <Grid item xs={6}>
              <Typography variant="body2" color="textSecondary">
                质押数量
              </Typography>
              <Typography variant="h6">
                {parseFloat(userInfo.stakingAmount).toFixed(4)} 代币
              </Typography>
            </Grid>
            <Grid item xs={6}>
              <Typography variant="body2" color="textSecondary">
                待领取奖励
              </Typography>
              <Typography variant="h6" color="primary">
                {parseFloat(userInfo.pendingReward).toFixed(6)} 代币
              </Typography>
            </Grid>
            <Grid item xs={6}>
              <Typography variant="body2" color="textSecondary">
                推荐人数
              </Typography>
              <Typography variant="h6">
                {userInfo.referralCount} 人
              </Typography>
            </Grid>
          </Grid>
          
          {!userInfo.isActive && (
            <Box mt={2}>
              <Button
                variant="contained"
                color="primary"
                onClick={() => setOpenRegisterDialog(true)}
                fullWidth
              >
                注册用户
              </Button>
            </Box>
          )}
          
          {userInfo.isActive && parseFloat(userInfo.pendingReward) > 0 && (
            <Box mt={2}>
              <Button
                variant="contained"
                color="secondary"
                onClick={claimRewards}
                disabled={loading}
                fullWidth
              >
                {loading ? <CircularProgress size={20} /> : '领取奖励'}
              </Button>
            </Box>
          )}
        </CardContent>
      </StyledCard>
    );
  };
  
  // 渲染质押卡片
  const renderStakingCard = () => {
    if (!userInfo?.isActive) return null;
    
    return (
      <StyledCard>
        <CardContent>
          <Typography variant="h6" gutterBottom>
            质押管理
          </Typography>
          
          <Box mb={3}>
            <Typography variant="body2" color="textSecondary" gutterBottom>
              质押代币
            </Typography>
            <TextField
              fullWidth
              variant="outlined"
              placeholder="输入质押数量"
              value={stakeAmount}
              onChange={(e) => setStakeAmount(e.target.value)}
              type="number"
              InputProps={{
                endAdornment: (
                  <Button
                    onClick={stakeTokens}
                    disabled={loading || !stakeAmount}
                    variant="contained"
                    size="small"
                  >
                    质押
                  </Button>
                )
              }}
            />
          </Box>
          
          <Box>
            <Typography variant="body2" color="textSecondary" gutterBottom>
              取消质押
            </Typography>
            <TextField
              fullWidth
              variant="outlined"
              placeholder="输入取消质押数量"
              value={unstakeAmount}
              onChange={(e) => setUnstakeAmount(e.target.value)}
              type="number"
              InputProps={{
                endAdornment: (
                  <Button
                    onClick={unstakeTokens}
                    disabled={loading || !unstakeAmount}
                    variant="outlined"
                    size="small"
                  >
                    取消质押
                  </Button>
                )
              }}
            />
          </Box>
        </CardContent>
      </StyledCard>
    );
  };
  
  // 渲染质押池信息卡片
  const renderStakingPoolCard = () => {
    if (!stakingPoolInfo) return null;
    
    return (
      <StyledCard>
        <CardContent>
          <Typography variant="h6" gutterBottom>
            质押池信息
          </Typography>
          <Grid container spacing={2}>
            <Grid item xs={6}>
              <Typography variant="body2" color="textSecondary">
                总质押量
              </Typography>
              <Typography variant="h6">
                {parseFloat(stakingPoolInfo.totalStaked).toFixed(2)} 代币
              </Typography>
            </Grid>
            <Grid item xs={6}>
              <Typography variant="body2" color="textSecondary">
                每秒奖励
              </Typography>
              <Typography variant="h6">
                {parseFloat(stakingPoolInfo.rewardPerSecond).toFixed(6)} 代币
              </Typography>
            </Grid>
            <Grid item xs={12}>
              <Typography variant="body2" color="textSecondary">
                池子状态
              </Typography>
              <Chip
                label={stakingPoolInfo.isActive ? '活跃' : '非活跃'}
                color={stakingPoolInfo.isActive ? 'success' : 'error'}
                size="small"
              />
            </Grid>
          </Grid>
        </CardContent>
      </StyledCard>
    );
  };
  
  // 渲染提案列表
  const renderProposals = () => {
    return (
      <Box>
        <Box display="flex" justifyContent="space-between" alignItems="center" mb={3}>
          <Typography variant="h6">
            治理提案
          </Typography>
          {userInfo?.isActive && (
            <Button
              variant="contained"
              onClick={() => setOpenProposalDialog(true)}
            >
              创建提案
            </Button>
          )}
        </Box>
        
        <TableContainer component={Paper}>
          <Table>
            <TableHead>
              <TableRow>
                <TableCell>ID</TableCell>
                <TableCell>标题</TableCell>
                <TableCell>提案人</TableCell>
                <TableCell>赞成票</TableCell>
                <TableCell>反对票</TableCell>
                <TableCell>状态</TableCell>
                <TableCell>操作</TableCell>
              </TableRow>
            </TableHead>
            <TableBody>
              {proposals.map((proposal) => {
                const now = new Date().getTime();
                const endTime = new Date(proposal.endTime).getTime();
                const isVotingActive = now < endTime;
                
                return (
                  <TableRow key={proposal.id}>
                    <TableCell>{proposal.id}</TableCell>
                    <TableCell>
                      <Typography variant="body2" fontWeight="bold">
                        {proposal.title}
                      </Typography>
                      <Typography variant="caption" color="textSecondary">
                        {proposal.description.slice(0, 50)}...
                      </Typography>
                    </TableCell>
                    <TableCell>
                      {proposal.proposer.slice(0, 6)}...{proposal.proposer.slice(-4)}
                    </TableCell>
                    <TableCell>
                      <Typography color="success.main">
                        {parseFloat(proposal.forVotes).toFixed(2)}
                      </Typography>
                    </TableCell>
                    <TableCell>
                      <Typography color="error.main">
                        {parseFloat(proposal.againstVotes).toFixed(2)}
                      </Typography>
                    </TableCell>
                    <TableCell>
                      <Chip
                        label={
                          proposal.executed
                            ? '已执行'
                            : isVotingActive
                            ? '投票中'
                            : '投票结束'
                        }
                        color={
                          proposal.executed
                            ? 'success'
                            : isVotingActive
                            ? 'primary'
                            : 'default'
                        }
                        size="small"
                      />
                    </TableCell>
                    <TableCell>
                      {userInfo?.isActive && isVotingActive && !proposal.executed && (
                        <Box>
                          <Button
                            size="small"
                            variant="outlined"
                            color="success"
                            onClick={() => voteOnProposal(proposal.id, true)}
                            disabled={loading}
                            sx={{ mr: 1 }}
                          >
                            支持
                          </Button>
                          <Button
                            size="small"
                            variant="outlined"
                            color="error"
                            onClick={() => voteOnProposal(proposal.id, false)}
                            disabled={loading}
                          >
                            反对
                          </Button>
                        </Box>
                      )}
                    </TableCell>
                  </TableRow>
                );
              })}
            </TableBody>
          </Table>
        </TableContainer>
      </Box>
    );
  };
  
  return (
    <Container maxWidth="lg" sx={{ py: 4 }}>
      {/* 标题 */}
      <Typography variant="h3" component="h1" gutterBottom align="center">
        实用DApp平台
      </Typography>
      <Typography variant="h6" color="textSecondary" align="center" gutterBottom>
        质押、治理、奖励一体化去中心化应用
      </Typography>
      
      {/* 钱包连接 */}
      {renderWalletConnection()}
      
      {/* 消息提示 */}
      {error && (
        <Alert severity="error" onClose={clearMessages} sx={{ mb: 2 }}>
          {error}
        </Alert>
      )}
      {success && (
        <Alert severity="success" onClose={clearMessages} sx={{ mb: 2 }}>
          {success}
        </Alert>
      )}
      
      {/* 加载指示器 */}
      {loading && <LinearProgress sx={{ mb: 2 }} />}
      
      {/* 主要内容 */}
      {account && (
        <>
          {/* 标签页 */}
          <Box sx={{ borderBottom: 1, borderColor: 'divider', mb: 3 }}>
            <Tabs value={tabValue} onChange={(_, newValue) => setTabValue(newValue)}>
              <Tab label="仪表板" />
              <Tab label="治理" />
            </Tabs>
          </Box>
          
          {/* 仪表板内容 */}
          {tabValue === 0 && (
            <Grid container spacing={3}>
              <Grid item xs={12} md={4}>
                {renderUserInfoCard()}
              </Grid>
              <Grid item xs={12} md={4}>
                {renderStakingCard()}
              </Grid>
              <Grid item xs={12} md={4}>
                {renderStakingPoolCard()}
              </Grid>
            </Grid>
          )}
          
          {/* 治理内容 */}
          {tabValue === 1 && renderProposals()}
        </>
      )}
      
      {/* 用户注册对话框 */}
      <Dialog open={openRegisterDialog} onClose={() => setOpenRegisterDialog(false)}>
        <DialogTitle>用户注册</DialogTitle>
        <DialogContent>
          <TextField
            autoFocus
            margin="dense"
            label="推荐人地址（可选）"
            fullWidth
            variant="outlined"
            value={referrerAddress}
            onChange={(e) => setReferrerAddress(e.target.value)}
            placeholder="0x..."
          />
        </DialogContent>
        <DialogActions>
          <Button onClick={() => setOpenRegisterDialog(false)}>取消</Button>
          <Button onClick={registerUser} disabled={loading}>注册</Button>
        </DialogActions>
      </Dialog>
      
      {/* 创建提案对话框 */}
      <Dialog open={openProposalDialog} onClose={() => setOpenProposalDialog(false)} maxWidth="md" fullWidth>
        <DialogTitle>创建提案</DialogTitle>
        <DialogContent>
          <TextField
            autoFocus
            margin="dense"
            label="提案标题"
            fullWidth
            variant="outlined"
            value={proposalTitle}
            onChange={(e) => setProposalTitle(e.target.value)}
            sx={{ mb: 2 }}
          />
          <TextField
            margin="dense"
            label="提案描述"
            fullWidth
            multiline
            rows={4}
            variant="outlined"
            value={proposalDescription}
            onChange={(e) => setProposalDescription(e.target.value)}
            sx={{ mb: 2 }}
          />
          <TextField
            margin="dense"
            label="投票期间（天）"
            type="number"
            variant="outlined"
            value={votingPeriod}
            onChange={(e) => setVotingPeriod(e.target.value)}
            inputProps={{ min: 1, max: 30 }}
          />
        </DialogContent>
        <DialogActions>
          <Button onClick={() => setOpenProposalDialog(false)}>取消</Button>
          <Button onClick={createProposal} disabled={loading || !proposalTitle || !proposalDescription}>
            创建提案
          </Button>
        </DialogActions>
      </Dialog>
    </Container>
  );
};

export default DAppInterface;
```

**前端特色**: 现代化UI设计，完整的Web3交互功能

---

## 📚 第三周：智能合约部署与测试

### 课堂主题：从开发到生产的完整流程
**时间**: 2024年3月18日  
**重点内容**:

#### 1. 部署脚本配置
```javascript
// deploy.js - 部署脚本
const { ethers } = require('hardhat');
const fs = require('fs');
const path = require('path');

async function main() {
  console.log('开始部署 PracticalDApp 合约...');
  
  // 获取部署账户
  const [deployer] = await ethers.getSigners();
  console.log('部署账户:', deployer.address);
  console.log('账户余额:', ethers.utils.formatEther(await deployer.getBalance()));
  
  // 部署合约
  const PracticalDApp = await ethers.getContractFactory('PracticalDApp');
  const initialSupply = ethers.utils.parseEther('100000'); // 10万代币初始供应
  
  console.log('正在部署合约...');
  const dapp = await PracticalDApp.deploy(
    'PracticalToken',
    'PRAC',
    initialSupply
  );
  
  await dapp.deployed();
  console.log('合约部署成功!');
  console.log('合约地址:', dapp.address);
  console.log('交易哈希:', dapp.deployTransaction.hash);
  
  // 等待确认
  console.log('等待区块确认...');
  await dapp.deployTransaction.wait(5);
  
  // 验证合约
  if (network.name !== 'hardhat' && network.name !== 'localhost') {
    console.log('验证合约...');
    try {
      await hre.run('verify:verify', {
        address: dapp.address,
        constructorArguments: ['PracticalToken', 'PRAC', initialSupply],
      });
      console.log('合约验证成功!');
    } catch (error) {
      console.log('合约验证失败:', error.message);
    }
  }
  
  // 保存部署信息
  const deploymentInfo = {
    network: network.name,
    contractAddress: dapp.address,
    deployerAddress: deployer.address,
    transactionHash: dapp.deployTransaction.hash,
    blockNumber: dapp.deployTransaction.blockNumber,
    gasUsed: dapp.deployTransaction.gasLimit.toString(),
    timestamp: new Date().toISOString(),
    constructorArgs: {
      name: 'PracticalToken',
      symbol: 'PRAC',
      initialSupply: initialSupply.toString()
    }
  };
  
  const deploymentsDir = path.join(__dirname, '../deployments');
  if (!fs.existsSync(deploymentsDir)) {
    fs.mkdirSync(deploymentsDir, { recursive: true });
  }
  
  fs.writeFileSync(
    path.join(deploymentsDir, `${network.name}.json`),
    JSON.stringify(deploymentInfo, null, 2)
  );
  
  console.log('部署信息已保存到:', path.join(deploymentsDir, `${network.name}.json`));
  
  // 初始化设置
  console.log('执行初始化设置...');
  
  // 可以在这里添加初始化逻辑
  // 例如：设置初始参数、分配初始代币等
  
  console.log('部署完成!');
}

main()
  .then(() => process.exit(0))
  .catch((error) => {
    console.error('部署失败:', error);
    process.exit(1);
  });
```

#### 2. 测试套件
```javascript
// test/PracticalDApp.test.js - 完整测试套件
const { expect } = require('chai');
const { ethers } = require('hardhat');
const { time } = require('@nomicfoundation/hardhat-network-helpers');

describe('PracticalDApp', function () {
  let dapp;
  let owner, user1, user2, user3;
  let initialSupply;
  
  beforeEach(async function () {
    [owner, user1, user2, user3] = await ethers.getSigners();
    
    const PracticalDApp = await ethers.getContractFactory('PracticalDApp');
    initialSupply = ethers.utils.parseEther('100000');
    
    dapp = await PracticalDApp.deploy('PracticalToken', 'PRAC', initialSupply);
    await dapp.deployed();
  });
  
  describe('部署测试', function () {
    it('应该正确设置初始参数', async function () {
      expect(await dapp.name()).to.equal('PracticalToken');
      expect(await dapp.symbol()).to.equal('PRAC');
      expect(await dapp.totalSupply()).to.equal(initialSupply);
      expect(await dapp.balanceOf(owner.address)).to.equal(initialSupply);
    });
    
    it('应该正确初始化质押池', async function () {
      const poolInfo = await dapp.getStakingPoolInfo();
      expect(poolInfo.totalStaked).to.equal(0);
      expect(poolInfo.isActive).to.be.true;
    });
  });
  
  describe('用户注册测试', function () {
    it('应该允许用户注册', async function () {
      await dapp.connect(user1).registerUser(ethers.constants.AddressZero);
      
      const userInfo = await dapp.getUserInfo(user1.address);
      expect(userInfo.isActive).to.be.true;
    });
    
    it('应该正确处理推荐关系', async function () {
      await dapp.connect(user1).registerUser(ethers.constants.AddressZero);
      await dapp.connect(user2).registerUser(user1.address);
      
      const user1Info = await dapp.getUserInfo(user1.address);
      const user2Info = await dapp.getUserInfo(user2.address);
      
      expect(user1Info.referralCount).to.equal(1);
      expect(user2Info.referrer).to.equal(user1.address);
    });
    
    it('应该给推荐人奖励', async function () {
      await dapp.connect(user1).registerUser(ethers.constants.AddressZero);
      
      const balanceBefore = await dapp.balanceOf(user1.address);
      await dapp.connect(user2).registerUser(user1.address);
      const balanceAfter = await dapp.balanceOf(user1.address);
      
      expect(balanceAfter.sub(balanceBefore)).to.equal(ethers.utils.parseEther('10'));
    });
  });
  
  describe('质押功能测试', function () {
    beforeEach(async function () {
      // 给用户分配代币并注册
      await dapp.transfer(user1.address, ethers.utils.parseEther('1000'));
      await dapp.connect(user1).registerUser(ethers.constants.AddressZero);
    });
    
    it('应该允许用户质押代币', async function () {
      const stakeAmount = ethers.utils.parseEther('100');
      
      await dapp.connect(user1).stake(stakeAmount);
      
      const userInfo = await dapp.getUserInfo(user1.address);
      expect(userInfo.stakingAmount).to.equal(stakeAmount);
      
      const poolInfo = await dapp.getStakingPoolInfo();
      expect(poolInfo.totalStaked).to.equal(stakeAmount);
    });
    
    it('应该正确计算奖励', async function () {
      const stakeAmount = ethers.utils.parseEther('100');
      
      await dapp.connect(user1).stake(stakeAmount);
      
      // 等待一段时间
      await time.increase(3600); // 1小时
      
      const pendingReward = await dapp.getPendingReward(user1.address);
      expect(pendingReward).to.be.gt(0);
    });
    
    it('应该允许用户取消质押', async function () {
      const stakeAmount = ethers.utils.parseEther('100');
      
      await dapp.connect(user1).stake(stakeAmount);
      await time.increase(3600);
      
      const balanceBefore = await dapp.balanceOf(user1.address);
      await dapp.connect(user1).unstake(stakeAmount);
      const balanceAfter = await dapp.balanceOf(user1.address);
      
      // 应该收到本金和奖励
      expect(balanceAfter.sub(balanceBefore)).to.be.gt(stakeAmount);
    });
  });
  
  describe('治理功能测试', function () {
    beforeEach(async function () {
      // 给用户分配足够的代币用于治理
      await dapp.transfer(user1.address, ethers.utils.parseEther('1000'));
      await dapp.connect(user1).registerUser(ethers.constants.AddressZero);
    });
    
    it('应该允许创建提案', async function () {
      const title = '测试提案';
      const description = '这是一个测试提案';
      const votingPeriod = 7 * 24 * 60 * 60; // 7天
      
      await expect(
        dapp.connect(user1).createProposal(title, description, votingPeriod)
      ).to.emit(dapp, 'ProposalCreated');
      
      const proposalCount = await dapp.proposalCount();
      expect(proposalCount).to.equal(1);
    });
    
    it('应该允许用户投票', async function () {
      const title = '测试提案';
      const description = '这是一个测试提案';
      const votingPeriod = 7 * 24 * 60 * 60;
      
      await dapp.connect(user1).createProposal(title, description, votingPeriod);
      
      await expect(
        dapp.connect(user1).vote(1, true)
      ).to.emit(dapp, 'Voted');
      
      const proposal = await dapp.getProposal(1);
      expect(proposal.forVotes).to.be.gt(0);
    });
    
    it('应该防止重复投票', async function () {
      const title = '测试提案';
      const description = '这是一个测试提案';
      const votingPeriod = 7 * 24 * 60 * 60;
      
      await dapp.connect(user1).createProposal(title, description, votingPeriod);
      await dapp.connect(user1).vote(1, true);
      
      await expect(
        dapp.connect(user1).vote(1, false)
      ).to.be.revertedWith('Already voted');
    });
  });
  
  describe('安全性测试', function () {
    it('应该防止重入攻击', async function () {
      // 这里可以添加重入攻击测试
      // 由于使用了ReentrancyGuard，应该能防止重入
    });
    
    it('应该正确处理暂停状态', async function () {
      await dapp.transfer(user1.address, ethers.utils.parseEther('1000'));
      await dapp.connect(user1).registerUser(ethers.constants.AddressZero);
      
      await dapp.pause();
      
      await expect(
        dapp.connect(user1).stake(ethers.utils.parseEther('100'))
      ).to.be.revertedWith('Pausable: paused');
    });
  });
  
  describe('边界条件测试', function () {
    it('应该处理零金额质押', async function () {
      await dapp.transfer(user1.address, ethers.utils.parseEther('1000'));
      await dapp.connect(user1).registerUser(ethers.constants.AddressZero);
      
      await expect(
        dapp.connect(user1).stake(0)
      ).to.be.revertedWith('Amount must be greater than 0');
    });
    
    it('应该处理余额不足的情况', async function () {
      await dapp.connect(user1).registerUser(ethers.constants.AddressZero);
      
      await expect(
        dapp.connect(user1).stake(ethers.utils.parseEther('1000'))
      ).to.be.revertedWith('Insufficient balance');
    });
  });
});
```

**测试覆盖**: 功能测试、安全测试、边界条件测试全覆盖

---

## 📚 第四周：性能优化与监控

### 课堂主题：生产级DApp性能优化
**时间**: 2024年3月25日  
**重点内容**:

#### 1. Gas优化策略
```solidity
// GasOptimizer.sol - Gas优化工具
pragma solidity ^0.8.19;

/**
 * @title GasOptimizer
 * @author 罗佳康
 * @notice Gas优化实用工具和技巧集合
 */
library GasOptimizer {
    
    /// @notice 批量转账优化
    /// @param token ERC20代币合约
    /// @param recipients 接收者数组
    /// @param amounts 金额数组
    function batchTransfer(
        IERC20 token,
        address[] calldata recipients,
        uint256[] calldata amounts
    ) external {
        require(recipients.length == amounts.length, "Array length mismatch");
        
        uint256 length = recipients.length;
        for (uint256 i = 0; i < length;) {
            token.transferFrom(msg.sender, recipients[i], amounts[i]);
            unchecked {
                ++i;
            }
        }
    }
    
    /// @notice 优化的存储打包
    struct PackedData {
        uint128 amount;      // 16字节
        uint64 timestamp;    // 8字节
        uint32 count;        // 4字节
        uint16 status;       // 2字节
        uint8 flag;          // 1字节
        bool isActive;       // 1字节
        // 总计32字节，正好一个存储槽
    }
    
    /// @notice 位运算优化示例
    function setBitFlag(uint256 flags, uint8 position, bool value) 
        internal 
        pure 
        returns (uint256) 
    {
        if (value) {
            return flags | (1 << position);
        } else {
            return flags & ~(1 << position);
        }
    }
    
    /// @notice 检查位标志
    function getBitFlag(uint256 flags, uint8 position) 
        internal 
        pure 
        returns (bool) 
    {
        return (flags >> position) & 1 == 1;
    }
    
    /// @notice 优化的数组操作
    function removeFromArray(uint256[] storage array, uint256 index) internal {
        require(index < array.length, "Index out of bounds");
        
        // 将最后一个元素移到要删除的位置
        array[index] = array[array.length - 1];
        array.pop();
    }
    
    /// @notice 高效的字符串比较
    function compareStrings(string memory a, string memory b) 
        internal 
        pure 
        returns (bool) 
    {
        return keccak256(abi.encodePacked(a)) == keccak256(abi.encodePacked(b));
    }
}
```

#### 2. 性能监控系统
```javascript
// monitor.js - 性能监控脚本
const { ethers } = require('ethers');
const fs = require('fs');
const path = require('path');

class DAppMonitor {
  constructor(contractAddress, providerUrl) {
    this.provider = new ethers.providers.JsonRpcProvider(providerUrl);
    this.contractAddress = contractAddress;
    this.contract = new ethers.Contract(
      contractAddress,
      require('../artifacts/contracts/PracticalDApp.sol/PracticalDApp.json').abi,
      this.provider
    );
    
    this.metrics = {
      gasUsage: [],
      transactionCounts: [],
      userActivity: [],
      stakingMetrics: [],
      governanceMetrics: []
    };
  }
  
  // 监控Gas使用情况
  async monitorGasUsage() {
    console.log('开始监控Gas使用情况...');
    
    const filter = {
      address: this.contractAddress,
      fromBlock: 'latest'
    };
    
    this.provider.on(filter, async (log) => {
      try {
        const tx = await this.provider.getTransaction(log.transactionHash);
        const receipt = await this.provider.getTransactionReceipt(log.transactionHash);
        
        const gasMetric = {
          timestamp: new Date().toISOString(),
          transactionHash: log.transactionHash,
          gasLimit: tx.gasLimit.toString(),
          gasUsed: receipt.gasUsed.toString(),
          gasPrice: tx.gasPrice.toString(),
          gasCost: receipt.gasUsed.mul(tx.gasPrice).toString(),
          functionName: this.decodeFunctionName(tx.data)
        };
        
        this.metrics.gasUsage.push(gasMetric);
        
        // 如果Gas使用过高，发出警告
        if (receipt.gasUsed.gt(ethers.utils.parseUnits('500000', 'wei'))) {
          console.warn(`⚠️  高Gas使用警告: ${receipt.gasUsed.toString()} gas`);
        }
        
      } catch (error) {
        console.error('监控Gas使用时出错:', error);
      }
    });
  }
  
  // 监控用户活动
  async monitorUserActivity() {
    console.log('开始监控用户活动...');
    
    // 监听用户注册事件
    this.contract.on('UserRegistered', (user, referrer, timestamp, event) => {
      const activity = {
        type: 'UserRegistered',
        user: user,
        referrer: referrer,
        timestamp: new Date(timestamp.toNumber() * 1000).toISOString(),
        blockNumber: event.blockNumber,
        transactionHash: event.transactionHash
      };
      
      this.metrics.userActivity.push(activity);
      console.log(`📝 新用户注册: ${user}`);
    });
    
    // 监听质押事件
    this.contract.on('Staked', (user, amount, timestamp, event) => {
      const activity = {
        type: 'Staked',
        user: user,
        amount: ethers.utils.formatEther(amount),
        timestamp: new Date(timestamp.toNumber() * 1000).toISOString(),
        blockNumber: event.blockNumber,
        transactionHash: event.transactionHash
      };
      
      this.metrics.stakingMetrics.push(activity);
      console.log(`💰 用户质押: ${user} - ${ethers.utils.formatEther(amount)} 代币`);
    });
    
    // 监听提案创建事件
    this.contract.on('ProposalCreated', (proposalId, proposer, title, startTime, endTime, event) => {
      const activity = {
        type: 'ProposalCreated',
        proposalId: proposalId.toString(),
        proposer: proposer,
        title: title,
        startTime: new Date(startTime.toNumber() * 1000).toISOString(),
        endTime: new Date(endTime.toNumber() * 1000).toISOString(),
        blockNumber: event.blockNumber,
        transactionHash: event.transactionHash
      };
      
      this.metrics.governanceMetrics.push(activity);
      console.log(`🗳️  新提案创建: ${title}`);
    });
  }
  
  // 生成性能报告
  async generatePerformanceReport() {
    console.log('生成性能报告...');
    
    const report = {
      timestamp: new Date().toISOString(),
      contractAddress: this.contractAddress,
      summary: {
        totalTransactions: this.metrics.gasUsage.length,
        totalUsers: await this.getTotalUsers(),
        totalStaked: await this.getTotalStaked(),
        totalProposals: await this.getTotalProposals(),
        averageGasUsage: this.calculateAverageGasUsage(),
        peakGasUsage: this.getPeakGasUsage()
      },
      gasAnalysis: this.analyzeGasUsage(),
      userGrowth: this.analyzeUserGrowth(),
      stakingTrends: this.analyzeStakingTrends(),
      governanceActivity: this.analyzeGovernanceActivity()
    };
    
    // 保存报告
    const reportsDir = path.join(__dirname, '../reports');
    if (!fs.existsSync(reportsDir)) {
      fs.mkdirSync(reportsDir, { recursive: true });
    }
    
    const reportFile = path.join(reportsDir, `performance-${Date.now()}.json`);
    fs.writeFileSync(reportFile, JSON.stringify(report, null, 2));
    
    console.log(`📊 性能报告已保存: ${reportFile}`);
    return report;
  }
  
  // 辅助方法
  decodeFunctionName(data) {
    try {
      const iface = new ethers.utils.Interface(this.contract.interface.fragments);
      const decoded = iface.parseTransaction({ data });
      return decoded.name;
    } catch (error) {
      return 'Unknown';
    }
  }
  
  async getTotalUsers() {
    try {
      return await this.contract.getActiveUserCount();
    } catch (error) {
      return 0;
    }
  }
  
  async getTotalStaked() {
    try {
      const poolInfo = await this.contract.getStakingPoolInfo();
      return ethers.utils.formatEther(poolInfo.totalStaked);
    } catch (error) {
      return '0';
    }
  }
  
  async getTotalProposals() {
    try {
      return await this.contract.proposalCount();
    } catch (error) {
      return 0;
    }
  }
  
  calculateAverageGasUsage() {
    if (this.metrics.gasUsage.length === 0) return 0;
    
    const total = this.metrics.gasUsage.reduce((sum, metric) => {
      return sum + parseInt(metric.gasUsed);
    }, 0);
    
    return Math.round(total / this.metrics.gasUsage.length);
  }
  
  getPeakGasUsage() {
    if (this.metrics.gasUsage.length === 0) return 0;
    
    return Math.max(...this.metrics.gasUsage.map(metric => parseInt(metric.gasUsed)));
  }
  
  analyzeGasUsage() {
    const functionGasUsage = {};
    
    this.metrics.gasUsage.forEach(metric => {
      const func = metric.functionName;
      if (!functionGasUsage[func]) {
        functionGasUsage[func] = {
          count: 0,
          totalGas: 0,
          averageGas: 0,
          maxGas: 0
        };
      }
      
      const gasUsed = parseInt(metric.gasUsed);
      functionGasUsage[func].count++;
      functionGasUsage[func].totalGas += gasUsed;
      functionGasUsage[func].maxGas = Math.max(functionGasUsage[func].maxGas, gasUsed);
    });
    
    // 计算平均值
    Object.keys(functionGasUsage).forEach(func => {
      functionGasUsage[func].averageGas = Math.round(
        functionGasUsage[func].totalGas / functionGasUsage[func].count
      );
    });
    
    return functionGasUsage;
  }
  
  analyzeUserGrowth() {
    const dailyGrowth = {};
    
    this.metrics.userActivity
      .filter(activity => activity.type === 'UserRegistered')
      .forEach(activity => {
        const date = activity.timestamp.split('T')[0];
        dailyGrowth[date] = (dailyGrowth[date] || 0) + 1;
      });
    
    return dailyGrowth;
  }
  
  analyzeStakingTrends() {
    const dailyStaking = {};
    
    this.metrics.stakingMetrics.forEach(metric => {
      const date = metric.timestamp.split('T')[0];
      if (!dailyStaking[date]) {
        dailyStaking[date] = {
          totalAmount: 0,
          transactionCount: 0
        };
      }
      
      dailyStaking[date].totalAmount += parseFloat(metric.amount);
      dailyStaking[date].transactionCount++;
    });
    
    return dailyStaking;
  }
  
  analyzeGovernanceActivity() {
    const proposalActivity = {
      totalProposals: this.metrics.governanceMetrics.length,
      proposalsByMonth: {},
      averageVotingPeriod: 0
    };
    
    this.metrics.governanceMetrics.forEach(proposal => {
      const month = proposal.startTime.substring(0, 7); // YYYY-MM
      proposalActivity.proposalsByMonth[month] = 
        (proposalActivity.proposalsByMonth[month] || 0) + 1;
    });
    
    return proposalActivity;
  }
  
  // 启动监控
  start() {
    console.log('🚀 启动DApp性能监控系统...');
    
    this.monitorGasUsage();
    this.monitorUserActivity();
    
    // 每小时生成一次报告
    setInterval(() => {
      this.generatePerformanceReport();
    }, 60 * 60 * 1000);
    
    console.log('✅ 监控系统已启动');
  }
}

// 使用示例
if (require.main === module) {
  const contractAddress = process.env.CONTRACT_ADDRESS || '0x1234567890123456789012345678901234567890';
  const providerUrl = process.env.PROVIDER_URL || 'http://localhost:8545';
  
  const monitor = new DAppMonitor(contractAddress, providerUrl);
  monitor.start();
}

module.exports = DAppMonitor;
```

**监控特色**: 全方位性能监控，实时Gas分析和用户行为追踪

---

## 📚 第五周：安全审计与最佳实践

### 课堂主题：生产级安全保障
**时间**: 2024年4月1日  
**重点内容**:

#### 1. 安全检查清单
```markdown
# DApp安全审计清单

## 智能合约安全
- [ ] 重入攻击防护 (ReentrancyGuard)
- [ ] 整数溢出防护 (SafeMath/Solidity 0.8+)
- [ ] 访问控制检查 (Ownable, Role-based)
- [ ] 输入验证 (require statements)
- [ ] 状态变量可见性 (private/internal)
- [ ] 函数可见性控制 (external/public/internal/private)
- [ ] 事件日志记录 (重要操作都有事件)
- [ ] 紧急暂停机制 (Pausable)
- [ ] 升级机制安全性 (如果使用代理模式)
- [ ] 时间依赖性问题 (block.timestamp)
- [ ] 随机数安全性 (避免使用block.hash等)
- [ ] 外部调用安全 (checks-effects-interactions)

## 前端安全
- [ ] 钱包连接安全 (验证签名)
- [ ] 交易确认机制 (用户确认)
- [ ] 输入验证和清理 (防止XSS)
- [ ] HTTPS强制使用
- [ ] 敏感信息保护 (不在前端存储私钥)
- [ ] 错误处理 (不暴露敏感信息)
- [ ] 会话管理 (适当的超时)
- [ ] 内容安全策略 (CSP)

## 部署安全
- [ ] 私钥管理 (硬件钱包/多签)
- [ ] 网络配置 (正确的RPC端点)
- [ ] 合约验证 (Etherscan等)
- [ ] 初始参数检查
- [ ] 权限移交 (如需要)
- [ ] 备份和恢复计划
```

#### 2. 自动化安全测试
```javascript
// security-tests.js - 安全测试套件
const { expect } = require('chai');
const { ethers } = require('hardhat');
const { time } = require('@nomicfoundation/hardhat-network-helpers');

describe('安全测试套件', function () {
  let dapp, owner, attacker, user1;
  
  beforeEach(async function () {
    [owner, attacker, user1] = await ethers.getSigners();
    
    const PracticalDApp = await ethers.getContractFactory('PracticalDApp');
    dapp = await PracticalDApp.deploy(
      'PracticalToken',
      'PRAC',
      ethers.utils.parseEther('100000')
    );
    await dapp.deployed();
  });
  
  describe('重入攻击测试', function () {
    it('应该防止重入攻击', async function () {
      // 部署恶意合约
      const MaliciousContract = await ethers.getContractFactory('MaliciousReentrancy');
      const malicious = await MaliciousContract.deploy(dapp.address);
      
      // 给恶意合约一些代币
      await dapp.transfer(malicious.address, ethers.utils.parseEther('1000'));
      
      // 尝试重入攻击
      await expect(
        malicious.attack()
      ).to.be.revertedWith('ReentrancyGuard: reentrant call');
    });
  });
  
  describe('访问控制测试', function () {
    it('应该阻止非授权的管理员操作', async function () {
      await expect(
        dapp.connect(attacker).pause()
      ).to.be.revertedWith('Ownable: caller is not the owner');
    });
    
    it('应该阻止非授权的紧急提取', async function () {
      await expect(
        dapp.connect(attacker).emergencyWithdraw(ethers.constants.AddressZero, 1000)
      ).to.be.revertedWith('Ownable: caller is not the owner');
    });
  });
  
  describe('输入验证测试', function () {
    it('应该拒绝无效的质押金额', async function () {
      await dapp.transfer(user1.address, ethers.utils.parseEther('1000'));
      await dapp.connect(user1).registerUser(ethers.constants.AddressZero);
      
      await expect(
        dapp.connect(user1).stake(0)
      ).to.be.revertedWith('Amount must be greater than 0');
    });
    
    it('应该拒绝空的提案标题', async function () {
      await dapp.transfer(user1.address, ethers.utils.parseEther('1000'));
      await dapp.connect(user1).registerUser(ethers.constants.AddressZero);
      
      await expect(
        dapp.connect(user1).createProposal('', '描述', 7 * 24 * 60 * 60)
      ).to.be.revertedWith('Title cannot be empty');
    });
  });
  
  describe('整数溢出测试', function () {
    it('应该处理大数值操作', async function () {
      const maxUint256 = ethers.constants.MaxUint256;
      
      // 测试是否正确处理大数值
      // Solidity 0.8+ 自动检查溢出
      await expect(
        dapp.transfer(user1.address, maxUint256)
      ).to.be.revertedWith('ERC20: transfer amount exceeds balance');
    });
  });
  
  describe('时间操作测试', function () {
    it('应该正确处理时间相关的逻辑', async function () {
      await dapp.transfer(user1.address, ethers.utils.parseEther('1000'));
      await dapp.connect(user1).registerUser(ethers.constants.AddressZero);
      
      // 创建提案
      const votingPeriod = 7 * 24 * 60 * 60;
      await dapp.connect(user1).createProposal('测试', '描述', votingPeriod);
      
      // 时间快进到投票期结束后
      await time.increase(votingPeriod + 1);
      
      // 应该无法投票
      await expect(
        dapp.connect(user1).vote(1, true)
      ).to.be.revertedWith('Voting period not active');
    });
  });
  
  describe('状态一致性测试', function () {
    it('应该保持状态一致性', async function () {
      await dapp.transfer(user1.address, ethers.utils.parseEther('1000'));
      await dapp.connect(user1).registerUser(ethers.constants.AddressZero);
      
      const stakeAmount = ethers.utils.parseEther('100');
      
      // 记录质押前的状态
      const balanceBefore = await dapp.balanceOf(user1.address);
      const poolInfoBefore = await dapp.getStakingPoolInfo();
      
      // 执行质押
      await dapp.connect(user1).stake(stakeAmount);
      
      // 检查状态一致性
      const balanceAfter = await dapp.balanceOf(user1.address);
      const poolInfoAfter = await dapp.getStakingPoolInfo();
      const userInfo = await dapp.getUserInfo(user1.address);
      
      expect(balanceBefore.sub(balanceAfter)).to.equal(stakeAmount);
      expect(poolInfoAfter.totalStaked.sub(poolInfoBefore.totalStaked)).to.equal(stakeAmount);
      expect(userInfo.stakingAmount).to.equal(stakeAmount);
    });
  });
});

// 恶意重入攻击合约示例
contract MaliciousReentrancy {
    PracticalDApp public target;
    bool public attacking = false;
    
    constructor(address _target) {
        target = PracticalDApp(_target);
    }
    
    function attack() external {
        attacking = true;
        target.registerUser(address(0));
        target.stake(100 ether);
        target.unstake(100 ether);
    }
    
    // 尝试在接收代币时重入
    receive() external payable {
        if (attacking && address(target).balance > 0) {
            target.unstake(100 ether);
        }
    }
}
```

**安全特色**: 全面的安全测试覆盖，自动化漏洞检测

---

## 📚 第六周：项目总结与部署上线

### 课堂主题：从开发到生产的完整交付
**时间**: 2024年4月8日  
**重点内容**:

#### 1. 生产部署配置
```javascript
// production-deploy.js - 生产环境部署脚本
const { ethers } = require('hardhat');
const fs = require('fs');
const path = require('path');

async function deployToProduction() {
  console.log('🚀 开始生产环境部署...');
  
  // 环境检查
  if (network.name === 'hardhat' || network.name === 'localhost') {
    throw new Error('不能在本地网络部署到生产环境');
  }
  
  // 获取部署账户
  const [deployer] = await ethers.getSigners();
  console.log('部署账户:', deployer.address);
  
  const balance = await deployer.getBalance();
  console.log('账户余额:', ethers.utils.formatEther(balance), 'ETH');
  
  // 检查余额是否足够
  const minBalance = ethers.utils.parseEther('0.1');
  if (balance.lt(minBalance)) {
    throw new Error('账户余额不足，至少需要 0.1 ETH');
  }
  
  // 部署参数
  const deployParams = {
    name: 'PracticalToken',
    symbol: 'PRAC',
    initialSupply: ethers.utils.parseEther('1000000') // 100万代币
  };
  
  console.log('部署参数:', deployParams);
  
  // 估算Gas费用
  const PracticalDApp = await ethers.getContractFactory('PracticalDApp');
  const deployTx = PracticalDApp.getDeployTransaction(
    deployParams.name,
    deployParams.symbol,
    deployParams.initialSupply
  );
  
  const gasEstimate = await deployer.estimateGas(deployTx);
  const gasPrice = await deployer.getGasPrice();
  const deploymentCost = gasEstimate.mul(gasPrice);
  
  console.log('预估Gas用量:', gasEstimate.toString());
  console.log('当前Gas价格:', ethers.utils.formatUnits(gasPrice, 'gwei'), 'Gwei');
  console.log('预估部署成本:', ethers.utils.formatEther(deploymentCost), 'ETH');
  
  // 用户确认
  const readline = require('readline').createInterface({
    input: process.stdin,
    output: process.stdout
  });
  
  const answer = await new Promise(resolve => {
    readline.question('确认部署到生产环境? (yes/no): ', resolve);
  });
  
  readline.close();
  
  if (answer.toLowerCase() !== 'yes') {
    console.log('部署已取消');
    return;
  }
  
  // 执行部署
  console.log('正在部署合约...');
  const dapp = await PracticalDApp.deploy(
    deployParams.name,
    deployParams.symbol,
    deployParams.initialSupply,
    {
      gasLimit: gasEstimate.mul(120).div(100), // 增加20%的Gas限制
      gasPrice: gasPrice
    }
  );
  
  console.log('等待部署确认...');
  await dapp.deployed();
  
  console.log('✅ 合约部署成功!');
  console.log('合约地址:', dapp.address);
  console.log('部署交易:', dapp.deployTransaction.hash);
  
  // 等待更多确认
  console.log('等待区块确认...');
  const receipt = await dapp.deployTransaction.wait(5);
  console.log('实际Gas使用:', receipt.gasUsed.toString());
  console.log('实际部署成本:', ethers.utils.formatEther(receipt.gasUsed.mul(gasPrice)), 'ETH');
  
  // 验证合约
  if (process.env.ETHERSCAN_API_KEY) {
    console.log('正在验证合约...');
    try {
      await hre.run('verify:verify', {
        address: dapp.address,
        constructorArguments: [
          deployParams.name,
          deployParams.symbol,
          deployParams.initialSupply
        ],
      });
      console.log('✅ 合约验证成功!');
    } catch (error) {
      console.warn('⚠️  合约验证失败:', error.message);
    }
  }
  
  // 保存部署信息
  const deploymentInfo = {
    network: network.name,
    contractAddress: dapp.address,
    deployerAddress: deployer.address,
    transactionHash: dapp.deployTransaction.hash,
    blockNumber: receipt.blockNumber,
    gasUsed: receipt.gasUsed.toString(),
    gasCost: receipt.gasUsed.mul(gasPrice).toString(),
    timestamp: new Date().toISOString(),
    constructorArgs: deployParams,
    verified: !!process.env.ETHERSCAN_API_KEY
  };
  
  const deploymentsDir = path.join(__dirname, '../deployments');
  if (!fs.existsSync(deploymentsDir)) {
    fs.mkdirSync(deploymentsDir, { recursive: true });
  }
  
  fs.writeFileSync(
    path.join(deploymentsDir, `${network.name}-production.json`),
    JSON.stringify(deploymentInfo, null, 2)
  );
  
  // 生成前端配置
  const frontendConfig = {
    contractAddress: dapp.address,
    network: network.name,
    abi: PracticalDApp.interface.format('json')
  };
  
  fs.writeFileSync(
    path.join(__dirname, '../frontend/src/config/contract.json'),
    JSON.stringify(frontendConfig, null, 2)
  );
  
  console.log('📄 部署信息已保存');
  console.log('🎉 生产环境部署完成!');
  
  // 部署后检查
  console.log('\n🔍 执行部署后检查...');
  await postDeploymentChecks(dapp);
}

async function postDeploymentChecks(contract) {
  try {
    // 检查基本信息
    const name = await contract.name();
    const symbol = await contract.symbol();
    const totalSupply = await contract.totalSupply();
    const owner = await contract.owner();
    
    console.log('合约名称:', name);
    console.log('代币符号:', symbol);
    console.log('总供应量:', ethers.utils.formatEther(totalSupply));
    console.log('合约所有者:', owner);
    
    // 检查质押池状态
    const poolInfo = await contract.getStakingPoolInfo();
    console.log('质押池状态:', poolInfo.isActive ? '活跃' : '非活跃');
    
    // 检查合约是否暂停
    const isPaused = await contract.paused();
    console.log('合约状态:', isPaused ? '已暂停' : '正常运行');
    
    console.log('✅ 部署后检查通过');
    
  } catch (error) {
    console.error('❌ 部署后检查失败:', error.message);
    throw error;
  }
}

if (require.main === module) {
  deployToProduction()
    .then(() => process.exit(0))
    .catch((error) => {
      console.error('部署失败:', error);
      process.exit(1);
    });
}

module.exports = { deployToProduction, postDeploymentChecks };
```

#### 2. 项目文档
```markdown
# PracticalDApp - 实用去中心化应用

## 项目概述

PracticalDApp 是一个集成了代币管理、质押挖矿、治理投票等功能的综合性去中心化应用。项目注重实际应用价值和用户体验，提供了完整的前后端解决方案。

## 核心功能

### 1. 用户管理系统
- 用户注册与推荐机制
- 用户信息管理
- 推荐奖励系统

### 2. 质押挖矿系统
- 代币质押功能
- 自动奖励分发
- 灵活的取消质押

### 3. 治理投票系统
- 提案创建与管理
- 基于代币权重的投票
- 提案执行机制

### 4. 安全保障
- 重入攻击防护
- 访问控制管理
- 紧急暂停机制

## 技术架构

### 智能合约层
- **语言**: Solidity 0.8.19
- **框架**: Hardhat
- **标准**: ERC20, OpenZeppelin
- **安全**: ReentrancyGuard, Pausable, Ownable

### 前端层
- **框架**: React + TypeScript
- **Web3**: ethers.js
- **UI**: Material-UI
- **钱包**: Web3Modal

### 部署与监控
- **部署**: Hardhat Deploy
- **监控**: 自定义监控系统
- **测试**: Comprehensive test suite

## 快速开始

### 环境要求
- Node.js >= 16.0.0
- npm >= 8.0.0
- Git

### 安装依赖
```bash
npm install
```

### 编译合约
```bash
npx hardhat compile
```

### 运行测试
```bash
npx hardhat test
```

### 本地部署
```bash
npx hardhat node
npx hardhat run scripts/deploy.js --network localhost
```

### 启动前端
```bash
cd frontend
npm install
npm start
```

## 部署指南

### 测试网部署
```bash
npx hardhat run scripts/deploy.js --network goerli
```

### 主网部署
```bash
npx hardhat run scripts/production-deploy.js --network mainnet
```

## 安全考虑

1. **智能合约安全**
   - 使用 OpenZeppelin 安全库
   - 实施重入攻击防护
   - 完善的访问控制

2. **前端安全**
   - 输入验证和清理
   - 安全的钱包连接
   - HTTPS 强制使用

3. **部署安全**
   - 多重签名钱包
   - 合约验证
   - 渐进式部署

## 监控与维护

- 实时性能监控
- Gas 使用分析
- 用户行为追踪
- 自动化报告生成

## 贡献指南

1. Fork 项目
2. 创建功能分支
3. 提交更改
4. 推送到分支
5. 创建 Pull Request

## 许可证

MIT License

## 联系方式

- 开发者: 罗佳康
- 邮箱: luojiakang@example.com
- GitHub: @luojiakang
```

---

## 🎯 学习心得与总结

### 核心技能掌握
1. **全栈DApp开发**: 从智能合约到前端界面的完整开发流程
2. **实用功能集成**: 质押、治理、奖励等核心DeFi功能实现
3. **生产级部署**: 完整的测试、部署、监控流程
4. **安全最佳实践**: 全面的安全防护和测试覆盖

### 技术创新点
1. **模块化架构**: 清晰的功能模块划分，便于维护和扩展
2. **用户体验优化**: 现代化的前端界面和流畅的交互体验
3. **性能监控**: 实时的Gas分析和用户行为追踪
4. **自动化流程**: 完整的CI/CD和自动化测试流程

### 实践项目成果
1. **PracticalDApp合约**: 功能完整的去中心化应用合约
2. **现代化前端**: React + TypeScript的Web3前端应用
3. **监控系统**: 全方位的性能监控和分析工具
4. **部署方案**: 生产级的部署和维护方案

### 未来发展方向
1. **跨链集成**: 支持多链部署和跨链交互
2. **Layer 2优化**: 集成Layer 2解决方案降低Gas费用
3. **移动端支持**: 开发移动端DApp应用
4. **AI集成**: 引入AI技术优化用户体验和风险管理

---

## 📚 参考资源

### 官方文档
- [Solidity Documentation](https://docs.soliditylang.org/)
- [OpenZeppelin Contracts](https://docs.openzeppelin.com/contracts/)
- [Hardhat Documentation](https://hardhat.org/docs/)
- [ethers.js Documentation](https://docs.ethers.io/)

### 学习资源
- [Ethereum Development Tutorial](https://ethereum.org/en/developers/tutorials/)
- [DeFi Developer Roadmap](https://github.com/OffcierCia/DeFi-Developer-Road-Map)
- [Smart Contract Security Best Practices](https://consensys.github.io/smart-contract-best-practices/)
- [Web3 Frontend Development](https://web3.career/learn-web3)

### 工具和库
- [Remix IDE](https://remix.ethereum.org/)
- [MetaMask](https://metamask.io/)
- [Etherscan](https://etherscan.io/)
- [OpenZeppelin Wizard](https://wizard.openzeppelin.com/)

### 社区资源
- [Ethereum Stack Exchange](https://ethereum.stackexchange.com/)
- [r/ethdev](https://www.reddit.com/r/ethdev/)
- [Ethereum Developers Discord](https://discord.gg/ethereum-org)
- [DeFi Pulse](https://defipulse.com/)

---

*记录时间: 2024年春季学期*  
*最后更新: 2024年4月8日*