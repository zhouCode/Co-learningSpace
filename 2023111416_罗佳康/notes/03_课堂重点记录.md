# è¯¾å ‚é‡ç‚¹è®°å½•

> **å­¦ä¹ è€…**: ç½—ä½³åº·  
> **å­¦å·**: 2023110555  
> **å­¦ä¹ ç‰¹è‰²**: æ³¨é‡å®é™…åº”ç”¨å’Œé¡¹ç›®å®è·µ  
> **ä»£ç é£æ ¼**: å®ç”¨ä¸»ä¹‰ã€é¡¹ç›®å¯¼å‘  
> **ç¬”è®°é‡ç‚¹**: å®é™…é¡¹ç›®å¼€å‘å’Œéƒ¨ç½²  
> **é¡¹ç›®ä»£ç **: PracticalDApp.sol - å®ç”¨å»ä¸­å¿ƒåŒ–åº”ç”¨  
> **è®°å½•æ—¶é—´**: 2024å¹´æ˜¥å­£å­¦æœŸ

---

## ğŸ“š ç¬¬ä¸€å‘¨ï¼šDAppæ¶æ„è®¾è®¡ä¸å®ç°

### è¯¾å ‚ä¸»é¢˜ï¼šä»é›¶åˆ°ä¸€æ„å»ºå»ä¸­å¿ƒåŒ–åº”ç”¨
**æ—¶é—´**: 2024å¹´3æœˆ4æ—¥  
**é‡ç‚¹å†…å®¹**:

#### 1. DAppæ¶æ„è®¾è®¡åŸåˆ™
- **å‰åç«¯åˆ†ç¦»**: æ™ºèƒ½åˆçº¦ä½œä¸ºåç«¯ï¼ŒWeb3å‰ç«¯äº¤äº’
- **æ¨¡å—åŒ–è®¾è®¡**: åˆçº¦åŠŸèƒ½æ¨¡å—åŒ–ï¼Œä¾¿äºç»´æŠ¤å’Œå‡çº§
- **ç”¨æˆ·ä½“éªŒä¼˜å…ˆ**: ç®€åŒ–äº¤äº’æµç¨‹ï¼Œæå‡ç”¨æˆ·å‹å¥½æ€§
- **å®‰å…¨æ€§è€ƒè™‘**: å¤šå±‚å®‰å…¨é˜²æŠ¤ï¼Œä¿æŠ¤ç”¨æˆ·èµ„äº§

#### 2. å®ç”¨å»ä¸­å¿ƒåŒ–åº”ç”¨ç³»ç»Ÿ
```solidity
// PracticalDApp.sol - å®ç”¨å»ä¸­å¿ƒåŒ–åº”ç”¨
pragma solidity ^0.8.19;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/security/Pausable.sol";
import "@openzeppelin/contracts/utils/math/SafeMath.sol";

/**
 * @title PracticalDApp
 * @author ç½—ä½³åº·
 * @notice å®ç”¨çš„å»ä¸­å¿ƒåŒ–åº”ç”¨ï¼Œé›†æˆå¤šç§å¸¸ç”¨åŠŸèƒ½
 * @dev åŒ…å«ä»£å¸ç®¡ç†ã€æŠ•ç¥¨æ²»ç†ã€å¥–åŠ±åˆ†å‘ç­‰æ ¸å¿ƒåŠŸèƒ½
 */
contract PracticalDApp is ERC20, Ownable, ReentrancyGuard, Pausable {
    using SafeMath for uint256;
    
    // âœ… æ ¸å¿ƒçŠ¶æ€å˜é‡
    
    /// @notice åº”ç”¨ç‰ˆæœ¬å·
    string public constant VERSION = "1.0.0";
    
    /// @notice æœ€å¤§ä¾›åº”é‡
    uint256 public constant MAX_SUPPLY = 1000000 * 10**18;
    
    /// @notice ç”¨æˆ·ä¿¡æ¯ç»“æ„
    struct UserInfo {
        uint256 balance;           // ç”¨æˆ·ä½™é¢
        uint256 stakingAmount;     // è´¨æŠ¼é‡‘é¢
        uint256 rewardDebt;        // å¥–åŠ±å€ºåŠ¡
        uint256 lastActionTime;    // æœ€åæ“ä½œæ—¶é—´
        bool isActive;             // æ˜¯å¦æ´»è·ƒç”¨æˆ·
        uint256 referralCount;     // æ¨èäººæ•°
        address referrer;          // æ¨èäºº
    }
    
    /// @notice ç”¨æˆ·ä¿¡æ¯æ˜ å°„
    mapping(address => UserInfo) public userInfo;
    
    /// @notice æ´»è·ƒç”¨æˆ·åˆ—è¡¨
    address[] public activeUsers;
    
    /// @notice è´¨æŠ¼æ± ä¿¡æ¯
    struct StakingPool {
        uint256 totalStaked;       // æ€»è´¨æŠ¼é‡
        uint256 rewardPerSecond;   // æ¯ç§’å¥–åŠ±
        uint256 lastRewardTime;    // æœ€åå¥–åŠ±æ—¶é—´
        uint256 accRewardPerShare; // ç´¯ç§¯æ¯è‚¡å¥–åŠ±
        bool isActive;             // æ± å­æ˜¯å¦æ´»è·ƒ
    }
    
    /// @notice è´¨æŠ¼æ± 
    StakingPool public stakingPool;
    
    /// @notice æ²»ç†ææ¡ˆç»“æ„
    struct Proposal {
        uint256 id;                // ææ¡ˆID
        address proposer;          // ææ¡ˆäºº
        string title;              // ææ¡ˆæ ‡é¢˜
        string description;        // ææ¡ˆæè¿°
        uint256 startTime;         // å¼€å§‹æ—¶é—´
        uint256 endTime;           // ç»“æŸæ—¶é—´
        uint256 forVotes;          // èµæˆç¥¨æ•°
        uint256 againstVotes;      // åå¯¹ç¥¨æ•°
        bool executed;             // æ˜¯å¦å·²æ‰§è¡Œ
        mapping(address => bool) hasVoted; // æ˜¯å¦å·²æŠ•ç¥¨
        mapping(address => bool) voteChoice; // æŠ•ç¥¨é€‰æ‹©
    }
    
    /// @notice ææ¡ˆæ˜ å°„
    mapping(uint256 => Proposal) public proposals;
    
    /// @notice ææ¡ˆè®¡æ•°å™¨
    uint256 public proposalCount;
    
    /// @notice æœ€å°æŠ•ç¥¨æƒé‡
    uint256 public constant MIN_VOTING_POWER = 100 * 10**18;
    
    /// @notice ææ¡ˆæ‰§è¡Œå»¶è¿Ÿï¼ˆç§’ï¼‰
    uint256 public constant EXECUTION_DELAY = 2 days;
    
    // âœ… äº‹ä»¶å®šä¹‰
    
    /// @notice ç”¨æˆ·æ³¨å†Œäº‹ä»¶
    event UserRegistered(
        address indexed user,
        address indexed referrer,
        uint256 timestamp
    );
    
    /// @notice è´¨æŠ¼äº‹ä»¶
    event Staked(
        address indexed user,
        uint256 amount,
        uint256 timestamp
    );
    
    /// @notice å–æ¶ˆè´¨æŠ¼äº‹ä»¶
    event Unstaked(
        address indexed user,
        uint256 amount,
        uint256 reward,
        uint256 timestamp
    );
    
    /// @notice å¥–åŠ±é¢†å–äº‹ä»¶
    event RewardClaimed(
        address indexed user,
        uint256 amount,
        uint256 timestamp
    );
    
    /// @notice ææ¡ˆåˆ›å»ºäº‹ä»¶
    event ProposalCreated(
        uint256 indexed proposalId,
        address indexed proposer,
        string title,
        uint256 startTime,
        uint256 endTime
    );
    
    /// @notice æŠ•ç¥¨äº‹ä»¶
    event Voted(
        uint256 indexed proposalId,
        address indexed voter,
        bool choice,
        uint256 votingPower,
        uint256 timestamp
    );
    
    /// @notice ææ¡ˆæ‰§è¡Œäº‹ä»¶
    event ProposalExecuted(
        uint256 indexed proposalId,
        bool success,
        uint256 timestamp
    );
    
    // âœ… ä¿®é¥°ç¬¦
    
    /// @notice æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å·²æ³¨å†Œ
    modifier onlyRegistered() {
        require(userInfo[msg.sender].isActive, "User not registered");
        _;
    }
    
    /// @notice æ£€æŸ¥ææ¡ˆæ˜¯å¦å­˜åœ¨
    modifier proposalExists(uint256 proposalId) {
        require(proposalId > 0 && proposalId <= proposalCount, "Proposal does not exist");
        _;
    }
    
    /// @notice æ£€æŸ¥æŠ•ç¥¨æƒé™
    modifier canVote(uint256 proposalId) {
        require(!proposals[proposalId].hasVoted[msg.sender], "Already voted");
        require(balanceOf(msg.sender) >= MIN_VOTING_POWER, "Insufficient voting power");
        require(
            block.timestamp >= proposals[proposalId].startTime &&
            block.timestamp <= proposals[proposalId].endTime,
            "Voting period not active"
        );
        _;
    }
    
    // âœ… æ„é€ å‡½æ•°
    
    constructor(
        string memory name,
        string memory symbol,
        uint256 initialSupply
    ) ERC20(name, symbol) {
        require(initialSupply <= MAX_SUPPLY, "Initial supply exceeds maximum");
        
        _mint(msg.sender, initialSupply);
        
        // åˆå§‹åŒ–è´¨æŠ¼æ± 
        stakingPool = StakingPool({
            totalStaked: 0,
            rewardPerSecond: 1 * 10**15, // 0.001 tokens per second
            lastRewardTime: block.timestamp,
            accRewardPerShare: 0,
            isActive: true
        });
        
        // æ³¨å†Œéƒ¨ç½²è€…ä¸ºç¬¬ä¸€ä¸ªç”¨æˆ·
        _registerUser(msg.sender, address(0));
    }
    
    // âœ… ç”¨æˆ·ç®¡ç†åŠŸèƒ½
    
    /// @notice ç”¨æˆ·æ³¨å†Œ
    /// @param referrer æ¨èäººåœ°å€
    function registerUser(address referrer) external {
        require(!userInfo[msg.sender].isActive, "User already registered");
        require(referrer != msg.sender, "Cannot refer yourself");
        
        if (referrer != address(0)) {
            require(userInfo[referrer].isActive, "Invalid referrer");
        }
        
        _registerUser(msg.sender, referrer);
    }
    
    /// @notice å†…éƒ¨æ³¨å†Œå‡½æ•°
    /// @param user ç”¨æˆ·åœ°å€
    /// @param referrer æ¨èäººåœ°å€
    function _registerUser(address user, address referrer) internal {
        userInfo[user] = UserInfo({
            balance: 0,
            stakingAmount: 0,
            rewardDebt: 0,
            lastActionTime: block.timestamp,
            isActive: true,
            referralCount: 0,
            referrer: referrer
        });
        
        activeUsers.push(user);
        
        // æ›´æ–°æ¨èäººä¿¡æ¯
        if (referrer != address(0)) {
            userInfo[referrer].referralCount = userInfo[referrer].referralCount.add(1);
            
            // ç»™æ¨èäººå¥–åŠ±
            uint256 referralReward = 10 * 10**18; // 10 tokens
            if (totalSupply().add(referralReward) <= MAX_SUPPLY) {
                _mint(referrer, referralReward);
            }
        }
        
        emit UserRegistered(user, referrer, block.timestamp);
    }
    
    /// @notice è·å–ç”¨æˆ·è¯¦ç»†ä¿¡æ¯
    /// @param user ç”¨æˆ·åœ°å€
    /// @return ç”¨æˆ·ä¿¡æ¯ç»“æ„ä½“
    function getUserInfo(address user) external view returns (
        uint256 balance,
        uint256 stakingAmount,
        uint256 pendingReward,
        uint256 lastActionTime,
        bool isActive,
        uint256 referralCount,
        address referrer
    ) {
        UserInfo memory info = userInfo[user];
        return (
            info.balance,
            info.stakingAmount,
            _calculatePendingReward(user),
            info.lastActionTime,
            info.isActive,
            info.referralCount,
            info.referrer
        );
    }
    
    // âœ… è´¨æŠ¼åŠŸèƒ½
    
    /// @notice è´¨æŠ¼ä»£å¸
    /// @param amount è´¨æŠ¼æ•°é‡
    function stake(uint256 amount) external onlyRegistered whenNotPaused nonReentrant {
        require(amount > 0, "Amount must be greater than 0");
        require(balanceOf(msg.sender) >= amount, "Insufficient balance");
        require(stakingPool.isActive, "Staking pool not active");
        
        // æ›´æ–°æ± å­å¥–åŠ±
        _updatePool();
        
        UserInfo storage user = userInfo[msg.sender];
        
        // å¦‚æœç”¨æˆ·å·²æœ‰è´¨æŠ¼ï¼Œå…ˆé¢†å–å¥–åŠ±
        if (user.stakingAmount > 0) {
            uint256 pending = user.stakingAmount.mul(stakingPool.accRewardPerShare).div(1e12).sub(user.rewardDebt);
            if (pending > 0) {
                _safeRewardTransfer(msg.sender, pending);
                emit RewardClaimed(msg.sender, pending, block.timestamp);
            }
        }
        
        // è½¬ç§»ä»£å¸åˆ°åˆçº¦
        _transfer(msg.sender, address(this), amount);
        
        // æ›´æ–°ç”¨æˆ·å’Œæ± å­ä¿¡æ¯
        user.stakingAmount = user.stakingAmount.add(amount);
        user.rewardDebt = user.stakingAmount.mul(stakingPool.accRewardPerShare).div(1e12);
        user.lastActionTime = block.timestamp;
        
        stakingPool.totalStaked = stakingPool.totalStaked.add(amount);
        
        emit Staked(msg.sender, amount, block.timestamp);
    }
    
    /// @notice å–æ¶ˆè´¨æŠ¼
    /// @param amount å–æ¶ˆè´¨æŠ¼æ•°é‡
    function unstake(uint256 amount) external onlyRegistered nonReentrant {
        UserInfo storage user = userInfo[msg.sender];
        require(user.stakingAmount >= amount, "Insufficient staked amount");
        require(amount > 0, "Amount must be greater than 0");
        
        // æ›´æ–°æ± å­å¥–åŠ±
        _updatePool();
        
        // è®¡ç®—å¾…é¢†å–å¥–åŠ±
        uint256 pending = user.stakingAmount.mul(stakingPool.accRewardPerShare).div(1e12).sub(user.rewardDebt);
        
        // æ›´æ–°ç”¨æˆ·ä¿¡æ¯
        user.stakingAmount = user.stakingAmount.sub(amount);
        user.rewardDebt = user.stakingAmount.mul(stakingPool.accRewardPerShare).div(1e12);
        user.lastActionTime = block.timestamp;
        
        // æ›´æ–°æ± å­ä¿¡æ¯
        stakingPool.totalStaked = stakingPool.totalStaked.sub(amount);
        
        // è½¬ç§»ä»£å¸å›ç”¨æˆ·
        _transfer(address(this), msg.sender, amount);
        
        // å‘æ”¾å¥–åŠ±
        if (pending > 0) {
            _safeRewardTransfer(msg.sender, pending);
        }
        
        emit Unstaked(msg.sender, amount, pending, block.timestamp);
    }
    
    /// @notice é¢†å–å¥–åŠ±
    function claimReward() external onlyRegistered nonReentrant {
        _updatePool();
        
        UserInfo storage user = userInfo[msg.sender];
        uint256 pending = user.stakingAmount.mul(stakingPool.accRewardPerShare).div(1e12).sub(user.rewardDebt);
        
        require(pending > 0, "No pending reward");
        
        user.rewardDebt = user.stakingAmount.mul(stakingPool.accRewardPerShare).div(1e12);
        user.lastActionTime = block.timestamp;
        
        _safeRewardTransfer(msg.sender, pending);
        
        emit RewardClaimed(msg.sender, pending, block.timestamp);
    }
    
    /// @notice æ›´æ–°è´¨æŠ¼æ± å¥–åŠ±
    function _updatePool() internal {
        if (block.timestamp <= stakingPool.lastRewardTime) {
            return;
        }
        
        if (stakingPool.totalStaked == 0) {
            stakingPool.lastRewardTime = block.timestamp;
            return;
        }
        
        uint256 timeElapsed = block.timestamp.sub(stakingPool.lastRewardTime);
        uint256 reward = timeElapsed.mul(stakingPool.rewardPerSecond);
        
        // é“¸é€ å¥–åŠ±ä»£å¸ï¼ˆå¦‚æœä¸è¶…è¿‡æœ€å¤§ä¾›åº”é‡ï¼‰
        if (totalSupply().add(reward) <= MAX_SUPPLY) {
            _mint(address(this), reward);
            stakingPool.accRewardPerShare = stakingPool.accRewardPerShare.add(
                reward.mul(1e12).div(stakingPool.totalStaked)
            );
        }
        
        stakingPool.lastRewardTime = block.timestamp;
    }
    
    /// @notice å®‰å…¨çš„å¥–åŠ±è½¬ç§»
    /// @param to æ¥æ”¶åœ°å€
    /// @param amount è½¬ç§»æ•°é‡
    function _safeRewardTransfer(address to, uint256 amount) internal {
        uint256 contractBalance = balanceOf(address(this));
        if (amount > contractBalance) {
            _transfer(address(this), to, contractBalance);
        } else {
            _transfer(address(this), to, amount);
        }
    }
    
    /// @notice è®¡ç®—å¾…é¢†å–å¥–åŠ±
    /// @param user ç”¨æˆ·åœ°å€
    /// @return å¾…é¢†å–å¥–åŠ±æ•°é‡
    function _calculatePendingReward(address user) internal view returns (uint256) {
        UserInfo memory userInfoData = userInfo[user];
        uint256 accRewardPerShare = stakingPool.accRewardPerShare;
        
        if (block.timestamp > stakingPool.lastRewardTime && stakingPool.totalStaked != 0) {
            uint256 timeElapsed = block.timestamp.sub(stakingPool.lastRewardTime);
            uint256 reward = timeElapsed.mul(stakingPool.rewardPerSecond);
            accRewardPerShare = accRewardPerShare.add(reward.mul(1e12).div(stakingPool.totalStaked));
        }
        
        return userInfoData.stakingAmount.mul(accRewardPerShare).div(1e12).sub(userInfoData.rewardDebt);
    }
    
    // âœ… æ²»ç†åŠŸèƒ½
    
    /// @notice åˆ›å»ºææ¡ˆ
    /// @param title ææ¡ˆæ ‡é¢˜
    /// @param description ææ¡ˆæè¿°
    /// @param votingPeriod æŠ•ç¥¨æœŸé—´ï¼ˆç§’ï¼‰
    /// @return ææ¡ˆID
    function createProposal(
        string calldata title,
        string calldata description,
        uint256 votingPeriod
    ) external onlyRegistered returns (uint256) {
        require(bytes(title).length > 0, "Title cannot be empty");
        require(bytes(description).length > 0, "Description cannot be empty");
        require(votingPeriod >= 1 days && votingPeriod <= 30 days, "Invalid voting period");
        require(balanceOf(msg.sender) >= MIN_VOTING_POWER, "Insufficient tokens to create proposal");
        
        proposalCount = proposalCount.add(1);
        uint256 proposalId = proposalCount;
        
        Proposal storage proposal = proposals[proposalId];
        proposal.id = proposalId;
        proposal.proposer = msg.sender;
        proposal.title = title;
        proposal.description = description;
        proposal.startTime = block.timestamp;
        proposal.endTime = block.timestamp.add(votingPeriod);
        proposal.forVotes = 0;
        proposal.againstVotes = 0;
        proposal.executed = false;
        
        emit ProposalCreated(
            proposalId,
            msg.sender,
            title,
            proposal.startTime,
            proposal.endTime
        );
        
        return proposalId;
    }
    
    /// @notice æŠ•ç¥¨
    /// @param proposalId ææ¡ˆID
    /// @param support æ˜¯å¦æ”¯æŒï¼ˆtrueä¸ºæ”¯æŒï¼Œfalseä¸ºåå¯¹ï¼‰
    function vote(
        uint256 proposalId,
        bool support
    ) external onlyRegistered proposalExists(proposalId) canVote(proposalId) {
        Proposal storage proposal = proposals[proposalId];
        uint256 votingPower = balanceOf(msg.sender);
        
        proposal.hasVoted[msg.sender] = true;
        proposal.voteChoice[msg.sender] = support;
        
        if (support) {
            proposal.forVotes = proposal.forVotes.add(votingPower);
        } else {
            proposal.againstVotes = proposal.againstVotes.add(votingPower);
        }
        
        emit Voted(proposalId, msg.sender, support, votingPower, block.timestamp);
    }
    
    /// @notice æ‰§è¡Œææ¡ˆ
    /// @param proposalId ææ¡ˆID
    function executeProposal(uint256 proposalId) external proposalExists(proposalId) {
        Proposal storage proposal = proposals[proposalId];
        
        require(!proposal.executed, "Proposal already executed");
        require(block.timestamp > proposal.endTime, "Voting period not ended");
        require(
            block.timestamp >= proposal.endTime.add(EXECUTION_DELAY),
            "Execution delay not passed"
        );
        
        bool success = proposal.forVotes > proposal.againstVotes;
        proposal.executed = true;
        
        if (success) {
            // è¿™é‡Œå¯ä»¥æ·»åŠ å…·ä½“çš„æ‰§è¡Œé€»è¾‘
            // ä¾‹å¦‚ï¼šå‚æ•°æ›´æ–°ã€èµ„é‡‘åˆ†é…ç­‰
            _executeProposalLogic(proposalId);
        }
        
        emit ProposalExecuted(proposalId, success, block.timestamp);
    }
    
    /// @notice æ‰§è¡Œææ¡ˆé€»è¾‘ï¼ˆå¯æ‰©å±•ï¼‰
    /// @param proposalId ææ¡ˆID
    function _executeProposalLogic(uint256 proposalId) internal {
        // æ ¹æ®ææ¡ˆå†…å®¹æ‰§è¡Œç›¸åº”é€»è¾‘
        // è¿™é‡Œæ˜¯ç¤ºä¾‹å®ç°ï¼Œå®é™…åº”ç”¨ä¸­éœ€è¦æ ¹æ®å…·ä½“éœ€æ±‚å®šåˆ¶
        
        // ç¤ºä¾‹ï¼šå¦‚æœæ˜¯å¥–åŠ±ç‡è°ƒæ•´ææ¡ˆ
        if (keccak256(bytes(proposals[proposalId].title)) == keccak256(bytes("Increase Reward Rate"))) {
            stakingPool.rewardPerSecond = stakingPool.rewardPerSecond.mul(110).div(100); // å¢åŠ 10%
        }
    }
    
    /// @notice è·å–ææ¡ˆä¿¡æ¯
    /// @param proposalId ææ¡ˆID
    /// @return ææ¡ˆè¯¦ç»†ä¿¡æ¯
    function getProposal(uint256 proposalId) external view proposalExists(proposalId) returns (
        uint256 id,
        address proposer,
        string memory title,
        string memory description,
        uint256 startTime,
        uint256 endTime,
        uint256 forVotes,
        uint256 againstVotes,
        bool executed
    ) {
        Proposal storage proposal = proposals[proposalId];
        return (
            proposal.id,
            proposal.proposer,
            proposal.title,
            proposal.description,
            proposal.startTime,
            proposal.endTime,
            proposal.forVotes,
            proposal.againstVotes,
            proposal.executed
        );
    }
    
    /// @notice æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å·²å¯¹ææ¡ˆæŠ•ç¥¨
    /// @param proposalId ææ¡ˆID
    /// @param voter æŠ•ç¥¨è€…åœ°å€
    /// @return æ˜¯å¦å·²æŠ•ç¥¨å’ŒæŠ•ç¥¨é€‰æ‹©
    function getVoteStatus(uint256 proposalId, address voter) 
        external 
        view 
        proposalExists(proposalId) 
        returns (bool hasVoted, bool voteChoice) 
    {
        Proposal storage proposal = proposals[proposalId];
        return (proposal.hasVoted[voter], proposal.voteChoice[voter]);
    }
    
    // âœ… ç®¡ç†å‘˜åŠŸèƒ½
    
    /// @notice æš‚åœåˆçº¦
    function pause() external onlyOwner {
        _pause();
    }
    
    /// @notice æ¢å¤åˆçº¦
    function unpause() external onlyOwner {
        _unpause();
    }
    
    /// @notice æ›´æ–°è´¨æŠ¼æ± å¥–åŠ±ç‡
    /// @param newRewardPerSecond æ–°çš„æ¯ç§’å¥–åŠ±
    function updateRewardRate(uint256 newRewardPerSecond) external onlyOwner {
        _updatePool();
        stakingPool.rewardPerSecond = newRewardPerSecond;
    }
    
    /// @notice ç´§æ€¥æå–ï¼ˆä»…é™ç´§æ€¥æƒ…å†µï¼‰
    /// @param token ä»£å¸åœ°å€
    /// @param amount æå–æ•°é‡
    function emergencyWithdraw(address token, uint256 amount) external onlyOwner {
        if (token == address(0)) {
            payable(owner()).transfer(amount);
        } else {
            IERC20(token).transfer(owner(), amount);
        }
    }
    
    // âœ… æŸ¥è¯¢åŠŸèƒ½
    
    /// @notice è·å–æ´»è·ƒç”¨æˆ·æ•°é‡
    /// @return æ´»è·ƒç”¨æˆ·æ•°é‡
    function getActiveUserCount() external view returns (uint256) {
        return activeUsers.length;
    }
    
    /// @notice è·å–è´¨æŠ¼æ± ä¿¡æ¯
    /// @return è´¨æŠ¼æ± è¯¦ç»†ä¿¡æ¯
    function getStakingPoolInfo() external view returns (
        uint256 totalStaked,
        uint256 rewardPerSecond,
        uint256 lastRewardTime,
        uint256 accRewardPerShare,
        bool isActive
    ) {
        return (
            stakingPool.totalStaked,
            stakingPool.rewardPerSecond,
            stakingPool.lastRewardTime,
            stakingPool.accRewardPerShare,
            stakingPool.isActive
        );
    }
    
    /// @notice è·å–ç”¨æˆ·å¾…é¢†å–å¥–åŠ±
    /// @param user ç”¨æˆ·åœ°å€
    /// @return å¾…é¢†å–å¥–åŠ±æ•°é‡
    function getPendingReward(address user) external view returns (uint256) {
        return _calculatePendingReward(user);
    }
    
    /// @notice æ‰¹é‡è·å–ç”¨æˆ·ä¿¡æ¯
    /// @param users ç”¨æˆ·åœ°å€æ•°ç»„
    /// @return ç”¨æˆ·ä¿¡æ¯æ•°ç»„
    function getBatchUserInfo(address[] calldata users) 
        external 
        view 
        returns (UserInfo[] memory) 
    {
        UserInfo[] memory infos = new UserInfo[](users.length);
        for (uint256 i = 0; i < users.length; i++) {
            infos[i] = userInfo[users[i]];
        }
        return infos;
    }
    
    /// @notice è·å–åˆçº¦ç»Ÿè®¡ä¿¡æ¯
    /// @return ç»Ÿè®¡ä¿¡æ¯
    function getContractStats() external view returns (
        uint256 totalUsers,
        uint256 totalStaked,
        uint256 totalProposals,
        uint256 contractBalance
    ) {
        return (
            activeUsers.length,
            stakingPool.totalStaked,
            proposalCount,
            balanceOf(address(this))
        );
    }
    
    // âœ… æ¥æ”¶ETHåŠŸèƒ½
    
    /// @notice æ¥æ”¶ETH
    receive() external payable {
        // å¯ä»¥åœ¨è¿™é‡Œæ·»åŠ ETHæ¥æ”¶é€»è¾‘
    }
    
    /// @notice å›é€€å‡½æ•°
    fallback() external payable {
        // å¤„ç†æœªçŸ¥å‡½æ•°è°ƒç”¨
    }
}
```

**å®ç”¨è®¾è®¡**: é›†æˆå¤šç§å¸¸ç”¨DAppåŠŸèƒ½ï¼Œæ³¨é‡ç”¨æˆ·ä½“éªŒ

---

## ğŸ“š ç¬¬äºŒå‘¨ï¼šå‰ç«¯é›†æˆä¸Web3äº¤äº’

### è¯¾å ‚ä¸»é¢˜ï¼šæ„å»ºç”¨æˆ·å‹å¥½çš„DAppå‰ç«¯
**æ—¶é—´**: 2024å¹´3æœˆ11æ—¥  
**é‡ç‚¹å†…å®¹**:

#### 1. Web3å‰ç«¯æŠ€æœ¯æ ˆ
- **React + TypeScript**: ç°ä»£åŒ–å‰ç«¯æ¡†æ¶
- **ethers.js**: ä»¥å¤ªåŠäº¤äº’åº“
- **Web3Modal**: é’±åŒ…è¿æ¥ç®¡ç†
- **Material-UI**: ç»„ä»¶åº“å’Œè®¾è®¡ç³»ç»Ÿ

#### 2. DAppå‰ç«¯å®ç°
```typescript
// DAppInterface.tsx - DAppå‰ç«¯æ¥å£
import React, { useState, useEffect, useCallback } from 'react';
import { ethers } from 'ethers';
import Web3Modal from 'web3modal';
import WalletConnectProvider from '@walletconnect/web3-provider';
import {
  Container,
  Grid,
  Card,
  CardContent,
  Typography,
  Button,
  TextField,
  Box,
  Tabs,
  Tab,
  Alert,
  CircularProgress,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  Paper,
  Chip,
  LinearProgress
} from '@mui/material';
import { styled } from '@mui/material/styles';

// åˆçº¦ABIï¼ˆç®€åŒ–ç‰ˆï¼‰
const CONTRACT_ABI = [
  "function registerUser(address referrer) external",
  "function stake(uint256 amount) external",
  "function unstake(uint256 amount) external",
  "function claimReward() external",
  "function createProposal(string title, string description, uint256 votingPeriod) external returns (uint256)",
  "function vote(uint256 proposalId, bool support) external",
  "function getUserInfo(address user) external view returns (uint256, uint256, uint256, uint256, bool, uint256, address)",
  "function getPendingReward(address user) external view returns (uint256)",
  "function getStakingPoolInfo() external view returns (uint256, uint256, uint256, uint256, bool)",
  "function getProposal(uint256 proposalId) external view returns (uint256, address, string, string, uint256, uint256, uint256, uint256, bool)",
  "function balanceOf(address account) external view returns (uint256)",
  "function proposalCount() external view returns (uint256)",
  "event UserRegistered(address indexed user, address indexed referrer, uint256 timestamp)",
  "event Staked(address indexed user, uint256 amount, uint256 timestamp)",
  "event Unstaked(address indexed user, uint256 amount, uint256 reward, uint256 timestamp)",
  "event RewardClaimed(address indexed user, uint256 amount, uint256 timestamp)",
  "event ProposalCreated(uint256 indexed proposalId, address indexed proposer, string title, uint256 startTime, uint256 endTime)",
  "event Voted(uint256 indexed proposalId, address indexed voter, bool choice, uint256 votingPower, uint256 timestamp)"
];

// åˆçº¦åœ°å€ï¼ˆéœ€è¦æ ¹æ®å®é™…éƒ¨ç½²åœ°å€ä¿®æ”¹ï¼‰
const CONTRACT_ADDRESS = "0x1234567890123456789012345678901234567890";

// æ ·å¼ç»„ä»¶
const StyledCard = styled(Card)(({ theme }) => ({
  height: '100%',
  display: 'flex',
  flexDirection: 'column',
  transition: 'transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out',
  '&:hover': {
    transform: 'translateY(-4px)',
    boxShadow: theme.shadows[8],
  },
}));

const GradientButton = styled(Button)(({ theme }) => ({
  background: 'linear-gradient(45deg, #FE6B8B 30%, #FF8E53 90%)',
  border: 0,
  borderRadius: 3,
  boxShadow: '0 3px 5px 2px rgba(255, 105, 135, .3)',
  color: 'white',
  height: 48,
  padding: '0 30px',
  '&:hover': {
    background: 'linear-gradient(45deg, #FE6B8B 60%, #FF8E53 100%)',
  },
}));

// æ¥å£å®šä¹‰
interface UserInfo {
  balance: string;
  stakingAmount: string;
  pendingReward: string;
  lastActionTime: string;
  isActive: boolean;
  referralCount: string;
  referrer: string;
}

interface StakingPoolInfo {
  totalStaked: string;
  rewardPerSecond: string;
  lastRewardTime: string;
  accRewardPerShare: string;
  isActive: boolean;
}

interface Proposal {
  id: string;
  proposer: string;
  title: string;
  description: string;
  startTime: string;
  endTime: string;
  forVotes: string;
  againstVotes: string;
  executed: boolean;
}

// ä¸»ç»„ä»¶
const DAppInterface: React.FC = () => {
  // çŠ¶æ€ç®¡ç†
  const [provider, setProvider] = useState<ethers.providers.Web3Provider | null>(null);
  const [signer, setSigner] = useState<ethers.Signer | null>(null);
  const [contract, setContract] = useState<ethers.Contract | null>(null);
  const [account, setAccount] = useState<string>('');
  const [userInfo, setUserInfo] = useState<UserInfo | null>(null);
  const [stakingPoolInfo, setStakingPoolInfo] = useState<StakingPoolInfo | null>(null);
  const [proposals, setProposals] = useState<Proposal[]>([]);
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<string>('');
  const [success, setSuccess] = useState<string>('');
  const [tabValue, setTabValue] = useState<number>(0);
  
  // è¡¨å•çŠ¶æ€
  const [stakeAmount, setStakeAmount] = useState<string>('');
  const [unstakeAmount, setUnstakeAmount] = useState<string>('');
  const [referrerAddress, setReferrerAddress] = useState<string>('');
  const [proposalTitle, setProposalTitle] = useState<string>('');
  const [proposalDescription, setProposalDescription] = useState<string>('');
  const [votingPeriod, setVotingPeriod] = useState<string>('7');
  
  // å¯¹è¯æ¡†çŠ¶æ€
  const [openRegisterDialog, setOpenRegisterDialog] = useState<boolean>(false);
  const [openProposalDialog, setOpenProposalDialog] = useState<boolean>(false);
  
  // Web3Modalé…ç½®
  const providerOptions = {
    walletconnect: {
      package: WalletConnectProvider,
      options: {
        infuraId: "YOUR_INFURA_ID" // æ›¿æ¢ä¸ºå®é™…çš„Infura ID
      }
    }
  };
  
  const web3Modal = new Web3Modal({
    network: "mainnet",
    cacheProvider: true,
    providerOptions
  });
  
  // è¿æ¥é’±åŒ…
  const connectWallet = useCallback(async () => {
    try {
      setLoading(true);
      const instance = await web3Modal.connect();
      const provider = new ethers.providers.Web3Provider(instance);
      const signer = provider.getSigner();
      const address = await signer.getAddress();
      
      setProvider(provider);
      setSigner(signer);
      setAccount(address);
      
      // åˆå§‹åŒ–åˆçº¦
      const contract = new ethers.Contract(CONTRACT_ADDRESS, CONTRACT_ABI, signer);
      setContract(contract);
      
      // åŠ è½½ç”¨æˆ·æ•°æ®
      await loadUserData(contract, address);
      
      setSuccess('é’±åŒ…è¿æ¥æˆåŠŸï¼');
    } catch (error) {
      console.error('è¿æ¥é’±åŒ…å¤±è´¥:', error);
      setError('è¿æ¥é’±åŒ…å¤±è´¥ï¼Œè¯·é‡è¯•');
    } finally {
      setLoading(false);
    }
  }, []);
  
  // æ–­å¼€é’±åŒ…è¿æ¥
  const disconnectWallet = useCallback(async () => {
    web3Modal.clearCachedProvider();
    setProvider(null);
    setSigner(null);
    setContract(null);
    setAccount('');
    setUserInfo(null);
    setStakingPoolInfo(null);
    setProposals([]);
  }, []);
  
  // åŠ è½½ç”¨æˆ·æ•°æ®
  const loadUserData = useCallback(async (contract: ethers.Contract, address: string) => {
    try {
      // è·å–ç”¨æˆ·ä¿¡æ¯
      const userInfoResult = await contract.getUserInfo(address);
      const userInfo: UserInfo = {
        balance: ethers.utils.formatEther(await contract.balanceOf(address)),
        stakingAmount: ethers.utils.formatEther(userInfoResult[1]),
        pendingReward: ethers.utils.formatEther(userInfoResult[2]),
        lastActionTime: new Date(userInfoResult[3].toNumber() * 1000).toLocaleString(),
        isActive: userInfoResult[4],
        referralCount: userInfoResult[5].toString(),
        referrer: userInfoResult[6]
      };
      setUserInfo(userInfo);
      
      // è·å–è´¨æŠ¼æ± ä¿¡æ¯
      const poolInfoResult = await contract.getStakingPoolInfo();
      const stakingPoolInfo: StakingPoolInfo = {
        totalStaked: ethers.utils.formatEther(poolInfoResult[0]),
        rewardPerSecond: ethers.utils.formatEther(poolInfoResult[1]),
        lastRewardTime: new Date(poolInfoResult[2].toNumber() * 1000).toLocaleString(),
        accRewardPerShare: poolInfoResult[3].toString(),
        isActive: poolInfoResult[4]
      };
      setStakingPoolInfo(stakingPoolInfo);
      
      // è·å–ææ¡ˆåˆ—è¡¨
      await loadProposals(contract);
      
    } catch (error) {
      console.error('åŠ è½½ç”¨æˆ·æ•°æ®å¤±è´¥:', error);
      setError('åŠ è½½æ•°æ®å¤±è´¥');
    }
  }, []);
  
  // åŠ è½½ææ¡ˆåˆ—è¡¨
  const loadProposals = useCallback(async (contract: ethers.Contract) => {
    try {
      const proposalCount = await contract.proposalCount();
      const proposalList: Proposal[] = [];
      
      for (let i = 1; i <= proposalCount.toNumber(); i++) {
        const proposalResult = await contract.getProposal(i);
        const proposal: Proposal = {
          id: proposalResult[0].toString(),
          proposer: proposalResult[1],
          title: proposalResult[2],
          description: proposalResult[3],
          startTime: new Date(proposalResult[4].toNumber() * 1000).toLocaleString(),
          endTime: new Date(proposalResult[5].toNumber() * 1000).toLocaleString(),
          forVotes: ethers.utils.formatEther(proposalResult[6]),
          againstVotes: ethers.utils.formatEther(proposalResult[7]),
          executed: proposalResult[8]
        };
        proposalList.push(proposal);
      }
      
      setProposals(proposalList.reverse()); // æœ€æ–°çš„åœ¨å‰é¢
    } catch (error) {
      console.error('åŠ è½½ææ¡ˆå¤±è´¥:', error);
    }
  }, []);
  
  // ç”¨æˆ·æ³¨å†Œ
  const registerUser = useCallback(async () => {
    if (!contract) return;
    
    try {
      setLoading(true);
      const referrer = referrerAddress || ethers.constants.AddressZero;
      const tx = await contract.registerUser(referrer);
      await tx.wait();
      
      setSuccess('ç”¨æˆ·æ³¨å†ŒæˆåŠŸï¼');
      setOpenRegisterDialog(false);
      setReferrerAddress('');
      
      // é‡æ–°åŠ è½½ç”¨æˆ·æ•°æ®
      await loadUserData(contract, account);
    } catch (error: any) {
      console.error('æ³¨å†Œå¤±è´¥:', error);
      setError(error.reason || 'æ³¨å†Œå¤±è´¥ï¼Œè¯·é‡è¯•');
    } finally {
      setLoading(false);
    }
  }, [contract, account, referrerAddress, loadUserData]);
  
  // è´¨æŠ¼ä»£å¸
  const stakeTokens = useCallback(async () => {
    if (!contract || !stakeAmount) return;
    
    try {
      setLoading(true);
      const amount = ethers.utils.parseEther(stakeAmount);
      const tx = await contract.stake(amount);
      await tx.wait();
      
      setSuccess(`æˆåŠŸè´¨æŠ¼ ${stakeAmount} ä»£å¸ï¼`);
      setStakeAmount('');
      
      // é‡æ–°åŠ è½½ç”¨æˆ·æ•°æ®
      await loadUserData(contract, account);
    } catch (error: any) {
      console.error('è´¨æŠ¼å¤±è´¥:', error);
      setError(error.reason || 'è´¨æŠ¼å¤±è´¥ï¼Œè¯·é‡è¯•');
    } finally {
      setLoading(false);
    }
  }, [contract, account, stakeAmount, loadUserData]);
  
  // å–æ¶ˆè´¨æŠ¼
  const unstakeTokens = useCallback(async () => {
    if (!contract || !unstakeAmount) return;
    
    try {
      setLoading(true);
      const amount = ethers.utils.parseEther(unstakeAmount);
      const tx = await contract.unstake(amount);
      await tx.wait();
      
      setSuccess(`æˆåŠŸå–æ¶ˆè´¨æŠ¼ ${unstakeAmount} ä»£å¸ï¼`);
      setUnstakeAmount('');
      
      // é‡æ–°åŠ è½½ç”¨æˆ·æ•°æ®
      await loadUserData(contract, account);
    } catch (error: any) {
      console.error('å–æ¶ˆè´¨æŠ¼å¤±è´¥:', error);
      setError(error.reason || 'å–æ¶ˆè´¨æŠ¼å¤±è´¥ï¼Œè¯·é‡è¯•');
    } finally {
      setLoading(false);
    }
  }, [contract, account, unstakeAmount, loadUserData]);
  
  // é¢†å–å¥–åŠ±
  const claimRewards = useCallback(async () => {
    if (!contract) return;
    
    try {
      setLoading(true);
      const tx = await contract.claimReward();
      await tx.wait();
      
      setSuccess('å¥–åŠ±é¢†å–æˆåŠŸï¼');
      
      // é‡æ–°åŠ è½½ç”¨æˆ·æ•°æ®
      await loadUserData(contract, account);
    } catch (error: any) {
      console.error('é¢†å–å¥–åŠ±å¤±è´¥:', error);
      setError(error.reason || 'é¢†å–å¥–åŠ±å¤±è´¥ï¼Œè¯·é‡è¯•');
    } finally {
      setLoading(false);
    }
  }, [contract, account, loadUserData]);
  
  // åˆ›å»ºææ¡ˆ
  const createProposal = useCallback(async () => {
    if (!contract || !proposalTitle || !proposalDescription) return;
    
    try {
      setLoading(true);
      const votingPeriodSeconds = parseInt(votingPeriod) * 24 * 60 * 60; // è½¬æ¢ä¸ºç§’
      const tx = await contract.createProposal(proposalTitle, proposalDescription, votingPeriodSeconds);
      await tx.wait();
      
      setSuccess('ææ¡ˆåˆ›å»ºæˆåŠŸï¼');
      setOpenProposalDialog(false);
      setProposalTitle('');
      setProposalDescription('');
      setVotingPeriod('7');
      
      // é‡æ–°åŠ è½½ææ¡ˆæ•°æ®
      await loadProposals(contract);
    } catch (error: any) {
      console.error('åˆ›å»ºææ¡ˆå¤±è´¥:', error);
      setError(error.reason || 'åˆ›å»ºææ¡ˆå¤±è´¥ï¼Œè¯·é‡è¯•');
    } finally {
      setLoading(false);
    }
  }, [contract, proposalTitle, proposalDescription, votingPeriod, loadProposals]);
  
  // æŠ•ç¥¨
  const voteOnProposal = useCallback(async (proposalId: string, support: boolean) => {
    if (!contract) return;
    
    try {
      setLoading(true);
      const tx = await contract.vote(proposalId, support);
      await tx.wait();
      
      setSuccess(`æŠ•ç¥¨æˆåŠŸï¼æ‚¨${support ? 'æ”¯æŒ' : 'åå¯¹'}è¯¥ææ¡ˆ`);
      
      // é‡æ–°åŠ è½½ææ¡ˆæ•°æ®
      await loadProposals(contract);
    } catch (error: any) {
      console.error('æŠ•ç¥¨å¤±è´¥:', error);
      setError(error.reason || 'æŠ•ç¥¨å¤±è´¥ï¼Œè¯·é‡è¯•');
    } finally {
      setLoading(false);
    }
  }, [contract, loadProposals]);
  
  // æ¸…é™¤æ¶ˆæ¯
  const clearMessages = useCallback(() => {
    setError('');
    setSuccess('');
  }, []);
  
  // é¡µé¢åŠ è½½æ—¶æ£€æŸ¥ç¼“å­˜çš„æä¾›è€…
  useEffect(() => {
    if (web3Modal.cachedProvider) {
      connectWallet();
    }
  }, [connectWallet]);
  
  // ç›‘å¬è´¦æˆ·å˜åŒ–
  useEffect(() => {
    if (provider) {
      const handleAccountsChanged = (accounts: string[]) => {
        if (accounts.length === 0) {
          disconnectWallet();
        } else {
          setAccount(accounts[0]);
          if (contract) {
            loadUserData(contract, accounts[0]);
          }
        }
      };
      
      const handleChainChanged = () => {
        window.location.reload();
      };
      
      provider.provider.on('accountsChanged', handleAccountsChanged);
      provider.provider.on('chainChanged', handleChainChanged);
      
      return () => {
        provider.provider.removeListener('accountsChanged', handleAccountsChanged);
        provider.provider.removeListener('chainChanged', handleChainChanged);
      };
    }
  }, [provider, contract, loadUserData, disconnectWallet]);
  
  // æ¸²æŸ“é’±åŒ…è¿æ¥æŒ‰é’®
  const renderWalletConnection = () => {
    if (!account) {
      return (
        <Box display="flex" justifyContent="center" mb={4}>
          <GradientButton
            onClick={connectWallet}
            disabled={loading}
            size="large"
          >
            {loading ? <CircularProgress size={24} color="inherit" /> : 'è¿æ¥é’±åŒ…'}
          </GradientButton>
        </Box>
      );
    }
    
    return (
      <Box display="flex" justifyContent="space-between" alignItems="center" mb={4}>
        <Typography variant="h6">
          å·²è¿æ¥: {account.slice(0, 6)}...{account.slice(-4)}
        </Typography>
        <Button onClick={disconnectWallet} variant="outlined">
          æ–­å¼€è¿æ¥
        </Button>
      </Box>
    );
  };
  
  // æ¸²æŸ“ç”¨æˆ·ä¿¡æ¯å¡ç‰‡
  const renderUserInfoCard = () => {
    if (!userInfo) return null;
    
    return (
      <StyledCard>
        <CardContent>
          <Typography variant="h6" gutterBottom>
            ç”¨æˆ·ä¿¡æ¯
          </Typography>
          <Grid container spacing={2}>
            <Grid item xs={6}>
              <Typography variant="body2" color="textSecondary">
                ä»£å¸ä½™é¢
              </Typography>
              <Typography variant="h6">
                {parseFloat(userInfo.balance).toFixed(4)} ä»£å¸
              </Typography>
            </Grid>
            <Grid item xs={6}>
              <Typography variant="body2" color="textSecondary">
                è´¨æŠ¼æ•°é‡
              </Typography>
              <Typography variant="h6">
                {parseFloat(userInfo.stakingAmount).toFixed(4)} ä»£å¸
              </Typography>
            </Grid>
            <Grid item xs={6}>
              <Typography variant="body2" color="textSecondary">
                å¾…é¢†å–å¥–åŠ±
              </Typography>
              <Typography variant="h6" color="primary">
                {parseFloat(userInfo.pendingReward).toFixed(6)} ä»£å¸
              </Typography>
            </Grid>
            <Grid item xs={6}>
              <Typography variant="body2" color="textSecondary">
                æ¨èäººæ•°
              </Typography>
              <Typography variant="h6">
                {userInfo.referralCount} äºº
              </Typography>
            </Grid>
          </Grid>
          
          {!userInfo.isActive && (
            <Box mt={2}>
              <Button
                variant="contained"
                color="primary"
                onClick={() => setOpenRegisterDialog(true)}
                fullWidth
              >
                æ³¨å†Œç”¨æˆ·
              </Button>
            </Box>
          )}
          
          {userInfo.isActive && parseFloat(userInfo.pendingReward) > 0 && (
            <Box mt={2}>
              <Button
                variant="contained"
                color="secondary"
                onClick={claimRewards}
                disabled={loading}
                fullWidth
              >
                {loading ? <CircularProgress size={20} /> : 'é¢†å–å¥–åŠ±'}
              </Button>
            </Box>
          )}
        </CardContent>
      </StyledCard>
    );
  };
  
  // æ¸²æŸ“è´¨æŠ¼å¡ç‰‡
  const renderStakingCard = () => {
    if (!userInfo?.isActive) return null;
    
    return (
      <StyledCard>
        <CardContent>
          <Typography variant="h6" gutterBottom>
            è´¨æŠ¼ç®¡ç†
          </Typography>
          
          <Box mb={3}>
            <Typography variant="body2" color="textSecondary" gutterBottom>
              è´¨æŠ¼ä»£å¸
            </Typography>
            <TextField
              fullWidth
              variant="outlined"
              placeholder="è¾“å…¥è´¨æŠ¼æ•°é‡"
              value={stakeAmount}
              onChange={(e) => setStakeAmount(e.target.value)}
              type="number"
              InputProps={{
                endAdornment: (
                  <Button
                    onClick={stakeTokens}
                    disabled={loading || !stakeAmount}
                    variant="contained"
                    size="small"
                  >
                    è´¨æŠ¼
                  </Button>
                )
              }}
            />
          </Box>
          
          <Box>
            <Typography variant="body2" color="textSecondary" gutterBottom>
              å–æ¶ˆè´¨æŠ¼
            </Typography>
            <TextField
              fullWidth
              variant="outlined"
              placeholder="è¾“å…¥å–æ¶ˆè´¨æŠ¼æ•°é‡"
              value={unstakeAmount}
              onChange={(e) => setUnstakeAmount(e.target.value)}
              type="number"
              InputProps={{
                endAdornment: (
                  <Button
                    onClick={unstakeTokens}
                    disabled={loading || !unstakeAmount}
                    variant="outlined"
                    size="small"
                  >
                    å–æ¶ˆè´¨æŠ¼
                  </Button>
                )
              }}
            />
          </Box>
        </CardContent>
      </StyledCard>
    );
  };
  
  // æ¸²æŸ“è´¨æŠ¼æ± ä¿¡æ¯å¡ç‰‡
  const renderStakingPoolCard = () => {
    if (!stakingPoolInfo) return null;
    
    return (
      <StyledCard>
        <CardContent>
          <Typography variant="h6" gutterBottom>
            è´¨æŠ¼æ± ä¿¡æ¯
          </Typography>
          <Grid container spacing={2}>
            <Grid item xs={6}>
              <Typography variant="body2" color="textSecondary">
                æ€»è´¨æŠ¼é‡
              </Typography>
              <Typography variant="h6">
                {parseFloat(stakingPoolInfo.totalStaked).toFixed(2)} ä»£å¸
              </Typography>
            </Grid>
            <Grid item xs={6}>
              <Typography variant="body2" color="textSecondary">
                æ¯ç§’å¥–åŠ±
              </Typography>
              <Typography variant="h6">
                {parseFloat(stakingPoolInfo.rewardPerSecond).toFixed(6)} ä»£å¸
              </Typography>
            </Grid>
            <Grid item xs={12}>
              <Typography variant="body2" color="textSecondary">
                æ± å­çŠ¶æ€
              </Typography>
              <Chip
                label={stakingPoolInfo.isActive ? 'æ´»è·ƒ' : 'éæ´»è·ƒ'}
                color={stakingPoolInfo.isActive ? 'success' : 'error'}
                size="small"
              />
            </Grid>
          </Grid>
        </CardContent>
      </StyledCard>
    );
  };
  
  // æ¸²æŸ“ææ¡ˆåˆ—è¡¨
  const renderProposals = () => {
    return (
      <Box>
        <Box display="flex" justifyContent="space-between" alignItems="center" mb={3}>
          <Typography variant="h6">
            æ²»ç†ææ¡ˆ
          </Typography>
          {userInfo?.isActive && (
            <Button
              variant="contained"
              onClick={() => setOpenProposalDialog(true)}
            >
              åˆ›å»ºææ¡ˆ
            </Button>
          )}
        </Box>
        
        <TableContainer component={Paper}>
          <Table>
            <TableHead>
              <TableRow>
                <TableCell>ID</TableCell>
                <TableCell>æ ‡é¢˜</TableCell>
                <TableCell>ææ¡ˆäºº</TableCell>
                <TableCell>èµæˆç¥¨</TableCell>
                <TableCell>åå¯¹ç¥¨</TableCell>
                <TableCell>çŠ¶æ€</TableCell>
                <TableCell>æ“ä½œ</TableCell>
              </TableRow>
            </TableHead>
            <TableBody>
              {proposals.map((proposal) => {
                const now = new Date().getTime();
                const endTime = new Date(proposal.endTime).getTime();
                const isVotingActive = now < endTime;
                
                return (
                  <TableRow key={proposal.id}>
                    <TableCell>{proposal.id}</TableCell>
                    <TableCell>
                      <Typography variant="body2" fontWeight="bold">
                        {proposal.title}
                      </Typography>
                      <Typography variant="caption" color="textSecondary">
                        {proposal.description.slice(0, 50)}...
                      </Typography>
                    </TableCell>
                    <TableCell>
                      {proposal.proposer.slice(0, 6)}...{proposal.proposer.slice(-4)}
                    </TableCell>
                    <TableCell>
                      <Typography color="success.main">
                        {parseFloat(proposal.forVotes).toFixed(2)}
                      </Typography>
                    </TableCell>
                    <TableCell>
                      <Typography color="error.main">
                        {parseFloat(proposal.againstVotes).toFixed(2)}
                      </Typography>
                    </TableCell>
                    <TableCell>
                      <Chip
                        label={
                          proposal.executed
                            ? 'å·²æ‰§è¡Œ'
                            : isVotingActive
                            ? 'æŠ•ç¥¨ä¸­'
                            : 'æŠ•ç¥¨ç»“æŸ'
                        }
                        color={
                          proposal.executed
                            ? 'success'
                            : isVotingActive
                            ? 'primary'
                            : 'default'
                        }
                        size="small"
                      />
                    </TableCell>
                    <TableCell>
                      {userInfo?.isActive && isVotingActive && !proposal.executed && (
                        <Box>
                          <Button
                            size="small"
                            variant="outlined"
                            color="success"
                            onClick={() => voteOnProposal(proposal.id, true)}
                            disabled={loading}
                            sx={{ mr: 1 }}
                          >
                            æ”¯æŒ
                          </Button>
                          <Button
                            size="small"
                            variant="outlined"
                            color="error"
                            onClick={() => voteOnProposal(proposal.id, false)}
                            disabled={loading}
                          >
                            åå¯¹
                          </Button>
                        </Box>
                      )}
                    </TableCell>
                  </TableRow>
                );
              })}
            </TableBody>
          </Table>
        </TableContainer>
      </Box>
    );
  };
  
  return (
    <Container maxWidth="lg" sx={{ py: 4 }}>
      {/* æ ‡é¢˜ */}
      <Typography variant="h3" component="h1" gutterBottom align="center">
        å®ç”¨DAppå¹³å°
      </Typography>
      <Typography variant="h6" color="textSecondary" align="center" gutterBottom>
        è´¨æŠ¼ã€æ²»ç†ã€å¥–åŠ±ä¸€ä½“åŒ–å»ä¸­å¿ƒåŒ–åº”ç”¨
      </Typography>
      
      {/* é’±åŒ…è¿æ¥ */}
      {renderWalletConnection()}
      
      {/* æ¶ˆæ¯æç¤º */}
      {error && (
        <Alert severity="error" onClose={clearMessages} sx={{ mb: 2 }}>
          {error}
        </Alert>
      )}
      {success && (
        <Alert severity="success" onClose={clearMessages} sx={{ mb: 2 }}>
          {success}
        </Alert>
      )}
      
      {/* åŠ è½½æŒ‡ç¤ºå™¨ */}
      {loading && <LinearProgress sx={{ mb: 2 }} />}
      
      {/* ä¸»è¦å†…å®¹ */}
      {account && (
        <>
          {/* æ ‡ç­¾é¡µ */}
          <Box sx={{ borderBottom: 1, borderColor: 'divider', mb: 3 }}>
            <Tabs value={tabValue} onChange={(_, newValue) => setTabValue(newValue)}>
              <Tab label="ä»ªè¡¨æ¿" />
              <Tab label="æ²»ç†" />
            </Tabs>
          </Box>
          
          {/* ä»ªè¡¨æ¿å†…å®¹ */}
          {tabValue === 0 && (
            <Grid container spacing={3}>
              <Grid item xs={12} md={4}>
                {renderUserInfoCard()}
              </Grid>
              <Grid item xs={12} md={4}>
                {renderStakingCard()}
              </Grid>
              <Grid item xs={12} md={4}>
                {renderStakingPoolCard()}
              </Grid>
            </Grid>
          )}
          
          {/* æ²»ç†å†…å®¹ */}
          {tabValue === 1 && renderProposals()}
        </>
      )}
      
      {/* ç”¨æˆ·æ³¨å†Œå¯¹è¯æ¡† */}
      <Dialog open={openRegisterDialog} onClose={() => setOpenRegisterDialog(false)}>
        <DialogTitle>ç”¨æˆ·æ³¨å†Œ</DialogTitle>
        <DialogContent>
          <TextField
            autoFocus
            margin="dense"
            label="æ¨èäººåœ°å€ï¼ˆå¯é€‰ï¼‰"
            fullWidth
            variant="outlined"
            value={referrerAddress}
            onChange={(e) => setReferrerAddress(e.target.value)}
            placeholder="0x..."
          />
        </DialogContent>
        <DialogActions>
          <Button onClick={() => setOpenRegisterDialog(false)}>å–æ¶ˆ</Button>
          <Button onClick={registerUser} disabled={loading}>æ³¨å†Œ</Button>
        </DialogActions>
      </Dialog>
      
      {/* åˆ›å»ºææ¡ˆå¯¹è¯æ¡† */}
      <Dialog open={openProposalDialog} onClose={() => setOpenProposalDialog(false)} maxWidth="md" fullWidth>
        <DialogTitle>åˆ›å»ºææ¡ˆ</DialogTitle>
        <DialogContent>
          <TextField
            autoFocus
            margin="dense"
            label="ææ¡ˆæ ‡é¢˜"
            fullWidth
            variant="outlined"
            value={proposalTitle}
            onChange={(e) => setProposalTitle(e.target.value)}
            sx={{ mb: 2 }}
          />
          <TextField
            margin="dense"
            label="ææ¡ˆæè¿°"
            fullWidth
            multiline
            rows={4}
            variant="outlined"
            value={proposalDescription}
            onChange={(e) => setProposalDescription(e.target.value)}
            sx={{ mb: 2 }}
          />
          <TextField
            margin="dense"
            label="æŠ•ç¥¨æœŸé—´ï¼ˆå¤©ï¼‰"
            type="number"
            variant="outlined"
            value={votingPeriod}
            onChange={(e) => setVotingPeriod(e.target.value)}
            inputProps={{ min: 1, max: 30 }}
          />
        </DialogContent>
        <DialogActions>
          <Button onClick={() => setOpenProposalDialog(false)}>å–æ¶ˆ</Button>
          <Button onClick={createProposal} disabled={loading || !proposalTitle || !proposalDescription}>
            åˆ›å»ºææ¡ˆ
          </Button>
        </DialogActions>
      </Dialog>
    </Container>
  );
};

export default DAppInterface;
```

**å‰ç«¯ç‰¹è‰²**: ç°ä»£åŒ–UIè®¾è®¡ï¼Œå®Œæ•´çš„Web3äº¤äº’åŠŸèƒ½

---

## ğŸ“š ç¬¬ä¸‰å‘¨ï¼šæ™ºèƒ½åˆçº¦éƒ¨ç½²ä¸æµ‹è¯•

### è¯¾å ‚ä¸»é¢˜ï¼šä»å¼€å‘åˆ°ç”Ÿäº§çš„å®Œæ•´æµç¨‹
**æ—¶é—´**: 2024å¹´3æœˆ18æ—¥  
**é‡ç‚¹å†…å®¹**:

#### 1. éƒ¨ç½²è„šæœ¬é…ç½®
```javascript
// deploy.js - éƒ¨ç½²è„šæœ¬
const { ethers } = require('hardhat');
const fs = require('fs');
const path = require('path');

async function main() {
  console.log('å¼€å§‹éƒ¨ç½² PracticalDApp åˆçº¦...');
  
  // è·å–éƒ¨ç½²è´¦æˆ·
  const [deployer] = await ethers.getSigners();
  console.log('éƒ¨ç½²è´¦æˆ·:', deployer.address);
  console.log('è´¦æˆ·ä½™é¢:', ethers.utils.formatEther(await deployer.getBalance()));
  
  // éƒ¨ç½²åˆçº¦
  const PracticalDApp = await ethers.getContractFactory('PracticalDApp');
  const initialSupply = ethers.utils.parseEther('100000'); // 10ä¸‡ä»£å¸åˆå§‹ä¾›åº”
  
  console.log('æ­£åœ¨éƒ¨ç½²åˆçº¦...');
  const dapp = await PracticalDApp.deploy(
    'PracticalToken',
    'PRAC',
    initialSupply
  );
  
  await dapp.deployed();
  console.log('åˆçº¦éƒ¨ç½²æˆåŠŸ!');
  console.log('åˆçº¦åœ°å€:', dapp.address);
  console.log('äº¤æ˜“å“ˆå¸Œ:', dapp.deployTransaction.hash);
  
  // ç­‰å¾…ç¡®è®¤
  console.log('ç­‰å¾…åŒºå—ç¡®è®¤...');
  await dapp.deployTransaction.wait(5);
  
  // éªŒè¯åˆçº¦
  if (network.name !== 'hardhat' && network.name !== 'localhost') {
    console.log('éªŒè¯åˆçº¦...');
    try {
      await hre.run('verify:verify', {
        address: dapp.address,
        constructorArguments: ['PracticalToken', 'PRAC', initialSupply],
      });
      console.log('åˆçº¦éªŒè¯æˆåŠŸ!');
    } catch (error) {
      console.log('åˆçº¦éªŒè¯å¤±è´¥:', error.message);
    }
  }
  
  // ä¿å­˜éƒ¨ç½²ä¿¡æ¯
  const deploymentInfo = {
    network: network.name,
    contractAddress: dapp.address,
    deployerAddress: deployer.address,
    transactionHash: dapp.deployTransaction.hash,
    blockNumber: dapp.deployTransaction.blockNumber,
    gasUsed: dapp.deployTransaction.gasLimit.toString(),
    timestamp: new Date().toISOString(),
    constructorArgs: {
      name: 'PracticalToken',
      symbol: 'PRAC',
      initialSupply: initialSupply.toString()
    }
  };
  
  const deploymentsDir = path.join(__dirname, '../deployments');
  if (!fs.existsSync(deploymentsDir)) {
    fs.mkdirSync(deploymentsDir, { recursive: true });
  }
  
  fs.writeFileSync(
    path.join(deploymentsDir, `${network.name}.json`),
    JSON.stringify(deploymentInfo, null, 2)
  );
  
  console.log('éƒ¨ç½²ä¿¡æ¯å·²ä¿å­˜åˆ°:', path.join(deploymentsDir, `${network.name}.json`));
  
  // åˆå§‹åŒ–è®¾ç½®
  console.log('æ‰§è¡Œåˆå§‹åŒ–è®¾ç½®...');
  
  // å¯ä»¥åœ¨è¿™é‡Œæ·»åŠ åˆå§‹åŒ–é€»è¾‘
  // ä¾‹å¦‚ï¼šè®¾ç½®åˆå§‹å‚æ•°ã€åˆ†é…åˆå§‹ä»£å¸ç­‰
  
  console.log('éƒ¨ç½²å®Œæˆ!');
}

main()
  .then(() => process.exit(0))
  .catch((error) => {
    console.error('éƒ¨ç½²å¤±è´¥:', error);
    process.exit(1);
  });
```

#### 2. æµ‹è¯•å¥—ä»¶
```javascript
// test/PracticalDApp.test.js - å®Œæ•´æµ‹è¯•å¥—ä»¶
const { expect } = require('chai');
const { ethers } = require('hardhat');
const { time } = require('@nomicfoundation/hardhat-network-helpers');

describe('PracticalDApp', function () {
  let dapp;
  let owner, user1, user2, user3;
  let initialSupply;
  
  beforeEach(async function () {
    [owner, user1, user2, user3] = await ethers.getSigners();
    
    const PracticalDApp = await ethers.getContractFactory('PracticalDApp');
    initialSupply = ethers.utils.parseEther('100000');
    
    dapp = await PracticalDApp.deploy('PracticalToken', 'PRAC', initialSupply);
    await dapp.deployed();
  });
  
  describe('éƒ¨ç½²æµ‹è¯•', function () {
    it('åº”è¯¥æ­£ç¡®è®¾ç½®åˆå§‹å‚æ•°', async function () {
      expect(await dapp.name()).to.equal('PracticalToken');
      expect(await dapp.symbol()).to.equal('PRAC');
      expect(await dapp.totalSupply()).to.equal(initialSupply);
      expect(await dapp.balanceOf(owner.address)).to.equal(initialSupply);
    });
    
    it('åº”è¯¥æ­£ç¡®åˆå§‹åŒ–è´¨æŠ¼æ± ', async function () {
      const poolInfo = await dapp.getStakingPoolInfo();
      expect(poolInfo.totalStaked).to.equal(0);
      expect(poolInfo.isActive).to.be.true;
    });
  });
  
  describe('ç”¨æˆ·æ³¨å†Œæµ‹è¯•', function () {
    it('åº”è¯¥å…è®¸ç”¨æˆ·æ³¨å†Œ', async function () {
      await dapp.connect(user1).registerUser(ethers.constants.AddressZero);
      
      const userInfo = await dapp.getUserInfo(user1.address);
      expect(userInfo.isActive).to.be.true;
    });
    
    it('åº”è¯¥æ­£ç¡®å¤„ç†æ¨èå…³ç³»', async function () {
      await dapp.connect(user1).registerUser(ethers.constants.AddressZero);
      await dapp.connect(user2).registerUser(user1.address);
      
      const user1Info = await dapp.getUserInfo(user1.address);
      const user2Info = await dapp.getUserInfo(user2.address);
      
      expect(user1Info.referralCount).to.equal(1);
      expect(user2Info.referrer).to.equal(user1.address);
    });
    
    it('åº”è¯¥ç»™æ¨èäººå¥–åŠ±', async function () {
      await dapp.connect(user1).registerUser(ethers.constants.AddressZero);
      
      const balanceBefore = await dapp.balanceOf(user1.address);
      await dapp.connect(user2).registerUser(user1.address);
      const balanceAfter = await dapp.balanceOf(user1.address);
      
      expect(balanceAfter.sub(balanceBefore)).to.equal(ethers.utils.parseEther('10'));
    });
  });
  
  describe('è´¨æŠ¼åŠŸèƒ½æµ‹è¯•', function () {
    beforeEach(async function () {
      // ç»™ç”¨æˆ·åˆ†é…ä»£å¸å¹¶æ³¨å†Œ
      await dapp.transfer(user1.address, ethers.utils.parseEther('1000'));
      await dapp.connect(user1).registerUser(ethers.constants.AddressZero);
    });
    
    it('åº”è¯¥å…è®¸ç”¨æˆ·è´¨æŠ¼ä»£å¸', async function () {
      const stakeAmount = ethers.utils.parseEther('100');
      
      await dapp.connect(user1).stake(stakeAmount);
      
      const userInfo = await dapp.getUserInfo(user1.address);
      expect(userInfo.stakingAmount).to.equal(stakeAmount);
      
      const poolInfo = await dapp.getStakingPoolInfo();
      expect(poolInfo.totalStaked).to.equal(stakeAmount);
    });
    
    it('åº”è¯¥æ­£ç¡®è®¡ç®—å¥–åŠ±', async function () {
      const stakeAmount = ethers.utils.parseEther('100');
      
      await dapp.connect(user1).stake(stakeAmount);
      
      // ç­‰å¾…ä¸€æ®µæ—¶é—´
      await time.increase(3600); // 1å°æ—¶
      
      const pendingReward = await dapp.getPendingReward(user1.address);
      expect(pendingReward).to.be.gt(0);
    });
    
    it('åº”è¯¥å…è®¸ç”¨æˆ·å–æ¶ˆè´¨æŠ¼', async function () {
      const stakeAmount = ethers.utils.parseEther('100');
      
      await dapp.connect(user1).stake(stakeAmount);
      await time.increase(3600);
      
      const balanceBefore = await dapp.balanceOf(user1.address);
      await dapp.connect(user1).unstake(stakeAmount);
      const balanceAfter = await dapp.balanceOf(user1.address);
      
      // åº”è¯¥æ”¶åˆ°æœ¬é‡‘å’Œå¥–åŠ±
      expect(balanceAfter.sub(balanceBefore)).to.be.gt(stakeAmount);
    });
  });
  
  describe('æ²»ç†åŠŸèƒ½æµ‹è¯•', function () {
    beforeEach(async function () {
      // ç»™ç”¨æˆ·åˆ†é…è¶³å¤Ÿçš„ä»£å¸ç”¨äºæ²»ç†
      await dapp.transfer(user1.address, ethers.utils.parseEther('1000'));
      await dapp.connect(user1).registerUser(ethers.constants.AddressZero);
    });
    
    it('åº”è¯¥å…è®¸åˆ›å»ºææ¡ˆ', async function () {
      const title = 'æµ‹è¯•ææ¡ˆ';
      const description = 'è¿™æ˜¯ä¸€ä¸ªæµ‹è¯•ææ¡ˆ';
      const votingPeriod = 7 * 24 * 60 * 60; // 7å¤©
      
      await expect(
        dapp.connect(user1).createProposal(title, description, votingPeriod)
      ).to.emit(dapp, 'ProposalCreated');
      
      const proposalCount = await dapp.proposalCount();
      expect(proposalCount).to.equal(1);
    });
    
    it('åº”è¯¥å…è®¸ç”¨æˆ·æŠ•ç¥¨', async function () {
      const title = 'æµ‹è¯•ææ¡ˆ';
      const description = 'è¿™æ˜¯ä¸€ä¸ªæµ‹è¯•ææ¡ˆ';
      const votingPeriod = 7 * 24 * 60 * 60;
      
      await dapp.connect(user1).createProposal(title, description, votingPeriod);
      
      await expect(
        dapp.connect(user1).vote(1, true)
      ).to.emit(dapp, 'Voted');
      
      const proposal = await dapp.getProposal(1);
      expect(proposal.forVotes).to.be.gt(0);
    });
    
    it('åº”è¯¥é˜²æ­¢é‡å¤æŠ•ç¥¨', async function () {
      const title = 'æµ‹è¯•ææ¡ˆ';
      const description = 'è¿™æ˜¯ä¸€ä¸ªæµ‹è¯•ææ¡ˆ';
      const votingPeriod = 7 * 24 * 60 * 60;
      
      await dapp.connect(user1).createProposal(title, description, votingPeriod);
      await dapp.connect(user1).vote(1, true);
      
      await expect(
        dapp.connect(user1).vote(1, false)
      ).to.be.revertedWith('Already voted');
    });
  });
  
  describe('å®‰å…¨æ€§æµ‹è¯•', function () {
    it('åº”è¯¥é˜²æ­¢é‡å…¥æ”»å‡»', async function () {
      // è¿™é‡Œå¯ä»¥æ·»åŠ é‡å…¥æ”»å‡»æµ‹è¯•
      // ç”±äºä½¿ç”¨äº†ReentrancyGuardï¼Œåº”è¯¥èƒ½é˜²æ­¢é‡å…¥
    });
    
    it('åº”è¯¥æ­£ç¡®å¤„ç†æš‚åœçŠ¶æ€', async function () {
      await dapp.transfer(user1.address, ethers.utils.parseEther('1000'));
      await dapp.connect(user1).registerUser(ethers.constants.AddressZero);
      
      await dapp.pause();
      
      await expect(
        dapp.connect(user1).stake(ethers.utils.parseEther('100'))
      ).to.be.revertedWith('Pausable: paused');
    });
  });
  
  describe('è¾¹ç•Œæ¡ä»¶æµ‹è¯•', function () {
    it('åº”è¯¥å¤„ç†é›¶é‡‘é¢è´¨æŠ¼', async function () {
      await dapp.transfer(user1.address, ethers.utils.parseEther('1000'));
      await dapp.connect(user1).registerUser(ethers.constants.AddressZero);
      
      await expect(
        dapp.connect(user1).stake(0)
      ).to.be.revertedWith('Amount must be greater than 0');
    });
    
    it('åº”è¯¥å¤„ç†ä½™é¢ä¸è¶³çš„æƒ…å†µ', async function () {
      await dapp.connect(user1).registerUser(ethers.constants.AddressZero);
      
      await expect(
        dapp.connect(user1).stake(ethers.utils.parseEther('1000'))
      ).to.be.revertedWith('Insufficient balance');
    });
  });
});
```

**æµ‹è¯•è¦†ç›–**: åŠŸèƒ½æµ‹è¯•ã€å®‰å…¨æµ‹è¯•ã€è¾¹ç•Œæ¡ä»¶æµ‹è¯•å…¨è¦†ç›–

---

## ğŸ“š ç¬¬å››å‘¨ï¼šæ€§èƒ½ä¼˜åŒ–ä¸ç›‘æ§

### è¯¾å ‚ä¸»é¢˜ï¼šç”Ÿäº§çº§DAppæ€§èƒ½ä¼˜åŒ–
**æ—¶é—´**: 2024å¹´3æœˆ25æ—¥  
**é‡ç‚¹å†…å®¹**:

#### 1. Gasä¼˜åŒ–ç­–ç•¥
```solidity
// GasOptimizer.sol - Gasä¼˜åŒ–å·¥å…·
pragma solidity ^0.8.19;

/**
 * @title GasOptimizer
 * @author ç½—ä½³åº·
 * @notice Gasä¼˜åŒ–å®ç”¨å·¥å…·å’ŒæŠ€å·§é›†åˆ
 */
library GasOptimizer {
    
    /// @notice æ‰¹é‡è½¬è´¦ä¼˜åŒ–
    /// @param token ERC20ä»£å¸åˆçº¦
    /// @param recipients æ¥æ”¶è€…æ•°ç»„
    /// @param amounts é‡‘é¢æ•°ç»„
    function batchTransfer(
        IERC20 token,
        address[] calldata recipients,
        uint256[] calldata amounts
    ) external {
        require(recipients.length == amounts.length, "Array length mismatch");
        
        uint256 length = recipients.length;
        for (uint256 i = 0; i < length;) {
            token.transferFrom(msg.sender, recipients[i], amounts[i]);
            unchecked {
                ++i;
            }
        }
    }
    
    /// @notice ä¼˜åŒ–çš„å­˜å‚¨æ‰“åŒ…
    struct PackedData {
        uint128 amount;      // 16å­—èŠ‚
        uint64 timestamp;    // 8å­—èŠ‚
        uint32 count;        // 4å­—èŠ‚
        uint16 status;       // 2å­—èŠ‚
        uint8 flag;          // 1å­—èŠ‚
        bool isActive;       // 1å­—èŠ‚
        // æ€»è®¡32å­—èŠ‚ï¼Œæ­£å¥½ä¸€ä¸ªå­˜å‚¨æ§½
    }
    
    /// @notice ä½è¿ç®—ä¼˜åŒ–ç¤ºä¾‹
    function setBitFlag(uint256 flags, uint8 position, bool value) 
        internal 
        pure 
        returns (uint256) 
    {
        if (value) {
            return flags | (1 << position);
        } else {
            return flags & ~(1 << position);
        }
    }
    
    /// @notice æ£€æŸ¥ä½æ ‡å¿—
    function getBitFlag(uint256 flags, uint8 position) 
        internal 
        pure 
        returns (bool) 
    {
        return (flags >> position) & 1 == 1;
    }
    
    /// @notice ä¼˜åŒ–çš„æ•°ç»„æ“ä½œ
    function removeFromArray(uint256[] storage array, uint256 index) internal {
        require(index < array.length, "Index out of bounds");
        
        // å°†æœ€åä¸€ä¸ªå…ƒç´ ç§»åˆ°è¦åˆ é™¤çš„ä½ç½®
        array[index] = array[array.length - 1];
        array.pop();
    }
    
    /// @notice é«˜æ•ˆçš„å­—ç¬¦ä¸²æ¯”è¾ƒ
    function compareStrings(string memory a, string memory b) 
        internal 
        pure 
        returns (bool) 
    {
        return keccak256(abi.encodePacked(a)) == keccak256(abi.encodePacked(b));
    }
}
```

#### 2. æ€§èƒ½ç›‘æ§ç³»ç»Ÿ
```javascript
// monitor.js - æ€§èƒ½ç›‘æ§è„šæœ¬
const { ethers } = require('ethers');
const fs = require('fs');
const path = require('path');

class DAppMonitor {
  constructor(contractAddress, providerUrl) {
    this.provider = new ethers.providers.JsonRpcProvider(providerUrl);
    this.contractAddress = contractAddress;
    this.contract = new ethers.Contract(
      contractAddress,
      require('../artifacts/contracts/PracticalDApp.sol/PracticalDApp.json').abi,
      this.provider
    );
    
    this.metrics = {
      gasUsage: [],
      transactionCounts: [],
      userActivity: [],
      stakingMetrics: [],
      governanceMetrics: []
    };
  }
  
  // ç›‘æ§Gasä½¿ç”¨æƒ…å†µ
  async monitorGasUsage() {
    console.log('å¼€å§‹ç›‘æ§Gasä½¿ç”¨æƒ…å†µ...');
    
    const filter = {
      address: this.contractAddress,
      fromBlock: 'latest'
    };
    
    this.provider.on(filter, async (log) => {
      try {
        const tx = await this.provider.getTransaction(log.transactionHash);
        const receipt = await this.provider.getTransactionReceipt(log.transactionHash);
        
        const gasMetric = {
          timestamp: new Date().toISOString(),
          transactionHash: log.transactionHash,
          gasLimit: tx.gasLimit.toString(),
          gasUsed: receipt.gasUsed.toString(),
          gasPrice: tx.gasPrice.toString(),
          gasCost: receipt.gasUsed.mul(tx.gasPrice).toString(),
          functionName: this.decodeFunctionName(tx.data)
        };
        
        this.metrics.gasUsage.push(gasMetric);
        
        // å¦‚æœGasä½¿ç”¨è¿‡é«˜ï¼Œå‘å‡ºè­¦å‘Š
        if (receipt.gasUsed.gt(ethers.utils.parseUnits('500000', 'wei'))) {
          console.warn(`âš ï¸  é«˜Gasä½¿ç”¨è­¦å‘Š: ${receipt.gasUsed.toString()} gas`);
        }
        
      } catch (error) {
        console.error('ç›‘æ§Gasä½¿ç”¨æ—¶å‡ºé”™:', error);
      }
    });
  }
  
  // ç›‘æ§ç”¨æˆ·æ´»åŠ¨
  async monitorUserActivity() {
    console.log('å¼€å§‹ç›‘æ§ç”¨æˆ·æ´»åŠ¨...');
    
    // ç›‘å¬ç”¨æˆ·æ³¨å†Œäº‹ä»¶
    this.contract.on('UserRegistered', (user, referrer, timestamp, event) => {
      const activity = {
        type: 'UserRegistered',
        user: user,
        referrer: referrer,
        timestamp: new Date(timestamp.toNumber() * 1000).toISOString(),
        blockNumber: event.blockNumber,
        transactionHash: event.transactionHash
      };
      
      this.metrics.userActivity.push(activity);
      console.log(`ğŸ“ æ–°ç”¨æˆ·æ³¨å†Œ: ${user}`);
    });
    
    // ç›‘å¬è´¨æŠ¼äº‹ä»¶
    this.contract.on('Staked', (user, amount, timestamp, event) => {
      const activity = {
        type: 'Staked',
        user: user,
        amount: ethers.utils.formatEther(amount),
        timestamp: new Date(timestamp.toNumber() * 1000).toISOString(),
        blockNumber: event.blockNumber,
        transactionHash: event.transactionHash
      };
      
      this.metrics.stakingMetrics.push(activity);
      console.log(`ğŸ’° ç”¨æˆ·è´¨æŠ¼: ${user} - ${ethers.utils.formatEther(amount)} ä»£å¸`);
    });
    
    // ç›‘å¬ææ¡ˆåˆ›å»ºäº‹ä»¶
    this.contract.on('ProposalCreated', (proposalId, proposer, title, startTime, endTime, event) => {
      const activity = {
        type: 'ProposalCreated',
        proposalId: proposalId.toString(),
        proposer: proposer,
        title: title,
        startTime: new Date(startTime.toNumber() * 1000).toISOString(),
        endTime: new Date(endTime.toNumber() * 1000).toISOString(),
        blockNumber: event.blockNumber,
        transactionHash: event.transactionHash
      };
      
      this.metrics.governanceMetrics.push(activity);
      console.log(`ğŸ—³ï¸  æ–°ææ¡ˆåˆ›å»º: ${title}`);
    });
  }
  
  // ç”Ÿæˆæ€§èƒ½æŠ¥å‘Š
  async generatePerformanceReport() {
    console.log('ç”Ÿæˆæ€§èƒ½æŠ¥å‘Š...');
    
    const report = {
      timestamp: new Date().toISOString(),
      contractAddress: this.contractAddress,
      summary: {
        totalTransactions: this.metrics.gasUsage.length,
        totalUsers: await this.getTotalUsers(),
        totalStaked: await this.getTotalStaked(),
        totalProposals: await this.getTotalProposals(),
        averageGasUsage: this.calculateAverageGasUsage(),
        peakGasUsage: this.getPeakGasUsage()
      },
      gasAnalysis: this.analyzeGasUsage(),
      userGrowth: this.analyzeUserGrowth(),
      stakingTrends: this.analyzeStakingTrends(),
      governanceActivity: this.analyzeGovernanceActivity()
    };
    
    // ä¿å­˜æŠ¥å‘Š
    const reportsDir = path.join(__dirname, '../reports');
    if (!fs.existsSync(reportsDir)) {
      fs.mkdirSync(reportsDir, { recursive: true });
    }
    
    const reportFile = path.join(reportsDir, `performance-${Date.now()}.json`);
    fs.writeFileSync(reportFile, JSON.stringify(report, null, 2));
    
    console.log(`ğŸ“Š æ€§èƒ½æŠ¥å‘Šå·²ä¿å­˜: ${reportFile}`);
    return report;
  }
  
  // è¾…åŠ©æ–¹æ³•
  decodeFunctionName(data) {
    try {
      const iface = new ethers.utils.Interface(this.contract.interface.fragments);
      const decoded = iface.parseTransaction({ data });
      return decoded.name;
    } catch (error) {
      return 'Unknown';
    }
  }
  
  async getTotalUsers() {
    try {
      return await this.contract.getActiveUserCount();
    } catch (error) {
      return 0;
    }
  }
  
  async getTotalStaked() {
    try {
      const poolInfo = await this.contract.getStakingPoolInfo();
      return ethers.utils.formatEther(poolInfo.totalStaked);
    } catch (error) {
      return '0';
    }
  }
  
  async getTotalProposals() {
    try {
      return await this.contract.proposalCount();
    } catch (error) {
      return 0;
    }
  }
  
  calculateAverageGasUsage() {
    if (this.metrics.gasUsage.length === 0) return 0;
    
    const total = this.metrics.gasUsage.reduce((sum, metric) => {
      return sum + parseInt(metric.gasUsed);
    }, 0);
    
    return Math.round(total / this.metrics.gasUsage.length);
  }
  
  getPeakGasUsage() {
    if (this.metrics.gasUsage.length === 0) return 0;
    
    return Math.max(...this.metrics.gasUsage.map(metric => parseInt(metric.gasUsed)));
  }
  
  analyzeGasUsage() {
    const functionGasUsage = {};
    
    this.metrics.gasUsage.forEach(metric => {
      const func = metric.functionName;
      if (!functionGasUsage[func]) {
        functionGasUsage[func] = {
          count: 0,
          totalGas: 0,
          averageGas: 0,
          maxGas: 0
        };
      }
      
      const gasUsed = parseInt(metric.gasUsed);
      functionGasUsage[func].count++;
      functionGasUsage[func].totalGas += gasUsed;
      functionGasUsage[func].maxGas = Math.max(functionGasUsage[func].maxGas, gasUsed);
    });
    
    // è®¡ç®—å¹³å‡å€¼
    Object.keys(functionGasUsage).forEach(func => {
      functionGasUsage[func].averageGas = Math.round(
        functionGasUsage[func].totalGas / functionGasUsage[func].count
      );
    });
    
    return functionGasUsage;
  }
  
  analyzeUserGrowth() {
    const dailyGrowth = {};
    
    this.metrics.userActivity
      .filter(activity => activity.type === 'UserRegistered')
      .forEach(activity => {
        const date = activity.timestamp.split('T')[0];
        dailyGrowth[date] = (dailyGrowth[date] || 0) + 1;
      });
    
    return dailyGrowth;
  }
  
  analyzeStakingTrends() {
    const dailyStaking = {};
    
    this.metrics.stakingMetrics.forEach(metric => {
      const date = metric.timestamp.split('T')[0];
      if (!dailyStaking[date]) {
        dailyStaking[date] = {
          totalAmount: 0,
          transactionCount: 0
        };
      }
      
      dailyStaking[date].totalAmount += parseFloat(metric.amount);
      dailyStaking[date].transactionCount++;
    });
    
    return dailyStaking;
  }
  
  analyzeGovernanceActivity() {
    const proposalActivity = {
      totalProposals: this.metrics.governanceMetrics.length,
      proposalsByMonth: {},
      averageVotingPeriod: 0
    };
    
    this.metrics.governanceMetrics.forEach(proposal => {
      const month = proposal.startTime.substring(0, 7); // YYYY-MM
      proposalActivity.proposalsByMonth[month] = 
        (proposalActivity.proposalsByMonth[month] || 0) + 1;
    });
    
    return proposalActivity;
  }
  
  // å¯åŠ¨ç›‘æ§
  start() {
    console.log('ğŸš€ å¯åŠ¨DAppæ€§èƒ½ç›‘æ§ç³»ç»Ÿ...');
    
    this.monitorGasUsage();
    this.monitorUserActivity();
    
    // æ¯å°æ—¶ç”Ÿæˆä¸€æ¬¡æŠ¥å‘Š
    setInterval(() => {
      this.generatePerformanceReport();
    }, 60 * 60 * 1000);
    
    console.log('âœ… ç›‘æ§ç³»ç»Ÿå·²å¯åŠ¨');
  }
}

// ä½¿ç”¨ç¤ºä¾‹
if (require.main === module) {
  const contractAddress = process.env.CONTRACT_ADDRESS || '0x1234567890123456789012345678901234567890';
  const providerUrl = process.env.PROVIDER_URL || 'http://localhost:8545';
  
  const monitor = new DAppMonitor(contractAddress, providerUrl);
  monitor.start();
}

module.exports = DAppMonitor;
```

**ç›‘æ§ç‰¹è‰²**: å…¨æ–¹ä½æ€§èƒ½ç›‘æ§ï¼Œå®æ—¶Gasåˆ†æå’Œç”¨æˆ·è¡Œä¸ºè¿½è¸ª

---

## ğŸ“š ç¬¬äº”å‘¨ï¼šå®‰å…¨å®¡è®¡ä¸æœ€ä½³å®è·µ

### è¯¾å ‚ä¸»é¢˜ï¼šç”Ÿäº§çº§å®‰å…¨ä¿éšœ
**æ—¶é—´**: 2024å¹´4æœˆ1æ—¥  
**é‡ç‚¹å†…å®¹**:

#### 1. å®‰å…¨æ£€æŸ¥æ¸…å•
```markdown
# DAppå®‰å…¨å®¡è®¡æ¸…å•

## æ™ºèƒ½åˆçº¦å®‰å…¨
- [ ] é‡å…¥æ”»å‡»é˜²æŠ¤ (ReentrancyGuard)
- [ ] æ•´æ•°æº¢å‡ºé˜²æŠ¤ (SafeMath/Solidity 0.8+)
- [ ] è®¿é—®æ§åˆ¶æ£€æŸ¥ (Ownable, Role-based)
- [ ] è¾“å…¥éªŒè¯ (require statements)
- [ ] çŠ¶æ€å˜é‡å¯è§æ€§ (private/internal)
- [ ] å‡½æ•°å¯è§æ€§æ§åˆ¶ (external/public/internal/private)
- [ ] äº‹ä»¶æ—¥å¿—è®°å½• (é‡è¦æ“ä½œéƒ½æœ‰äº‹ä»¶)
- [ ] ç´§æ€¥æš‚åœæœºåˆ¶ (Pausable)
- [ ] å‡çº§æœºåˆ¶å®‰å…¨æ€§ (å¦‚æœä½¿ç”¨ä»£ç†æ¨¡å¼)
- [ ] æ—¶é—´ä¾èµ–æ€§é—®é¢˜ (block.timestamp)
- [ ] éšæœºæ•°å®‰å…¨æ€§ (é¿å…ä½¿ç”¨block.hashç­‰)
- [ ] å¤–éƒ¨è°ƒç”¨å®‰å…¨ (checks-effects-interactions)

## å‰ç«¯å®‰å…¨
- [ ] é’±åŒ…è¿æ¥å®‰å…¨ (éªŒè¯ç­¾å)
- [ ] äº¤æ˜“ç¡®è®¤æœºåˆ¶ (ç”¨æˆ·ç¡®è®¤)
- [ ] è¾“å…¥éªŒè¯å’Œæ¸…ç† (é˜²æ­¢XSS)
- [ ] HTTPSå¼ºåˆ¶ä½¿ç”¨
- [ ] æ•æ„Ÿä¿¡æ¯ä¿æŠ¤ (ä¸åœ¨å‰ç«¯å­˜å‚¨ç§é’¥)
- [ ] é”™è¯¯å¤„ç† (ä¸æš´éœ²æ•æ„Ÿä¿¡æ¯)
- [ ] ä¼šè¯ç®¡ç† (é€‚å½“çš„è¶…æ—¶)
- [ ] å†…å®¹å®‰å…¨ç­–ç•¥ (CSP)

## éƒ¨ç½²å®‰å…¨
- [ ] ç§é’¥ç®¡ç† (ç¡¬ä»¶é’±åŒ…/å¤šç­¾)
- [ ] ç½‘ç»œé…ç½® (æ­£ç¡®çš„RPCç«¯ç‚¹)
- [ ] åˆçº¦éªŒè¯ (Etherscanç­‰)
- [ ] åˆå§‹å‚æ•°æ£€æŸ¥
- [ ] æƒé™ç§»äº¤ (å¦‚éœ€è¦)
- [ ] å¤‡ä»½å’Œæ¢å¤è®¡åˆ’
```

#### 2. è‡ªåŠ¨åŒ–å®‰å…¨æµ‹è¯•
```javascript
// security-tests.js - å®‰å…¨æµ‹è¯•å¥—ä»¶
const { expect } = require('chai');
const { ethers } = require('hardhat');
const { time } = require('@nomicfoundation/hardhat-network-helpers');

describe('å®‰å…¨æµ‹è¯•å¥—ä»¶', function () {
  let dapp, owner, attacker, user1;
  
  beforeEach(async function () {
    [owner, attacker, user1] = await ethers.getSigners();
    
    const PracticalDApp = await ethers.getContractFactory('PracticalDApp');
    dapp = await PracticalDApp.deploy(
      'PracticalToken',
      'PRAC',
      ethers.utils.parseEther('100000')
    );
    await dapp.deployed();
  });
  
  describe('é‡å…¥æ”»å‡»æµ‹è¯•', function () {
    it('åº”è¯¥é˜²æ­¢é‡å…¥æ”»å‡»', async function () {
      // éƒ¨ç½²æ¶æ„åˆçº¦
      const MaliciousContract = await ethers.getContractFactory('MaliciousReentrancy');
      const malicious = await MaliciousContract.deploy(dapp.address);
      
      // ç»™æ¶æ„åˆçº¦ä¸€äº›ä»£å¸
      await dapp.transfer(malicious.address, ethers.utils.parseEther('1000'));
      
      // å°è¯•é‡å…¥æ”»å‡»
      await expect(
        malicious.attack()
      ).to.be.revertedWith('ReentrancyGuard: reentrant call');
    });
  });
  
  describe('è®¿é—®æ§åˆ¶æµ‹è¯•', function () {
    it('åº”è¯¥é˜»æ­¢éæˆæƒçš„ç®¡ç†å‘˜æ“ä½œ', async function () {
      await expect(
        dapp.connect(attacker).pause()
      ).to.be.revertedWith('Ownable: caller is not the owner');
    });
    
    it('åº”è¯¥é˜»æ­¢éæˆæƒçš„ç´§æ€¥æå–', async function () {
      await expect(
        dapp.connect(attacker).emergencyWithdraw(ethers.constants.AddressZero, 1000)
      ).to.be.revertedWith('Ownable: caller is not the owner');
    });
  });
  
  describe('è¾“å…¥éªŒè¯æµ‹è¯•', function () {
    it('åº”è¯¥æ‹’ç»æ— æ•ˆçš„è´¨æŠ¼é‡‘é¢', async function () {
      await dapp.transfer(user1.address, ethers.utils.parseEther('1000'));
      await dapp.connect(user1).registerUser(ethers.constants.AddressZero);
      
      await expect(
        dapp.connect(user1).stake(0)
      ).to.be.revertedWith('Amount must be greater than 0');
    });
    
    it('åº”è¯¥æ‹’ç»ç©ºçš„ææ¡ˆæ ‡é¢˜', async function () {
      await dapp.transfer(user1.address, ethers.utils.parseEther('1000'));
      await dapp.connect(user1).registerUser(ethers.constants.AddressZero);
      
      await expect(
        dapp.connect(user1).createProposal('', 'æè¿°', 7 * 24 * 60 * 60)
      ).to.be.revertedWith('Title cannot be empty');
    });
  });
  
  describe('æ•´æ•°æº¢å‡ºæµ‹è¯•', function () {
    it('åº”è¯¥å¤„ç†å¤§æ•°å€¼æ“ä½œ', async function () {
      const maxUint256 = ethers.constants.MaxUint256;
      
      // æµ‹è¯•æ˜¯å¦æ­£ç¡®å¤„ç†å¤§æ•°å€¼
      // Solidity 0.8+ è‡ªåŠ¨æ£€æŸ¥æº¢å‡º
      await expect(
        dapp.transfer(user1.address, maxUint256)
      ).to.be.revertedWith('ERC20: transfer amount exceeds balance');
    });
  });
  
  describe('æ—¶é—´æ“ä½œæµ‹è¯•', function () {
    it('åº”è¯¥æ­£ç¡®å¤„ç†æ—¶é—´ç›¸å…³çš„é€»è¾‘', async function () {
      await dapp.transfer(user1.address, ethers.utils.parseEther('1000'));
      await dapp.connect(user1).registerUser(ethers.constants.AddressZero);
      
      // åˆ›å»ºææ¡ˆ
      const votingPeriod = 7 * 24 * 60 * 60;
      await dapp.connect(user1).createProposal('æµ‹è¯•', 'æè¿°', votingPeriod);
      
      // æ—¶é—´å¿«è¿›åˆ°æŠ•ç¥¨æœŸç»“æŸå
      await time.increase(votingPeriod + 1);
      
      // åº”è¯¥æ— æ³•æŠ•ç¥¨
      await expect(
        dapp.connect(user1).vote(1, true)
      ).to.be.revertedWith('Voting period not active');
    });
  });
  
  describe('çŠ¶æ€ä¸€è‡´æ€§æµ‹è¯•', function () {
    it('åº”è¯¥ä¿æŒçŠ¶æ€ä¸€è‡´æ€§', async function () {
      await dapp.transfer(user1.address, ethers.utils.parseEther('1000'));
      await dapp.connect(user1).registerUser(ethers.constants.AddressZero);
      
      const stakeAmount = ethers.utils.parseEther('100');
      
      // è®°å½•è´¨æŠ¼å‰çš„çŠ¶æ€
      const balanceBefore = await dapp.balanceOf(user1.address);
      const poolInfoBefore = await dapp.getStakingPoolInfo();
      
      // æ‰§è¡Œè´¨æŠ¼
      await dapp.connect(user1).stake(stakeAmount);
      
      // æ£€æŸ¥çŠ¶æ€ä¸€è‡´æ€§
      const balanceAfter = await dapp.balanceOf(user1.address);
      const poolInfoAfter = await dapp.getStakingPoolInfo();
      const userInfo = await dapp.getUserInfo(user1.address);
      
      expect(balanceBefore.sub(balanceAfter)).to.equal(stakeAmount);
      expect(poolInfoAfter.totalStaked.sub(poolInfoBefore.totalStaked)).to.equal(stakeAmount);
      expect(userInfo.stakingAmount).to.equal(stakeAmount);
    });
  });
});

// æ¶æ„é‡å…¥æ”»å‡»åˆçº¦ç¤ºä¾‹
contract MaliciousReentrancy {
    PracticalDApp public target;
    bool public attacking = false;
    
    constructor(address _target) {
        target = PracticalDApp(_target);
    }
    
    function attack() external {
        attacking = true;
        target.registerUser(address(0));
        target.stake(100 ether);
        target.unstake(100 ether);
    }
    
    // å°è¯•åœ¨æ¥æ”¶ä»£å¸æ—¶é‡å…¥
    receive() external payable {
        if (attacking && address(target).balance > 0) {
            target.unstake(100 ether);
        }
    }
}
```

**å®‰å…¨ç‰¹è‰²**: å…¨é¢çš„å®‰å…¨æµ‹è¯•è¦†ç›–ï¼Œè‡ªåŠ¨åŒ–æ¼æ´æ£€æµ‹

---

## ğŸ“š ç¬¬å…­å‘¨ï¼šé¡¹ç›®æ€»ç»“ä¸éƒ¨ç½²ä¸Šçº¿

### è¯¾å ‚ä¸»é¢˜ï¼šä»å¼€å‘åˆ°ç”Ÿäº§çš„å®Œæ•´äº¤ä»˜
**æ—¶é—´**: 2024å¹´4æœˆ8æ—¥  
**é‡ç‚¹å†…å®¹**:

#### 1. ç”Ÿäº§éƒ¨ç½²é…ç½®
```javascript
// production-deploy.js - ç”Ÿäº§ç¯å¢ƒéƒ¨ç½²è„šæœ¬
const { ethers } = require('hardhat');
const fs = require('fs');
const path = require('path');

async function deployToProduction() {
  console.log('ğŸš€ å¼€å§‹ç”Ÿäº§ç¯å¢ƒéƒ¨ç½²...');
  
  // ç¯å¢ƒæ£€æŸ¥
  if (network.name === 'hardhat' || network.name === 'localhost') {
    throw new Error('ä¸èƒ½åœ¨æœ¬åœ°ç½‘ç»œéƒ¨ç½²åˆ°ç”Ÿäº§ç¯å¢ƒ');
  }
  
  // è·å–éƒ¨ç½²è´¦æˆ·
  const [deployer] = await ethers.getSigners();
  console.log('éƒ¨ç½²è´¦æˆ·:', deployer.address);
  
  const balance = await deployer.getBalance();
  console.log('è´¦æˆ·ä½™é¢:', ethers.utils.formatEther(balance), 'ETH');
  
  // æ£€æŸ¥ä½™é¢æ˜¯å¦è¶³å¤Ÿ
  const minBalance = ethers.utils.parseEther('0.1');
  if (balance.lt(minBalance)) {
    throw new Error('è´¦æˆ·ä½™é¢ä¸è¶³ï¼Œè‡³å°‘éœ€è¦ 0.1 ETH');
  }
  
  // éƒ¨ç½²å‚æ•°
  const deployParams = {
    name: 'PracticalToken',
    symbol: 'PRAC',
    initialSupply: ethers.utils.parseEther('1000000') // 100ä¸‡ä»£å¸
  };
  
  console.log('éƒ¨ç½²å‚æ•°:', deployParams);
  
  // ä¼°ç®—Gasè´¹ç”¨
  const PracticalDApp = await ethers.getContractFactory('PracticalDApp');
  const deployTx = PracticalDApp.getDeployTransaction(
    deployParams.name,
    deployParams.symbol,
    deployParams.initialSupply
  );
  
  const gasEstimate = await deployer.estimateGas(deployTx);
  const gasPrice = await deployer.getGasPrice();
  const deploymentCost = gasEstimate.mul(gasPrice);
  
  console.log('é¢„ä¼°Gasç”¨é‡:', gasEstimate.toString());
  console.log('å½“å‰Gasä»·æ ¼:', ethers.utils.formatUnits(gasPrice, 'gwei'), 'Gwei');
  console.log('é¢„ä¼°éƒ¨ç½²æˆæœ¬:', ethers.utils.formatEther(deploymentCost), 'ETH');
  
  // ç”¨æˆ·ç¡®è®¤
  const readline = require('readline').createInterface({
    input: process.stdin,
    output: process.stdout
  });
  
  const answer = await new Promise(resolve => {
    readline.question('ç¡®è®¤éƒ¨ç½²åˆ°ç”Ÿäº§ç¯å¢ƒ? (yes/no): ', resolve);
  });
  
  readline.close();
  
  if (answer.toLowerCase() !== 'yes') {
    console.log('éƒ¨ç½²å·²å–æ¶ˆ');
    return;
  }
  
  // æ‰§è¡Œéƒ¨ç½²
  console.log('æ­£åœ¨éƒ¨ç½²åˆçº¦...');
  const dapp = await PracticalDApp.deploy(
    deployParams.name,
    deployParams.symbol,
    deployParams.initialSupply,
    {
      gasLimit: gasEstimate.mul(120).div(100), // å¢åŠ 20%çš„Gasé™åˆ¶
      gasPrice: gasPrice
    }
  );
  
  console.log('ç­‰å¾…éƒ¨ç½²ç¡®è®¤...');
  await dapp.deployed();
  
  console.log('âœ… åˆçº¦éƒ¨ç½²æˆåŠŸ!');
  console.log('åˆçº¦åœ°å€:', dapp.address);
  console.log('éƒ¨ç½²äº¤æ˜“:', dapp.deployTransaction.hash);
  
  // ç­‰å¾…æ›´å¤šç¡®è®¤
  console.log('ç­‰å¾…åŒºå—ç¡®è®¤...');
  const receipt = await dapp.deployTransaction.wait(5);
  console.log('å®é™…Gasä½¿ç”¨:', receipt.gasUsed.toString());
  console.log('å®é™…éƒ¨ç½²æˆæœ¬:', ethers.utils.formatEther(receipt.gasUsed.mul(gasPrice)), 'ETH');
  
  // éªŒè¯åˆçº¦
  if (process.env.ETHERSCAN_API_KEY) {
    console.log('æ­£åœ¨éªŒè¯åˆçº¦...');
    try {
      await hre.run('verify:verify', {
        address: dapp.address,
        constructorArguments: [
          deployParams.name,
          deployParams.symbol,
          deployParams.initialSupply
        ],
      });
      console.log('âœ… åˆçº¦éªŒè¯æˆåŠŸ!');
    } catch (error) {
      console.warn('âš ï¸  åˆçº¦éªŒè¯å¤±è´¥:', error.message);
    }
  }
  
  // ä¿å­˜éƒ¨ç½²ä¿¡æ¯
  const deploymentInfo = {
    network: network.name,
    contractAddress: dapp.address,
    deployerAddress: deployer.address,
    transactionHash: dapp.deployTransaction.hash,
    blockNumber: receipt.blockNumber,
    gasUsed: receipt.gasUsed.toString(),
    gasCost: receipt.gasUsed.mul(gasPrice).toString(),
    timestamp: new Date().toISOString(),
    constructorArgs: deployParams,
    verified: !!process.env.ETHERSCAN_API_KEY
  };
  
  const deploymentsDir = path.join(__dirname, '../deployments');
  if (!fs.existsSync(deploymentsDir)) {
    fs.mkdirSync(deploymentsDir, { recursive: true });
  }
  
  fs.writeFileSync(
    path.join(deploymentsDir, `${network.name}-production.json`),
    JSON.stringify(deploymentInfo, null, 2)
  );
  
  // ç”Ÿæˆå‰ç«¯é…ç½®
  const frontendConfig = {
    contractAddress: dapp.address,
    network: network.name,
    abi: PracticalDApp.interface.format('json')
  };
  
  fs.writeFileSync(
    path.join(__dirname, '../frontend/src/config/contract.json'),
    JSON.stringify(frontendConfig, null, 2)
  );
  
  console.log('ğŸ“„ éƒ¨ç½²ä¿¡æ¯å·²ä¿å­˜');
  console.log('ğŸ‰ ç”Ÿäº§ç¯å¢ƒéƒ¨ç½²å®Œæˆ!');
  
  // éƒ¨ç½²åæ£€æŸ¥
  console.log('\nğŸ” æ‰§è¡Œéƒ¨ç½²åæ£€æŸ¥...');
  await postDeploymentChecks(dapp);
}

async function postDeploymentChecks(contract) {
  try {
    // æ£€æŸ¥åŸºæœ¬ä¿¡æ¯
    const name = await contract.name();
    const symbol = await contract.symbol();
    const totalSupply = await contract.totalSupply();
    const owner = await contract.owner();
    
    console.log('åˆçº¦åç§°:', name);
    console.log('ä»£å¸ç¬¦å·:', symbol);
    console.log('æ€»ä¾›åº”é‡:', ethers.utils.formatEther(totalSupply));
    console.log('åˆçº¦æ‰€æœ‰è€…:', owner);
    
    // æ£€æŸ¥è´¨æŠ¼æ± çŠ¶æ€
    const poolInfo = await contract.getStakingPoolInfo();
    console.log('è´¨æŠ¼æ± çŠ¶æ€:', poolInfo.isActive ? 'æ´»è·ƒ' : 'éæ´»è·ƒ');
    
    // æ£€æŸ¥åˆçº¦æ˜¯å¦æš‚åœ
    const isPaused = await contract.paused();
    console.log('åˆçº¦çŠ¶æ€:', isPaused ? 'å·²æš‚åœ' : 'æ­£å¸¸è¿è¡Œ');
    
    console.log('âœ… éƒ¨ç½²åæ£€æŸ¥é€šè¿‡');
    
  } catch (error) {
    console.error('âŒ éƒ¨ç½²åæ£€æŸ¥å¤±è´¥:', error.message);
    throw error;
  }
}

if (require.main === module) {
  deployToProduction()
    .then(() => process.exit(0))
    .catch((error) => {
      console.error('éƒ¨ç½²å¤±è´¥:', error);
      process.exit(1);
    });
}

module.exports = { deployToProduction, postDeploymentChecks };
```

#### 2. é¡¹ç›®æ–‡æ¡£
```markdown
# PracticalDApp - å®ç”¨å»ä¸­å¿ƒåŒ–åº”ç”¨

## é¡¹ç›®æ¦‚è¿°

PracticalDApp æ˜¯ä¸€ä¸ªé›†æˆäº†ä»£å¸ç®¡ç†ã€è´¨æŠ¼æŒ–çŸ¿ã€æ²»ç†æŠ•ç¥¨ç­‰åŠŸèƒ½çš„ç»¼åˆæ€§å»ä¸­å¿ƒåŒ–åº”ç”¨ã€‚é¡¹ç›®æ³¨é‡å®é™…åº”ç”¨ä»·å€¼å’Œç”¨æˆ·ä½“éªŒï¼Œæä¾›äº†å®Œæ•´çš„å‰åç«¯è§£å†³æ–¹æ¡ˆã€‚

## æ ¸å¿ƒåŠŸèƒ½

### 1. ç”¨æˆ·ç®¡ç†ç³»ç»Ÿ
- ç”¨æˆ·æ³¨å†Œä¸æ¨èæœºåˆ¶
- ç”¨æˆ·ä¿¡æ¯ç®¡ç†
- æ¨èå¥–åŠ±ç³»ç»Ÿ

### 2. è´¨æŠ¼æŒ–çŸ¿ç³»ç»Ÿ
- ä»£å¸è´¨æŠ¼åŠŸèƒ½
- è‡ªåŠ¨å¥–åŠ±åˆ†å‘
- çµæ´»çš„å–æ¶ˆè´¨æŠ¼

### 3. æ²»ç†æŠ•ç¥¨ç³»ç»Ÿ
- ææ¡ˆåˆ›å»ºä¸ç®¡ç†
- åŸºäºä»£å¸æƒé‡çš„æŠ•ç¥¨
- ææ¡ˆæ‰§è¡Œæœºåˆ¶

### 4. å®‰å…¨ä¿éšœ
- é‡å…¥æ”»å‡»é˜²æŠ¤
- è®¿é—®æ§åˆ¶ç®¡ç†
- ç´§æ€¥æš‚åœæœºåˆ¶

## æŠ€æœ¯æ¶æ„

### æ™ºèƒ½åˆçº¦å±‚
- **è¯­è¨€**: Solidity 0.8.19
- **æ¡†æ¶**: Hardhat
- **æ ‡å‡†**: ERC20, OpenZeppelin
- **å®‰å…¨**: ReentrancyGuard, Pausable, Ownable

### å‰ç«¯å±‚
- **æ¡†æ¶**: React + TypeScript
- **Web3**: ethers.js
- **UI**: Material-UI
- **é’±åŒ…**: Web3Modal

### éƒ¨ç½²ä¸ç›‘æ§
- **éƒ¨ç½²**: Hardhat Deploy
- **ç›‘æ§**: è‡ªå®šä¹‰ç›‘æ§ç³»ç»Ÿ
- **æµ‹è¯•**: Comprehensive test suite

## å¿«é€Ÿå¼€å§‹

### ç¯å¢ƒè¦æ±‚
- Node.js >= 16.0.0
- npm >= 8.0.0
- Git

### å®‰è£…ä¾èµ–
```bash
npm install
```

### ç¼–è¯‘åˆçº¦
```bash
npx hardhat compile
```

### è¿è¡Œæµ‹è¯•
```bash
npx hardhat test
```

### æœ¬åœ°éƒ¨ç½²
```bash
npx hardhat node
npx hardhat run scripts/deploy.js --network localhost
```

### å¯åŠ¨å‰ç«¯
```bash
cd frontend
npm install
npm start
```

## éƒ¨ç½²æŒ‡å—

### æµ‹è¯•ç½‘éƒ¨ç½²
```bash
npx hardhat run scripts/deploy.js --network goerli
```

### ä¸»ç½‘éƒ¨ç½²
```bash
npx hardhat run scripts/production-deploy.js --network mainnet
```

## å®‰å…¨è€ƒè™‘

1. **æ™ºèƒ½åˆçº¦å®‰å…¨**
   - ä½¿ç”¨ OpenZeppelin å®‰å…¨åº“
   - å®æ–½é‡å…¥æ”»å‡»é˜²æŠ¤
   - å®Œå–„çš„è®¿é—®æ§åˆ¶

2. **å‰ç«¯å®‰å…¨**
   - è¾“å…¥éªŒè¯å’Œæ¸…ç†
   - å®‰å…¨çš„é’±åŒ…è¿æ¥
   - HTTPS å¼ºåˆ¶ä½¿ç”¨

3. **éƒ¨ç½²å®‰å…¨**
   - å¤šé‡ç­¾åé’±åŒ…
   - åˆçº¦éªŒè¯
   - æ¸è¿›å¼éƒ¨ç½²

## ç›‘æ§ä¸ç»´æŠ¤

- å®æ—¶æ€§èƒ½ç›‘æ§
- Gas ä½¿ç”¨åˆ†æ
- ç”¨æˆ·è¡Œä¸ºè¿½è¸ª
- è‡ªåŠ¨åŒ–æŠ¥å‘Šç”Ÿæˆ

## è´¡çŒ®æŒ‡å—

1. Fork é¡¹ç›®
2. åˆ›å»ºåŠŸèƒ½åˆ†æ”¯
3. æäº¤æ›´æ”¹
4. æ¨é€åˆ°åˆ†æ”¯
5. åˆ›å»º Pull Request

## è®¸å¯è¯

MIT License

## è”ç³»æ–¹å¼

- å¼€å‘è€…: ç½—ä½³åº·
- é‚®ç®±: luojiakang@example.com
- GitHub: @luojiakang
```

---

## ğŸ¯ å­¦ä¹ å¿ƒå¾—ä¸æ€»ç»“

### æ ¸å¿ƒæŠ€èƒ½æŒæ¡
1. **å…¨æ ˆDAppå¼€å‘**: ä»æ™ºèƒ½åˆçº¦åˆ°å‰ç«¯ç•Œé¢çš„å®Œæ•´å¼€å‘æµç¨‹
2. **å®ç”¨åŠŸèƒ½é›†æˆ**: è´¨æŠ¼ã€æ²»ç†ã€å¥–åŠ±ç­‰æ ¸å¿ƒDeFiåŠŸèƒ½å®ç°
3. **ç”Ÿäº§çº§éƒ¨ç½²**: å®Œæ•´çš„æµ‹è¯•ã€éƒ¨ç½²ã€ç›‘æ§æµç¨‹
4. **å®‰å…¨æœ€ä½³å®è·µ**: å…¨é¢çš„å®‰å…¨é˜²æŠ¤å’Œæµ‹è¯•è¦†ç›–

### æŠ€æœ¯åˆ›æ–°ç‚¹
1. **æ¨¡å—åŒ–æ¶æ„**: æ¸…æ™°çš„åŠŸèƒ½æ¨¡å—åˆ’åˆ†ï¼Œä¾¿äºç»´æŠ¤å’Œæ‰©å±•
2. **ç”¨æˆ·ä½“éªŒä¼˜åŒ–**: ç°ä»£åŒ–çš„å‰ç«¯ç•Œé¢å’Œæµç•…çš„äº¤äº’ä½“éªŒ
3. **æ€§èƒ½ç›‘æ§**: å®æ—¶çš„Gasåˆ†æå’Œç”¨æˆ·è¡Œä¸ºè¿½è¸ª
4. **è‡ªåŠ¨åŒ–æµç¨‹**: å®Œæ•´çš„CI/CDå’Œè‡ªåŠ¨åŒ–æµ‹è¯•æµç¨‹

### å®è·µé¡¹ç›®æˆæœ
1. **PracticalDAppåˆçº¦**: åŠŸèƒ½å®Œæ•´çš„å»ä¸­å¿ƒåŒ–åº”ç”¨åˆçº¦
2. **ç°ä»£åŒ–å‰ç«¯**: React + TypeScriptçš„Web3å‰ç«¯åº”ç”¨
3. **ç›‘æ§ç³»ç»Ÿ**: å…¨æ–¹ä½çš„æ€§èƒ½ç›‘æ§å’Œåˆ†æå·¥å…·
4. **éƒ¨ç½²æ–¹æ¡ˆ**: ç”Ÿäº§çº§çš„éƒ¨ç½²å’Œç»´æŠ¤æ–¹æ¡ˆ

### æœªæ¥å‘å±•æ–¹å‘
1. **è·¨é“¾é›†æˆ**: æ”¯æŒå¤šé“¾éƒ¨ç½²å’Œè·¨é“¾äº¤äº’
2. **Layer 2ä¼˜åŒ–**: é›†æˆLayer 2è§£å†³æ–¹æ¡ˆé™ä½Gasè´¹ç”¨
3. **ç§»åŠ¨ç«¯æ”¯æŒ**: å¼€å‘ç§»åŠ¨ç«¯DAppåº”ç”¨
4. **AIé›†æˆ**: å¼•å…¥AIæŠ€æœ¯ä¼˜åŒ–ç”¨æˆ·ä½“éªŒå’Œé£é™©ç®¡ç†

---

## ğŸ“š å‚è€ƒèµ„æº

### å®˜æ–¹æ–‡æ¡£
- [Solidity Documentation](https://docs.soliditylang.org/)
- [OpenZeppelin Contracts](https://docs.openzeppelin.com/contracts/)
- [Hardhat Documentation](https://hardhat.org/docs/)
- [ethers.js Documentation](https://docs.ethers.io/)

### å­¦ä¹ èµ„æº
- [Ethereum Development Tutorial](https://ethereum.org/en/developers/tutorials/)
- [DeFi Developer Roadmap](https://github.com/OffcierCia/DeFi-Developer-Road-Map)
- [Smart Contract Security Best Practices](https://consensys.github.io/smart-contract-best-practices/)
- [Web3 Frontend Development](https://web3.career/learn-web3)

### å·¥å…·å’Œåº“
- [Remix IDE](https://remix.ethereum.org/)
- [MetaMask](https://metamask.io/)
- [Etherscan](https://etherscan.io/)
- [OpenZeppelin Wizard](https://wizard.openzeppelin.com/)

### ç¤¾åŒºèµ„æº
- [Ethereum Stack Exchange](https://ethereum.stackexchange.com/)
- [r/ethdev](https://www.reddit.com/r/ethdev/)
- [Ethereum Developers Discord](https://discord.gg/ethereum-org)
- [DeFi Pulse](https://defipulse.com/)

---

*è®°å½•æ—¶é—´: 2024å¹´æ˜¥å­£å­¦æœŸ*  
*æœ€åæ›´æ–°: 2024å¹´4æœˆ8æ—¥*