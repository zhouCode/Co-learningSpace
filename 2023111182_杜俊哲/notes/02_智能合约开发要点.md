# 智能合约开发要点

> **学习者**: 杜俊哲  
> **学习特色**: 注重系统架构和设计模式  
> **代码风格**: 模块化架构，设计模式应用  
> **笔记重点**: 代理模式、工厂模式、模块化设计  
> **创建时间**: 2024年

---

## 🏗️ 系统架构设计

### 分层架构模式

在智能合约开发中，采用分层架构可以提高代码的可维护性和可扩展性。

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

// 数据访问层接口
interface IDataAccessLayer {
    function getData(bytes32 key) external view returns (bytes memory);
    function setData(bytes32 key, bytes memory data) external;
    function deleteData(bytes32 key) external;
}

// 业务逻辑层接口
interface IBusinessLogicLayer {
    function processTransaction(address user, uint256 amount, bytes memory data) external returns (bool);
    function validateInput(bytes memory input) external pure returns (bool);
    function calculateFee(uint256 amount) external view returns (uint256);
}

// 表现层接口
interface IPresentationLayer {
    function executeUserAction(string memory action, bytes memory params) external payable;
    function getUserInfo(address user) external view returns (bytes memory);
}

// 数据访问层实现
contract DataAccessLayer is IDataAccessLayer {
    mapping(bytes32 => bytes) private dataStore;
    mapping(address => bool) public authorizedCallers;
    
    modifier onlyAuthorized() {
        require(authorizedCallers[msg.sender], "Unauthorized access");
        _;
    }
    
    constructor() {
        authorizedCallers[msg.sender] = true;
    }
    
    function addAuthorizedCaller(address caller) external onlyAuthorized {
        authorizedCallers[caller] = true;
    }
    
    function getData(bytes32 key) external view override returns (bytes memory) {
        return dataStore[key];
    }
    
    function setData(bytes32 key, bytes memory data) external override onlyAuthorized {
        dataStore[key] = data;
    }
    
    function deleteData(bytes32 key) external override onlyAuthorized {
        delete dataStore[key];
    }
}

// 业务逻辑层实现
contract BusinessLogicLayer is IBusinessLogicLayer {
    IDataAccessLayer public dataLayer;
    
    uint256 public constant FEE_RATE = 100; // 1%
    uint256 public constant MAX_TRANSACTION_AMOUNT = 1000000 * 1e18;
    
    event TransactionProcessed(address indexed user, uint256 amount, bool success);
    
    constructor(address _dataLayer) {
        dataLayer = IDataAccessLayer(_dataLayer);
    }
    
    function processTransaction(
        address user, 
        uint256 amount, 
        bytes memory data
    ) external override returns (bool) {
        // 验证输入
        require(validateInput(data), "Invalid input data");
        require(amount <= MAX_TRANSACTION_AMOUNT, "Amount exceeds limit");
        
        // 计算费用
        uint256 fee = calculateFee(amount);
        uint256 netAmount = amount - fee;
        
        // 存储交易数据
        bytes32 txKey = keccak256(abi.encodePacked(user, block.timestamp, amount));
        bytes memory txData = abi.encode(user, netAmount, fee, block.timestamp);
        dataLayer.setData(txKey, txData);
        
        emit TransactionProcessed(user, amount, true);
        return true;
    }
    
    function validateInput(bytes memory input) public pure override returns (bool) {
        if (input.length == 0) return false;
        if (input.length > 1024) return false; // 限制输入大小
        
        // 可以添加更多验证逻辑
        return true;
    }
    
    function calculateFee(uint256 amount) public view override returns (uint256) {
        return (amount * FEE_RATE) / 10000;
    }
}

// 表现层实现
contract PresentationLayer is IPresentationLayer {
    IBusinessLogicLayer public businessLayer;
    
    mapping(string => bool) public supportedActions;
    
    event ActionExecuted(address indexed user, string action, bool success);
    
    constructor(address _businessLayer) {
        businessLayer = IBusinessLogicLayer(_businessLayer);
        
        // 初始化支持的操作
        supportedActions["deposit"] = true;
        supportedActions["withdraw"] = true;
        supportedActions["transfer"] = true;
    }
    
    function executeUserAction(
        string memory action, 
        bytes memory params
    ) external payable override {
        require(supportedActions[action], "Unsupported action");
        
        bool success = false;
        
        if (keccak256(bytes(action)) == keccak256(bytes("deposit"))) {
            success = _handleDeposit(params);
        } else if (keccak256(bytes(action)) == keccak256(bytes("withdraw"))) {
            success = _handleWithdraw(params);
        } else if (keccak256(bytes(action)) == keccak256(bytes("transfer"))) {
            success = _handleTransfer(params);
        }
        
        emit ActionExecuted(msg.sender, action, success);
    }
    
    function getUserInfo(address user) external view override returns (bytes memory) {
        // 从业务层获取用户信息
        bytes32 userKey = keccak256(abi.encodePacked("user", user));
        // 这里需要通过数据层获取信息，简化处理
        return abi.encode(user, block.timestamp);
    }
    
    function _handleDeposit(bytes memory params) internal returns (bool) {
        (uint256 amount) = abi.decode(params, (uint256));
        require(msg.value == amount, "Value mismatch");
        
        return businessLayer.processTransaction(msg.sender, amount, params);
    }
    
    function _handleWithdraw(bytes memory params) internal returns (bool) {
        (uint256 amount) = abi.decode(params, (uint256));
        
        return businessLayer.processTransaction(msg.sender, amount, params);
    }
    
    function _handleTransfer(bytes memory params) internal returns (bool) {
        (address to, uint256 amount) = abi.decode(params, (address, uint256));
        bytes memory transferData = abi.encode(msg.sender, to, amount);
        
        return businessLayer.processTransaction(msg.sender, amount, transferData);
    }
}
```

### 微服务架构模式

```solidity
// 服务注册中心
contract ServiceRegistry {
    struct Service {
        address serviceAddress;
        string serviceName;
        string version;
        bool isActive;
        uint256 registeredAt;
    }
    
    mapping(bytes32 => Service) public services;
    mapping(string => bytes32[]) public servicesByName;
    
    address public owner;
    
    event ServiceRegistered(bytes32 indexed serviceId, string serviceName, address serviceAddress);
    event ServiceDeregistered(bytes32 indexed serviceId);
    event ServiceUpdated(bytes32 indexed serviceId, address newAddress);
    
    modifier onlyOwner() {
        require(msg.sender == owner, "Only owner can perform this action");
        _;
    }
    
    constructor() {
        owner = msg.sender;
    }
    
    function registerService(
        string memory serviceName,
        string memory version,
        address serviceAddress
    ) external onlyOwner returns (bytes32) {
        bytes32 serviceId = keccak256(abi.encodePacked(serviceName, version, block.timestamp));
        
        services[serviceId] = Service({
            serviceAddress: serviceAddress,
            serviceName: serviceName,
            version: version,
            isActive: true,
            registeredAt: block.timestamp
        });
        
        servicesByName[serviceName].push(serviceId);
        
        emit ServiceRegistered(serviceId, serviceName, serviceAddress);
        return serviceId;
    }
    
    function deregisterService(bytes32 serviceId) external onlyOwner {
        require(services[serviceId].isActive, "Service not active");
        
        services[serviceId].isActive = false;
        emit ServiceDeregistered(serviceId);
    }
    
    function updateService(bytes32 serviceId, address newAddress) external onlyOwner {
        require(services[serviceId].isActive, "Service not active");
        
        services[serviceId].serviceAddress = newAddress;
        emit ServiceUpdated(serviceId, newAddress);
    }
    
    function getService(bytes32 serviceId) external view returns (Service memory) {
        return services[serviceId];
    }
    
    function getServicesByName(string memory serviceName) external view returns (bytes32[] memory) {
        return servicesByName[serviceName];
    }
    
    function getActiveServiceAddress(string memory serviceName) external view returns (address) {
        bytes32[] memory serviceIds = servicesByName[serviceName];
        
        for (uint256 i = serviceIds.length; i > 0; i--) {
            bytes32 serviceId = serviceIds[i - 1];
            if (services[serviceId].isActive) {
                return services[serviceId].serviceAddress;
            }
        }
        
        revert("No active service found");
    }
}

// 服务基类
abstract contract BaseService {
    ServiceRegistry public registry;
    string public serviceName;
    string public version;
    bytes32 public serviceId;
    
    modifier onlyRegisteredService() {
        require(registry.getService(serviceId).isActive, "Service not registered");
        _;
    }
    
    constructor(
        address _registry,
        string memory _serviceName,
        string memory _version
    ) {
        registry = ServiceRegistry(_registry);
        serviceName = _serviceName;
        version = _version;
    }
    
    function registerSelf() external {
        serviceId = registry.registerService(serviceName, version, address(this));
    }
    
    function callService(
        string memory targetServiceName,
        bytes memory data
    ) internal returns (bool success, bytes memory result) {
        address serviceAddress = registry.getActiveServiceAddress(targetServiceName);
        return serviceAddress.call(data);
    }
}

// 用户服务
contract UserService is BaseService {
    struct User {
        address userAddress;
        string username;
        uint256 createdAt;
        bool isActive;
        mapping(string => bytes) metadata;
    }
    
    mapping(address => User) public users;
    mapping(string => address) public usernameToAddress;
    
    event UserCreated(address indexed userAddress, string username);
    event UserUpdated(address indexed userAddress);
    
    constructor(address _registry) BaseService(_registry, "UserService", "1.0.0") {}
    
    function createUser(string memory username) external {
        require(bytes(username).length > 0, "Username cannot be empty");
        require(usernameToAddress[username] == address(0), "Username already exists");
        require(!users[msg.sender].isActive, "User already exists");
        
        users[msg.sender].userAddress = msg.sender;
        users[msg.sender].username = username;
        users[msg.sender].createdAt = block.timestamp;
        users[msg.sender].isActive = true;
        
        usernameToAddress[username] = msg.sender;
        
        emit UserCreated(msg.sender, username);
    }
    
    function updateUserMetadata(string memory key, bytes memory value) external {
        require(users[msg.sender].isActive, "User not found");
        
        users[msg.sender].metadata[key] = value;
        emit UserUpdated(msg.sender);
    }
    
    function getUserMetadata(address userAddress, string memory key) 
        external view returns (bytes memory) {
        require(users[userAddress].isActive, "User not found");
        return users[userAddress].metadata[key];
    }
    
    function isUserActive(address userAddress) external view returns (bool) {
        return users[userAddress].isActive;
    }
}

// 通知服务
contract NotificationService is BaseService {
    struct Notification {
        uint256 id;
        address recipient;
        string message;
        uint256 timestamp;
        bool isRead;
    }
    
    mapping(address => Notification[]) public userNotifications;
    mapping(address => uint256) public unreadCounts;
    
    uint256 private nextNotificationId = 1;
    
    event NotificationSent(address indexed recipient, uint256 notificationId, string message);
    event NotificationRead(address indexed recipient, uint256 notificationId);
    
    constructor(address _registry) BaseService(_registry, "NotificationService", "1.0.0") {}
    
    function sendNotification(address recipient, string memory message) external onlyRegisteredService {
        // 验证用户是否存在
        (bool success, bytes memory result) = callService(
            "UserService",
            abi.encodeWithSignature("isUserActive(address)", recipient)
        );
        
        require(success, "Failed to verify user");
        bool isActive = abi.decode(result, (bool));
        require(isActive, "Recipient not found");
        
        Notification memory notification = Notification({
            id: nextNotificationId,
            recipient: recipient,
            message: message,
            timestamp: block.timestamp,
            isRead: false
        });
        
        userNotifications[recipient].push(notification);
        unreadCounts[recipient]++;
        
        emit NotificationSent(recipient, nextNotificationId, message);
        nextNotificationId++;
    }
    
    function markAsRead(uint256 notificationId) external {
        Notification[] storage notifications = userNotifications[msg.sender];
        
        for (uint256 i = 0; i < notifications.length; i++) {
            if (notifications[i].id == notificationId && !notifications[i].isRead) {
                notifications[i].isRead = true;
                unreadCounts[msg.sender]--;
                
                emit NotificationRead(msg.sender, notificationId);
                break;
            }
        }
    }
    
    function getUnreadCount(address user) external view returns (uint256) {
        return unreadCounts[user];
    }
    
    function getNotifications(address user) external view returns (Notification[] memory) {
        return userNotifications[user];
    }
}
```

---

## 🎨 设计模式实现

### 代理模式（Proxy Pattern）

```solidity
// 可升级代理合约
contract UpgradeableProxy {
    // 存储槽位置（避免与实现合约冲突）
    bytes32 private constant IMPLEMENTATION_SLOT = keccak256("proxy.implementation");
    bytes32 private constant ADMIN_SLOT = keccak256("proxy.admin");
    
    event Upgraded(address indexed implementation);
    event AdminChanged(address previousAdmin, address newAdmin);
    
    modifier onlyAdmin() {
        require(msg.sender == _getAdmin(), "Only admin can perform this action");
        _;
    }
    
    constructor(address _implementation, address _admin) {
        _setImplementation(_implementation);
        _setAdmin(_admin);
    }
    
    // 回退函数，将调用委托给实现合约
    fallback() external payable {
        _delegate(_getImplementation());
    }
    
    receive() external payable {
        _delegate(_getImplementation());
    }
    
    // 升级实现合约
    function upgrade(address newImplementation) external onlyAdmin {
        require(newImplementation != address(0), "Invalid implementation address");
        require(newImplementation != _getImplementation(), "Same implementation");
        
        _setImplementation(newImplementation);
        emit Upgraded(newImplementation);
    }
    
    // 更改管理员
    function changeAdmin(address newAdmin) external onlyAdmin {
        require(newAdmin != address(0), "Invalid admin address");
        
        address previousAdmin = _getAdmin();
        _setAdmin(newAdmin);
        
        emit AdminChanged(previousAdmin, newAdmin);
    }
    
    // 获取当前实现合约地址
    function implementation() external view returns (address) {
        return _getImplementation();
    }
    
    // 获取当前管理员地址
    function admin() external view returns (address) {
        return _getAdmin();
    }
    
    // 委托调用
    function _delegate(address impl) internal {
        assembly {
            // 复制调用数据
            calldatacopy(0, 0, calldatasize())
            
            // 委托调用实现合约
            let result := delegatecall(gas(), impl, 0, calldatasize(), 0, 0)
            
            // 复制返回数据
            returndatacopy(0, 0, returndatasize())
            
            switch result
            case 0 {
                revert(0, returndatasize())
            }
            default {
                return(0, returndatasize())
            }
        }
    }
    
    // 获取实现合约地址
    function _getImplementation() internal view returns (address impl) {
        bytes32 slot = IMPLEMENTATION_SLOT;
        assembly {
            impl := sload(slot)
        }
    }
    
    // 设置实现合约地址
    function _setImplementation(address impl) internal {
        bytes32 slot = IMPLEMENTATION_SLOT;
        assembly {
            sstore(slot, impl)
        }
    }
    
    // 获取管理员地址
    function _getAdmin() internal view returns (address adm) {
        bytes32 slot = ADMIN_SLOT;
        assembly {
            adm := sload(slot)
        }
    }
    
    // 设置管理员地址
    function _setAdmin(address adm) internal {
        bytes32 slot = ADMIN_SLOT;
        assembly {
            sstore(slot, adm)
        }
    }
}

// 实现合约基类
abstract contract Initializable {
    bool private _initialized;
    bool private _initializing;
    
    modifier initializer() {
        require(
            _initializing || !_initialized,
            "Contract instance has already been initialized"
        );
        
        bool isTopLevelCall = !_initializing;
        if (isTopLevelCall) {
            _initializing = true;
            _initialized = true;
        }
        
        _;
        
        if (isTopLevelCall) {
            _initializing = false;
        }
    }
}

// 示例实现合约 V1
contract TokenV1 is Initializable {
    mapping(address => uint256) public balances;
    mapping(address => mapping(address => uint256)) public allowances;
    
    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public totalSupply;
    
    address public owner;
    
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    
    function initialize(
        string memory _name,
        string memory _symbol,
        uint8 _decimals,
        uint256 _totalSupply
    ) external initializer {
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
        totalSupply = _totalSupply;
        owner = msg.sender;
        
        balances[msg.sender] = _totalSupply;
        emit Transfer(address(0), msg.sender, _totalSupply);
    }
    
    function transfer(address to, uint256 amount) external returns (bool) {
        require(balances[msg.sender] >= amount, "Insufficient balance");
        
        balances[msg.sender] -= amount;
        balances[to] += amount;
        
        emit Transfer(msg.sender, to, amount);
        return true;
    }
    
    function approve(address spender, uint256 amount) external returns (bool) {
        allowances[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }
    
    function transferFrom(address from, address to, uint256 amount) external returns (bool) {
        require(balances[from] >= amount, "Insufficient balance");
        require(allowances[from][msg.sender] >= amount, "Insufficient allowance");
        
        balances[from] -= amount;
        balances[to] += amount;
        allowances[from][msg.sender] -= amount;
        
        emit Transfer(from, to, amount);
        return true;
    }
}

// 升级后的实现合约 V2
contract TokenV2 is Initializable {
    mapping(address => uint256) public balances;
    mapping(address => mapping(address => uint256)) public allowances;
    
    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public totalSupply;
    
    address public owner;
    
    // V2 新增功能
    mapping(address => bool) public blacklist;
    bool public paused;
    uint256 public maxTransferAmount;
    
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    event Blacklisted(address indexed account);
    event Unblacklisted(address indexed account);
    event Paused();
    event Unpaused();
    
    modifier onlyOwner() {
        require(msg.sender == owner, "Only owner");
        _;
    }
    
    modifier whenNotPaused() {
        require(!paused, "Contract is paused");
        _;
    }
    
    modifier notBlacklisted(address account) {
        require(!blacklist[account], "Account is blacklisted");
        _;
    }
    
    // V2 初始化函数（只能调用一次）
    function initializeV2(uint256 _maxTransferAmount) external {
        require(maxTransferAmount == 0, "Already initialized V2");
        maxTransferAmount = _maxTransferAmount;
    }
    
    function transfer(address to, uint256 amount) 
        external 
        whenNotPaused 
        notBlacklisted(msg.sender) 
        notBlacklisted(to) 
        returns (bool) 
    {
        require(amount <= maxTransferAmount, "Amount exceeds maximum");
        require(balances[msg.sender] >= amount, "Insufficient balance");
        
        balances[msg.sender] -= amount;
        balances[to] += amount;
        
        emit Transfer(msg.sender, to, amount);
        return true;
    }
    
    function approve(address spender, uint256 amount) 
        external 
        whenNotPaused 
        notBlacklisted(msg.sender) 
        returns (bool) 
    {
        allowances[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }
    
    function transferFrom(address from, address to, uint256 amount) 
        external 
        whenNotPaused 
        notBlacklisted(from) 
        notBlacklisted(to) 
        returns (bool) 
    {
        require(amount <= maxTransferAmount, "Amount exceeds maximum");
        require(balances[from] >= amount, "Insufficient balance");
        require(allowances[from][msg.sender] >= amount, "Insufficient allowance");
        
        balances[from] -= amount;
        balances[to] += amount;
        allowances[from][msg.sender] -= amount;
        
        emit Transfer(from, to, amount);
        return true;
    }
    
    // V2 新增管理功能
    function addToBlacklist(address account) external onlyOwner {
        blacklist[account] = true;
        emit Blacklisted(account);
    }
    
    function removeFromBlacklist(address account) external onlyOwner {
        blacklist[account] = false;
        emit Unblacklisted(account);
    }
    
    function pause() external onlyOwner {
        paused = true;
        emit Paused();
    }
    
    function unpause() external onlyOwner {
        paused = false;
        emit Unpaused();
    }
    
    function setMaxTransferAmount(uint256 _maxTransferAmount) external onlyOwner {
        maxTransferAmount = _maxTransferAmount;
    }
}
```

### 工厂模式（Factory Pattern）

```solidity
// 抽象产品接口
interface IToken {
    function name() external view returns (string memory);
    function symbol() external view returns (string memory);
    function decimals() external view returns (uint8);
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address to, uint256 amount) external returns (bool);
}

// 具体产品：标准代币
contract StandardToken is IToken {
    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;
    
    string private _name;
    string private _symbol;
    uint8 private _decimals;
    uint256 private _totalSupply;
    
    constructor(
        string memory name_,
        string memory symbol_,
        uint8 decimals_,
        uint256 totalSupply_
    ) {
        _name = name_;
        _symbol = symbol_;
        _decimals = decimals_;
        _totalSupply = totalSupply_;
        _balances[msg.sender] = totalSupply_;
    }
    
    function name() external view override returns (string memory) {
        return _name;
    }
    
    function symbol() external view override returns (string memory) {
        return _symbol;
    }
    
    function decimals() external view override returns (uint8) {
        return _decimals;
    }
    
    function totalSupply() external view override returns (uint256) {
        return _totalSupply;
    }
    
    function balanceOf(address account) external view override returns (uint256) {
        return _balances[account];
    }
    
    function transfer(address to, uint256 amount) external override returns (bool) {
        require(_balances[msg.sender] >= amount, "Insufficient balance");
        
        _balances[msg.sender] -= amount;
        _balances[to] += amount;
        
        return true;
    }
}

// 具体产品：可铸造代币
contract MintableToken is IToken {
    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;
    
    string private _name;
    string private _symbol;
    uint8 private _decimals;
    uint256 private _totalSupply;
    
    address public owner;
    
    modifier onlyOwner() {
        require(msg.sender == owner, "Only owner");
        _;
    }
    
    constructor(
        string memory name_,
        string memory symbol_,
        uint8 decimals_
    ) {
        _name = name_;
        _symbol = symbol_;
        _decimals = decimals_;
        owner = msg.sender;
    }
    
    function name() external view override returns (string memory) {
        return _name;
    }
    
    function symbol() external view override returns (string memory) {
        return _symbol;
    }
    
    function decimals() external view override returns (uint8) {
        return _decimals;
    }
    
    function totalSupply() external view override returns (uint256) {
        return _totalSupply;
    }
    
    function balanceOf(address account) external view override returns (uint256) {
        return _balances[account];
    }
    
    function transfer(address to, uint256 amount) external override returns (bool) {
        require(_balances[msg.sender] >= amount, "Insufficient balance");
        
        _balances[msg.sender] -= amount;
        _balances[to] += amount;
        
        return true;
    }
    
    function mint(address to, uint256 amount) external onlyOwner {
        _balances[to] += amount;
        _totalSupply += amount;
    }
    
    function burn(uint256 amount) external {
        require(_balances[msg.sender] >= amount, "Insufficient balance");
        
        _balances[msg.sender] -= amount;
        _totalSupply -= amount;
    }
}

// 具体产品：带费用的代币
contract FeeToken is IToken {
    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;
    
    string private _name;
    string private _symbol;
    uint8 private _decimals;
    uint256 private _totalSupply;
    
    address public feeCollector;
    uint256 public feeRate; // 基点 (1 = 0.01%)
    
    constructor(
        string memory name_,
        string memory symbol_,
        uint8 decimals_,
        uint256 totalSupply_,
        address feeCollector_,
        uint256 feeRate_
    ) {
        _name = name_;
        _symbol = symbol_;
        _decimals = decimals_;
        _totalSupply = totalSupply_;
        feeCollector = feeCollector_;
        feeRate = feeRate_;
        _balances[msg.sender] = totalSupply_;
    }
    
    function name() external view override returns (string memory) {
        return _name;
    }
    
    function symbol() external view override returns (string memory) {
        return _symbol;
    }
    
    function decimals() external view override returns (uint8) {
        return _decimals;
    }
    
    function totalSupply() external view override returns (uint256) {
        return _totalSupply;
    }
    
    function balanceOf(address account) external view override returns (uint256) {
        return _balances[account];
    }
    
    function transfer(address to, uint256 amount) external override returns (bool) {
        require(_balances[msg.sender] >= amount, "Insufficient balance");
        
        uint256 fee = (amount * feeRate) / 10000;
        uint256 netAmount = amount - fee;
        
        _balances[msg.sender] -= amount;
        _balances[to] += netAmount;
        _balances[feeCollector] += fee;
        
        return true;
    }
}

// 抽象工厂
abstract contract TokenFactory {
    event TokenCreated(address indexed token, address indexed creator, string tokenType);
    
    function createToken(
        string memory name,
        string memory symbol,
        uint8 decimals,
        bytes memory params
    ) external virtual returns (address);
    
    function getTokenType() external view virtual returns (string memory);
}

// 具体工厂：标准代币工厂
contract StandardTokenFactory is TokenFactory {
    function createToken(
        string memory name,
        string memory symbol,
        uint8 decimals,
        bytes memory params
    ) external override returns (address) {
        uint256 totalSupply = abi.decode(params, (uint256));
        
        StandardToken token = new StandardToken(name, symbol, decimals, totalSupply);
        
        emit TokenCreated(address(token), msg.sender, "Standard");
        return address(token);
    }
    
    function getTokenType() external pure override returns (string memory) {
        return "Standard";
    }
}

// 具体工厂：可铸造代币工厂
contract MintableTokenFactory is TokenFactory {
    function createToken(
        string memory name,
        string memory symbol,
        uint8 decimals,
        bytes memory params
    ) external override returns (address) {
        // params 为空，因为可铸造代币不需要初始供应量
        
        MintableToken token = new MintableToken(name, symbol, decimals);
        
        emit TokenCreated(address(token), msg.sender, "Mintable");
        return address(token);
    }
    
    function getTokenType() external pure override returns (string memory) {
        return "Mintable";
    }
}

// 具体工厂：带费用代币工厂
contract FeeTokenFactory is TokenFactory {
    function createToken(
        string memory name,
        string memory symbol,
        uint8 decimals,
        bytes memory params
    ) external override returns (address) {
        (uint256 totalSupply, address feeCollector, uint256 feeRate) = 
            abi.decode(params, (uint256, address, uint256));
        
        FeeToken token = new FeeToken(
            name, 
            symbol, 
            decimals, 
            totalSupply, 
            feeCollector, 
            feeRate
        );
        
        emit TokenCreated(address(token), msg.sender, "Fee");
        return address(token);
    }
    
    function getTokenType() external pure override returns (string memory) {
        return "Fee";
    }
}

// 工厂管理器
contract TokenFactoryManager {
    mapping(string => address) public factories;
    mapping(address => bool) public authorizedFactories;
    
    address public owner;
    
    event FactoryRegistered(string indexed tokenType, address indexed factory);
    event TokenCreated(address indexed token, string tokenType, address indexed creator);
    
    modifier onlyOwner() {
        require(msg.sender == owner, "Only owner");
        _;
    }
    
    constructor() {
        owner = msg.sender;
    }
    
    function registerFactory(string memory tokenType, address factory) external onlyOwner {
        require(factory != address(0), "Invalid factory address");
        require(factories[tokenType] == address(0), "Factory already registered");
        
        factories[tokenType] = factory;
        authorizedFactories[factory] = true;
        
        emit FactoryRegistered(tokenType, factory);
    }
    
    function createToken(
        string memory tokenType,
        string memory name,
        string memory symbol,
        uint8 decimals,
        bytes memory params
    ) external returns (address) {
        address factory = factories[tokenType];
        require(factory != address(0), "Factory not found");
        
        address token = TokenFactory(factory).createToken(name, symbol, decimals, params);
        
        emit TokenCreated(token, tokenType, msg.sender);
        return token;
    }
    
    function getFactory(string memory tokenType) external view returns (address) {
        return factories[tokenType];
    }
    
    function isAuthorizedFactory(address factory) external view returns (bool) {
        return authorizedFactories[factory];
    }
}
```

### 观察者模式（Observer Pattern）

```solidity
// 观察者接口
interface IObserver {
    function update(address subject, bytes memory data) external;
}

// 主题接口
interface ISubject {
    function attach(address observer) external;
    function detach(address observer) external;
    function notify(bytes memory data) external;
}

// 具体主题：价格预言机
contract PriceOracle is ISubject {
    struct PriceData {
        uint256 price;
        uint256 timestamp;
        uint256 confidence;
    }
    
    mapping(string => PriceData) public prices;
    mapping(address => bool) public observers;
    address[] public observerList;
    
    address public owner;
    
    event PriceUpdated(string indexed symbol, uint256 price, uint256 timestamp);
    event ObserverAttached(address indexed observer);
    event ObserverDetached(address indexed observer);
    
    modifier onlyOwner() {
        require(msg.sender == owner, "Only owner");
        _;
    }
    
    constructor() {
        owner = msg.sender;
    }
    
    function attach(address observer) external override onlyOwner {
        require(observer != address(0), "Invalid observer address");
        require(!observers[observer], "Observer already attached");
        
        observers[observer] = true;
        observerList.push(observer);
        
        emit ObserverAttached(observer);
    }
    
    function detach(address observer) external override onlyOwner {
        require(observers[observer], "Observer not attached");
        
        observers[observer] = false;
        
        // 从数组中移除
        for (uint256 i = 0; i < observerList.length; i++) {
            if (observerList[i] == observer) {
                observerList[i] = observerList[observerList.length - 1];
                observerList.pop();
                break;
            }
        }
        
        emit ObserverDetached(observer);
    }
    
    function notify(bytes memory data) public override {
        for (uint256 i = 0; i < observerList.length; i++) {
            try IObserver(observerList[i]).update(address(this), data) {
                // 成功通知
            } catch {
                // 忽略失败的观察者
            }
        }
    }
    
    function updatePrice(
        string memory symbol,
        uint256 price,
        uint256 confidence
    ) external onlyOwner {
        prices[symbol] = PriceData({
            price: price,
            timestamp: block.timestamp,
            confidence: confidence
        });
        
        bytes memory data = abi.encode(symbol, price, block.timestamp, confidence);
        notify(data);
        
        emit PriceUpdated(symbol, price, block.timestamp);
    }
    
    function getPrice(string memory symbol) external view returns (PriceData memory) {
        return prices[symbol];
    }
}

// 具体观察者：交易策略
contract TradingStrategy is IObserver {
    struct Position {
        string symbol;
        uint256 amount;
        uint256 entryPrice;
        uint256 timestamp;
        bool isLong;
    }
    
    mapping(address => Position[]) public userPositions;
    mapping(string => uint256) public thresholds;
    
    address public oracle;
    address public owner;
    
    event PositionOpened(address indexed user, string symbol, uint256 amount, bool isLong);
    event PositionClosed(address indexed user, string symbol, uint256 amount);
    event ThresholdTriggered(string symbol, uint256 price, uint256 threshold);
    
    modifier onlyOwner() {
        require(msg.sender == owner, "Only owner");
        _;
    }
    
    modifier onlyOracle() {
        require(msg.sender == oracle, "Only oracle can call");
        _;
    }
    
    constructor(address _oracle) {
        oracle = _oracle;
        owner = msg.sender;
    }
    
    function update(address subject, bytes memory data) external override onlyOracle {
        require(subject == oracle, "Invalid subject");
        
        (string memory symbol, uint256 price, uint256 timestamp, uint256 confidence) = 
            abi.decode(data, (string, uint256, uint256, uint256));
        
        // 检查阈值触发
        if (thresholds[symbol] > 0 && price >= thresholds[symbol]) {
            emit ThresholdTriggered(symbol, price, thresholds[symbol]);
            _executeThresholdStrategy(symbol, price);
        }
        
        // 检查止损/止盈
        _checkStopLoss(symbol, price);
    }
    
    function setThreshold(string memory symbol, uint256 threshold) external onlyOwner {
        thresholds[symbol] = threshold;
    }
    
    function openPosition(
        string memory symbol,
        uint256 amount,
        bool isLong
    ) external {
        // 获取当前价格
        (uint256 currentPrice,,,) = abi.decode(
            abi.encode(PriceOracle(oracle).getPrice(symbol)),
            (uint256, uint256, uint256, uint256)
        );
        
        Position memory newPosition = Position({
            symbol: symbol,
            amount: amount,
            entryPrice: currentPrice,
            timestamp: block.timestamp,
            isLong: isLong
        });
        
        userPositions[msg.sender].push(newPosition);
        
        emit PositionOpened(msg.sender, symbol, amount, isLong);
    }
    
    function _executeThresholdStrategy(string memory symbol, uint256 price) internal {
        // 实现阈值触发策略
        // 这里可以自动开仓或平仓
    }
    
    function _checkStopLoss(string memory symbol, uint256 currentPrice) internal {
        // 检查所有用户的止损条件
        // 实现止损逻辑
    }
    
    function getUserPositions(address user) external view returns (Position[] memory) {
        return userPositions[user];
    }
}

// 具体观察者：风险管理
contract RiskManager is IObserver {
    struct RiskMetrics {
        uint256 volatility;
        uint256 maxDrawdown;
        uint256 sharpeRatio;
        uint256 lastUpdate;
    }
    
    mapping(string => RiskMetrics) public riskMetrics;
    mapping(string => uint256[]) public priceHistory;
    
    address public oracle;
    address public owner;
    
    uint256 public constant MAX_HISTORY_LENGTH = 100;
    uint256 public constant VOLATILITY_THRESHOLD = 5000; // 50%
    
    event RiskAlert(string symbol, string riskType, uint256 value);
    event RiskMetricsUpdated(string symbol, uint256 volatility, uint256 maxDrawdown);
    
    modifier onlyOwner() {
        require(msg.sender == owner, "Only owner");
        _;
    }
    
    modifier onlyOracle() {
        require(msg.sender == oracle, "Only oracle can call");
        _;
    }
    
    constructor(address _oracle) {
        oracle = _oracle;
        owner = msg.sender;
    }
    
    function update(address subject, bytes memory data) external override onlyOracle {
        require(subject == oracle, "Invalid subject");
        
        (string memory symbol, uint256 price, uint256 timestamp, uint256 confidence) = 
            abi.decode(data, (string, uint256, uint256, uint256));
        
        // 更新价格历史
        _updatePriceHistory(symbol, price);
        
        // 计算风险指标
        _calculateRiskMetrics(symbol);
        
        // 检查风险阈值
        _checkRiskThresholds(symbol);
    }
    
    function _updatePriceHistory(string memory symbol, uint256 price) internal {
        uint256[] storage history = priceHistory[symbol];
        
        history.push(price);
        
        // 保持历史长度限制
        if (history.length > MAX_HISTORY_LENGTH) {
            // 移除最旧的价格
            for (uint256 i = 0; i < history.length - 1; i++) {
                history[i] = history[i + 1];
            }
            history.pop();
        }
    }
    
    function _calculateRiskMetrics(string memory symbol) internal {
        uint256[] storage history = priceHistory[symbol];
        
        if (history.length < 2) return;
        
        // 计算波动率（简化版）
        uint256 volatility = _calculateVolatility(history);
        
        // 计算最大回撤
        uint256 maxDrawdown = _calculateMaxDrawdown(history);
        
        riskMetrics[symbol] = RiskMetrics({
            volatility: volatility,
            maxDrawdown: maxDrawdown,
            sharpeRatio: 0, // 简化，实际需要更复杂计算
            lastUpdate: block.timestamp
        });
        
        emit RiskMetricsUpdated(symbol, volatility, maxDrawdown);
    }
    
    function _calculateVolatility(uint256[] storage prices) internal view returns (uint256) {
        if (prices.length < 2) return 0;
        
        // 计算收益率的标准差（简化版）
        uint256 sum = 0;
        uint256 sumSquares = 0;
        uint256 count = prices.length - 1;
        
        for (uint256 i = 1; i < prices.length; i++) {
            uint256 return_ = (prices[i] * 10000) / prices[i - 1]; // 基点表示
            sum += return_;
            sumSquares += return_ * return_;
        }
        
        uint256 mean = sum / count;
        uint256 variance = (sumSquares / count) - (mean * mean);
        
        return _sqrt(variance);
    }
    
    function _calculateMaxDrawdown(uint256[] storage prices) internal view returns (uint256) {
        if (prices.length < 2) return 0;
        
        uint256 peak = prices[0];
        uint256 maxDrawdown = 0;
        
        for (uint256 i = 1; i < prices.length; i++) {
            if (prices[i] > peak) {
                peak = prices[i];
            } else {
                uint256 drawdown = ((peak - prices[i]) * 10000) / peak; // 基点表示
                if (drawdown > maxDrawdown) {
                    maxDrawdown = drawdown;
                }
            }
        }
        
        return maxDrawdown;
    }
    
    function _checkRiskThresholds(string memory symbol) internal {
        RiskMetrics storage metrics = riskMetrics[symbol];
        
        if (metrics.volatility > VOLATILITY_THRESHOLD) {
            emit RiskAlert(symbol, "HIGH_VOLATILITY", metrics.volatility);
        }
        
        if (metrics.maxDrawdown > 2000) { // 20%
            emit RiskAlert(symbol, "HIGH_DRAWDOWN", metrics.maxDrawdown);
        }
    }
    
    function _sqrt(uint256 x) internal pure returns (uint256) {
        if (x == 0) return 0;
        uint256 z = (x + 1) / 2;
        uint256 y = x;
        while (z < y) {
            y = z;
            z = (x / z + z) / 2;
        }
        return y;
    }
    
    function getRiskMetrics(string memory symbol) external view returns (RiskMetrics memory) {
        return riskMetrics[symbol];
    }
    
    function getPriceHistory(string memory symbol) external view returns (uint256[] memory) {
        return priceHistory[symbol];
    }
}
```

---

## 🔧 模块化设计实践

### 库合约设计

```solidity
// 数学运算库
library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");
        return c;
    }
    
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, "SafeMath: subtraction overflow");
        return a - b;
    }
    
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) return 0;
        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");
        return c;
    }
    
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0, "SafeMath: division by zero");
        return a / b;
    }
    
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0, "SafeMath: modulo by zero");
        return a % b;
    }
}

// 地址工具库
library Address {
    function isContract(address account) internal view returns (bool) {
        uint256 size;
        assembly {
            size := extcodesize(account)
        }
        return size > 0;
    }
    
    function sendValue(address payable recipient, uint256 amount) internal {
        require(address(this).balance >= amount, "Address: insufficient balance");
        
        (bool success, ) = recipient.call{value: amount}("");
        require(success, "Address: unable to send value, recipient may have reverted");
    }
    
    function functionCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionCall(target, data, "Address: low-level call failed");
    }
    
    function functionCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal returns (bytes memory) {
        return functionCallWithValue(target, data, 0, errorMessage);
    }
    
    function functionCallWithValue(
        address target,
        bytes memory data,
        uint256 value,
        string memory errorMessage
    ) internal returns (bytes memory) {
        require(address(this).balance >= value, "Address: insufficient balance for call");
        require(isContract(target), "Address: call to non-contract");
        
        (bool success, bytes memory returndata) = target.call{value: value}(data);
        return _verifyCallResult(success, returndata, errorMessage);
    }
    
    function _verifyCallResult(
        bool success,
        bytes memory returndata,
        string memory errorMessage
    ) private pure returns (bytes memory) {
        if (success) {
            return returndata;
        } else {
            if (returndata.length > 0) {
                assembly {
                    let returndata_size := mload(returndata)
                    revert(add(32, returndata), returndata_size)
                }
            } else {
                revert(errorMessage);
            }
        }
    }
}

// 字符串工具库
library Strings {
    bytes16 private constant _HEX_SYMBOLS = "0123456789abcdef";
    
    function toString(uint256 value) internal pure returns (string memory) {
        if (value == 0) {
            return "0";
        }
        uint256 temp = value;
        uint256 digits;
        while (temp != 0) {
            digits++;
            temp /= 10;
        }
        bytes memory buffer = new bytes(digits);
        while (value != 0) {
            digits -= 1;
            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));
            value /= 10;
        }
        return string(buffer);
    }
    
    function toHexString(uint256 value) internal pure returns (string memory) {
        if (value == 0) {
            return "0x00";
        }
        uint256 temp = value;
        uint256 length = 0;
        while (temp != 0) {
            length++;
            temp >>= 8;
        }
        return toHexString(value, length);
    }
    
    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {
        bytes memory buffer = new bytes(2 * length + 2);
        buffer[0] = "0";
        buffer[1] = "x";
        for (uint256 i = 2 * length + 1; i > 1; --i) {
            buffer[i] = _HEX_SYMBOLS[value & 0xf];
            value >>= 4;
        }
        require(value == 0, "Strings: hex length insufficient");
        return string(buffer);
    }
}

// 加密工具库
library Cryptography {
    function hash(bytes memory data) internal pure returns (bytes32) {
        return keccak256(data);
    }
    
    function hashPair(bytes32 a, bytes32 b) internal pure returns (bytes32) {
        return a < b ? keccak256(abi.encodePacked(a, b)) : keccak256(abi.encodePacked(b, a));
    }
    
    function verify(
        bytes32 hash,
        bytes32 r,
        bytes32 s,
        uint8 v
    ) internal pure returns (address) {
        require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, "Invalid signature 's' value");
        require(v == 27 || v == 28, "Invalid signature 'v' value");
        
        address signer = ecrecover(hash, v, r, s);
        require(signer != address(0), "Invalid signature");
        
        return signer;
    }
    
    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", hash));
    }
    
    function generateMerkleRoot(bytes32[] memory leaves) internal pure returns (bytes32) {
        require(leaves.length > 0, "Empty leaves array");
        
        if (leaves.length == 1) {
            return leaves[0];
        }
        
        bytes32[] memory currentLevel = leaves;
        
        while (currentLevel.length > 1) {
            bytes32[] memory nextLevel = new bytes32[]((currentLevel.length + 1) / 2);
            
            for (uint256 i = 0; i < currentLevel.length; i += 2) {
                if (i + 1 < currentLevel.length) {
                    nextLevel[i / 2] = hashPair(currentLevel[i], currentLevel[i + 1]);
                } else {
                    nextLevel[i / 2] = currentLevel[i];
                }
            }
            
            currentLevel = nextLevel;
        }
        
        return currentLevel[0];
    }
    
    function verifyMerkleProof(
        bytes32[] memory proof,
        bytes32 root,
        bytes32 leaf
    ) internal pure returns (bool) {
        bytes32 computedHash = leaf;
        
        for (uint256 i = 0; i < proof.length; i++) {
            computedHash = hashPair(computedHash, proof[i]);
        }
        
        return computedHash == root;
    }
}
```

### 插件架构系统

```solidity
// 插件接口
interface IPlugin {
    function getName() external view returns (string memory);
    function getVersion() external view returns (string memory);
    function initialize(bytes memory params) external;
    function execute(bytes memory input) external returns (bytes memory);
    function isActive() external view returns (bool);
}

// 插件管理器
contract PluginManager {
    struct Plugin {
        address pluginAddress;
        string name;
        string version;
        bool isActive;
        bool isInstalled;
        uint256 installedAt;
        mapping(string => bytes) metadata;
    }
    
    mapping(bytes32 => Plugin) public plugins;
    mapping(string => bytes32) public pluginsByName;
    bytes32[] public installedPlugins;
    
    address public owner;
    bool public paused;
    
    event PluginInstalled(bytes32 indexed pluginId, string name, address pluginAddress);
    event PluginUninstalled(bytes32 indexed pluginId, string name);
    event PluginActivated(bytes32 indexed pluginId);
    event PluginDeactivated(bytes32 indexed pluginId);
    
    modifier onlyOwner() {
        require(msg.sender == owner, "Only owner");
        _;
    }
    
    modifier whenNotPaused() {
        require(!paused, "System is paused");
        _;
    }
    
    constructor() {
        owner = msg.sender;
    }
    
    function installPlugin(
        address pluginAddress,
        bytes memory initParams
    ) external onlyOwner whenNotPaused returns (bytes32) {
        require(pluginAddress != address(0), "Invalid plugin address");
        require(Address.isContract(pluginAddress), "Not a contract");
        
        IPlugin plugin = IPlugin(pluginAddress);
        string memory name = plugin.getName();
        string memory version = plugin.getVersion();
        
        bytes32 pluginId = keccak256(abi.encodePacked(name, version, block.timestamp));
        require(!plugins[pluginId].isInstalled, "Plugin already installed");
        
        // 初始化插件
        plugin.initialize(initParams);
        
        plugins[pluginId].pluginAddress = pluginAddress;
        plugins[pluginId].name = name;
        plugins[pluginId].version = version;
        plugins[pluginId].isActive = true;
        plugins[pluginId].isInstalled = true;
        plugins[pluginId].installedAt = block.timestamp;
        
        pluginsByName[name] = pluginId;
        installedPlugins.push(pluginId);
        
        emit PluginInstalled(pluginId, name, pluginAddress);
        return pluginId;
    }
    
    function uninstallPlugin(bytes32 pluginId) external onlyOwner {
        require(plugins[pluginId].isInstalled, "Plugin not installed");
        
        plugins[pluginId].isInstalled = false;
        plugins[pluginId].isActive = false;
        
        // 从数组中移除
        for (uint256 i = 0; i < installedPlugins.length; i++) {
            if (installedPlugins[i] == pluginId) {
                installedPlugins[i] = installedPlugins[installedPlugins.length - 1];
                installedPlugins.pop();
                break;
            }
        }
        
        emit PluginUninstalled(pluginId, plugins[pluginId].name);
    }
    
    function activatePlugin(bytes32 pluginId) external onlyOwner {
        require(plugins[pluginId].isInstalled, "Plugin not installed");
        require(!plugins[pluginId].isActive, "Plugin already active");
        
        plugins[pluginId].isActive = true;
        emit PluginActivated(pluginId);
    }
    
    function deactivatePlugin(bytes32 pluginId) external onlyOwner {
        require(plugins[pluginId].isInstalled, "Plugin not installed");
        require(plugins[pluginId].isActive, "Plugin already inactive");
        
        plugins[pluginId].isActive = false;
        emit PluginDeactivated(pluginId);
    }
    
    function executePlugin(
        string memory pluginName,
        bytes memory input
    ) external whenNotPaused returns (bytes memory) {
        bytes32 pluginId = pluginsByName[pluginName];
        require(plugins[pluginId].isInstalled, "Plugin not installed");
        require(plugins[pluginId].isActive, "Plugin not active");
        
        IPlugin plugin = IPlugin(plugins[pluginId].pluginAddress);
        return plugin.execute(input);
    }
    
    function getInstalledPlugins() external view returns (bytes32[] memory) {
        return installedPlugins;
    }
    
    function getPluginInfo(bytes32 pluginId) external view returns (
        address pluginAddress,
        string memory name,
        string memory version,
        bool isActive,
        bool isInstalled,
        uint256 installedAt
    ) {
        Plugin storage plugin = plugins[pluginId];
        return (
            plugin.pluginAddress,
            plugin.name,
            plugin.version,
            plugin.isActive,
            plugin.isInstalled,
            plugin.installedAt
        );
    }
}

// 示例插件：数据验证插件
contract DataValidationPlugin is IPlugin {
    string private constant NAME = "DataValidation";
    string private constant VERSION = "1.0.0";
    
    bool private _isActive;
    address private _manager;
    
    struct ValidationRule {
        string fieldName;
        string ruleType; // "required", "minLength", "maxLength", "pattern"
        bytes ruleValue;
    }
    
    mapping(string => ValidationRule[]) public validationRules;
    
    modifier onlyManager() {
        require(msg.sender == _manager, "Only manager can call");
        _;
    }
    
    function getName() external pure override returns (string memory) {
        return NAME;
    }
    
    function getVersion() external pure override returns (string memory) {
        return VERSION;
    }
    
    function initialize(bytes memory params) external override {
        require(_manager == address(0), "Already initialized");
        
        _manager = msg.sender;
        _isActive = true;
        
        // 解析初始化参数
        if (params.length > 0) {
            // 可以设置默认验证规则
        }
    }
    
    function execute(bytes memory input) external override onlyManager returns (bytes memory) {
        require(_isActive, "Plugin not active");
        
        (string memory schema, bytes memory data) = abi.decode(input, (string, bytes));
        
        bool isValid = _validateData(schema, data);
        return abi.encode(isValid);
    }
    
    function isActive() external view override returns (bool) {
        return _isActive;
    }
    
    function addValidationRule(
        string memory schema,
        string memory fieldName,
        string memory ruleType,
        bytes memory ruleValue
    ) external onlyManager {
        validationRules[schema].push(ValidationRule({
            fieldName: fieldName,
            ruleType: ruleType,
            ruleValue: ruleValue
        }));
    }
    
    function _validateData(string memory schema, bytes memory data) internal view returns (bool) {
        ValidationRule[] storage rules = validationRules[schema];
        
        for (uint256 i = 0; i < rules.length; i++) {
            ValidationRule storage rule = rules[i];
            
            if (!_validateField(data, rule)) {
                return false;
            }
        }
        
        return true;
    }
    
    function _validateField(bytes memory data, ValidationRule storage rule) internal pure returns (bool) {
        // 简化的验证逻辑
        if (keccak256(bytes(rule.ruleType)) == keccak256(bytes("required"))) {
            return data.length > 0;
        }
        
        if (keccak256(bytes(rule.ruleType)) == keccak256(bytes("minLength"))) {
            uint256 minLength = abi.decode(rule.ruleValue, (uint256));
            return data.length >= minLength;
        }
        
        if (keccak256(bytes(rule.ruleType)) == keccak256(bytes("maxLength"))) {
            uint256 maxLength = abi.decode(rule.ruleValue, (uint256));
            return data.length <= maxLength;
        }
        
        return true;
    }
}
```

---

## 📚 学习心得与总结

### 系统架构设计要点

1. **分层架构的优势**
   - 职责分离：每层专注于特定功能
   - 可维护性：修改某层不影响其他层
   - 可测试性：每层可独立测试
   - 可扩展性：易于添加新功能

2. **微服务架构的实践**
   - 服务独立：每个服务可独立部署和升级
   - 松耦合：服务间通过接口通信
   - 容错性：单个服务故障不影响整体系统
   - 可伸缩性：可根据需求扩展特定服务

### 设计模式应用心得

1. **代理模式的价值**
   - 合约升级：解决区块链不可变性问题
   - 访问控制：统一管理权限验证
   - 性能优化：延迟加载和缓存机制
   - 安全增强：隔离核心逻辑和外部调用

2. **工厂模式的实用性**
   - 对象创建：统一管理复杂对象的创建过程
   - 类型安全：编译时确保对象类型正确
   - 扩展性：易于添加新的产品类型
   - 配置管理：集中管理创建参数

3. **观察者模式的应用场景**
   - 事件驱动：实现松耦合的事件处理
   - 实时更新：自动同步状态变化
   - 扩展性：易于添加新的观察者
   - 解耦合：主题和观察者独立变化

### 模块化设计实践

1. **库合约的设计原则**
   - 纯函数：无状态，可重用
   - 安全性：防止溢出和异常
   - 效率性：优化Gas消耗
   - 通用性：适用于多种场景

2. **插件架构的优势**
   - 功能扩展：动态添加新功能
   - 版本管理：支持插件版本控制
   - 隔离性：插件故障不影响核心系统
   - 灵活性：可根据需求启用/禁用功能

### 实践建议

1. **架构设计阶段**
   - 明确系统边界和职责划分
   - 选择合适的架构模式
   - 考虑未来扩展需求
   - 设计清晰的接口规范

2. **开发实施阶段**
   - 遵循SOLID原则
   - 编写完整的单元测试
   - 使用设计模式解决常见问题
   - 保持代码的可读性和可维护性

3. **部署运维阶段**
   - 实施渐进式部署策略
   - 建立完善的监控体系
   - 准备应急响应方案
   - 定期进行安全审计

### 未来发展方向

1. **技术趋势**
   - Layer 2解决方案的架构设计
   - 跨链互操作性架构
   - 去中心化身份系统架构
   - 可持续发展的经济模型设计

2. **学习计划**
   - 深入研究企业级架构模式
   - 学习分布式系统设计原理
   - 掌握性能优化和安全加固技术
   - 关注新兴技术和最佳实践

通过系统性的架构设计和模式应用，我们可以构建出更加健壮、可维护和可扩展的智能合约系统。这不仅提高了开发效率，也为项目的长期成功奠定了坚实基础。