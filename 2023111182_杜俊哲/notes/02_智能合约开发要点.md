# æ™ºèƒ½åˆçº¦å¼€å‘è¦ç‚¹

> **å­¦ä¹ è€…**: æœä¿Šå“²  
> **å­¦ä¹ ç‰¹è‰²**: æ³¨é‡ç³»ç»Ÿæ¶æ„å’Œè®¾è®¡æ¨¡å¼  
> **ä»£ç é£æ ¼**: æ¨¡å—åŒ–æ¶æ„ï¼Œè®¾è®¡æ¨¡å¼åº”ç”¨  
> **ç¬”è®°é‡ç‚¹**: ä»£ç†æ¨¡å¼ã€å·¥å‚æ¨¡å¼ã€æ¨¡å—åŒ–è®¾è®¡  
> **åˆ›å»ºæ—¶é—´**: 2024å¹´

---

## ğŸ—ï¸ ç³»ç»Ÿæ¶æ„è®¾è®¡

### åˆ†å±‚æ¶æ„æ¨¡å¼

åœ¨æ™ºèƒ½åˆçº¦å¼€å‘ä¸­ï¼Œé‡‡ç”¨åˆ†å±‚æ¶æ„å¯ä»¥æé«˜ä»£ç çš„å¯ç»´æŠ¤æ€§å’Œå¯æ‰©å±•æ€§ã€‚

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

// æ•°æ®è®¿é—®å±‚æ¥å£
interface IDataAccessLayer {
    function getData(bytes32 key) external view returns (bytes memory);
    function setData(bytes32 key, bytes memory data) external;
    function deleteData(bytes32 key) external;
}

// ä¸šåŠ¡é€»è¾‘å±‚æ¥å£
interface IBusinessLogicLayer {
    function processTransaction(address user, uint256 amount, bytes memory data) external returns (bool);
    function validateInput(bytes memory input) external pure returns (bool);
    function calculateFee(uint256 amount) external view returns (uint256);
}

// è¡¨ç°å±‚æ¥å£
interface IPresentationLayer {
    function executeUserAction(string memory action, bytes memory params) external payable;
    function getUserInfo(address user) external view returns (bytes memory);
}

// æ•°æ®è®¿é—®å±‚å®ç°
contract DataAccessLayer is IDataAccessLayer {
    mapping(bytes32 => bytes) private dataStore;
    mapping(address => bool) public authorizedCallers;
    
    modifier onlyAuthorized() {
        require(authorizedCallers[msg.sender], "Unauthorized access");
        _;
    }
    
    constructor() {
        authorizedCallers[msg.sender] = true;
    }
    
    function addAuthorizedCaller(address caller) external onlyAuthorized {
        authorizedCallers[caller] = true;
    }
    
    function getData(bytes32 key) external view override returns (bytes memory) {
        return dataStore[key];
    }
    
    function setData(bytes32 key, bytes memory data) external override onlyAuthorized {
        dataStore[key] = data;
    }
    
    function deleteData(bytes32 key) external override onlyAuthorized {
        delete dataStore[key];
    }
}

// ä¸šåŠ¡é€»è¾‘å±‚å®ç°
contract BusinessLogicLayer is IBusinessLogicLayer {
    IDataAccessLayer public dataLayer;
    
    uint256 public constant FEE_RATE = 100; // 1%
    uint256 public constant MAX_TRANSACTION_AMOUNT = 1000000 * 1e18;
    
    event TransactionProcessed(address indexed user, uint256 amount, bool success);
    
    constructor(address _dataLayer) {
        dataLayer = IDataAccessLayer(_dataLayer);
    }
    
    function processTransaction(
        address user, 
        uint256 amount, 
        bytes memory data
    ) external override returns (bool) {
        // éªŒè¯è¾“å…¥
        require(validateInput(data), "Invalid input data");
        require(amount <= MAX_TRANSACTION_AMOUNT, "Amount exceeds limit");
        
        // è®¡ç®—è´¹ç”¨
        uint256 fee = calculateFee(amount);
        uint256 netAmount = amount - fee;
        
        // å­˜å‚¨äº¤æ˜“æ•°æ®
        bytes32 txKey = keccak256(abi.encodePacked(user, block.timestamp, amount));
        bytes memory txData = abi.encode(user, netAmount, fee, block.timestamp);
        dataLayer.setData(txKey, txData);
        
        emit TransactionProcessed(user, amount, true);
        return true;
    }
    
    function validateInput(bytes memory input) public pure override returns (bool) {
        if (input.length == 0) return false;
        if (input.length > 1024) return false; // é™åˆ¶è¾“å…¥å¤§å°
        
        // å¯ä»¥æ·»åŠ æ›´å¤šéªŒè¯é€»è¾‘
        return true;
    }
    
    function calculateFee(uint256 amount) public view override returns (uint256) {
        return (amount * FEE_RATE) / 10000;
    }
}

// è¡¨ç°å±‚å®ç°
contract PresentationLayer is IPresentationLayer {
    IBusinessLogicLayer public businessLayer;
    
    mapping(string => bool) public supportedActions;
    
    event ActionExecuted(address indexed user, string action, bool success);
    
    constructor(address _businessLayer) {
        businessLayer = IBusinessLogicLayer(_businessLayer);
        
        // åˆå§‹åŒ–æ”¯æŒçš„æ“ä½œ
        supportedActions["deposit"] = true;
        supportedActions["withdraw"] = true;
        supportedActions["transfer"] = true;
    }
    
    function executeUserAction(
        string memory action, 
        bytes memory params
    ) external payable override {
        require(supportedActions[action], "Unsupported action");
        
        bool success = false;
        
        if (keccak256(bytes(action)) == keccak256(bytes("deposit"))) {
            success = _handleDeposit(params);
        } else if (keccak256(bytes(action)) == keccak256(bytes("withdraw"))) {
            success = _handleWithdraw(params);
        } else if (keccak256(bytes(action)) == keccak256(bytes("transfer"))) {
            success = _handleTransfer(params);
        }
        
        emit ActionExecuted(msg.sender, action, success);
    }
    
    function getUserInfo(address user) external view override returns (bytes memory) {
        // ä»ä¸šåŠ¡å±‚è·å–ç”¨æˆ·ä¿¡æ¯
        bytes32 userKey = keccak256(abi.encodePacked("user", user));
        // è¿™é‡Œéœ€è¦é€šè¿‡æ•°æ®å±‚è·å–ä¿¡æ¯ï¼Œç®€åŒ–å¤„ç†
        return abi.encode(user, block.timestamp);
    }
    
    function _handleDeposit(bytes memory params) internal returns (bool) {
        (uint256 amount) = abi.decode(params, (uint256));
        require(msg.value == amount, "Value mismatch");
        
        return businessLayer.processTransaction(msg.sender, amount, params);
    }
    
    function _handleWithdraw(bytes memory params) internal returns (bool) {
        (uint256 amount) = abi.decode(params, (uint256));
        
        return businessLayer.processTransaction(msg.sender, amount, params);
    }
    
    function _handleTransfer(bytes memory params) internal returns (bool) {
        (address to, uint256 amount) = abi.decode(params, (address, uint256));
        bytes memory transferData = abi.encode(msg.sender, to, amount);
        
        return businessLayer.processTransaction(msg.sender, amount, transferData);
    }
}
```

### å¾®æœåŠ¡æ¶æ„æ¨¡å¼

```solidity
// æœåŠ¡æ³¨å†Œä¸­å¿ƒ
contract ServiceRegistry {
    struct Service {
        address serviceAddress;
        string serviceName;
        string version;
        bool isActive;
        uint256 registeredAt;
    }
    
    mapping(bytes32 => Service) public services;
    mapping(string => bytes32[]) public servicesByName;
    
    address public owner;
    
    event ServiceRegistered(bytes32 indexed serviceId, string serviceName, address serviceAddress);
    event ServiceDeregistered(bytes32 indexed serviceId);
    event ServiceUpdated(bytes32 indexed serviceId, address newAddress);
    
    modifier onlyOwner() {
        require(msg.sender == owner, "Only owner can perform this action");
        _;
    }
    
    constructor() {
        owner = msg.sender;
    }
    
    function registerService(
        string memory serviceName,
        string memory version,
        address serviceAddress
    ) external onlyOwner returns (bytes32) {
        bytes32 serviceId = keccak256(abi.encodePacked(serviceName, version, block.timestamp));
        
        services[serviceId] = Service({
            serviceAddress: serviceAddress,
            serviceName: serviceName,
            version: version,
            isActive: true,
            registeredAt: block.timestamp
        });
        
        servicesByName[serviceName].push(serviceId);
        
        emit ServiceRegistered(serviceId, serviceName, serviceAddress);
        return serviceId;
    }
    
    function deregisterService(bytes32 serviceId) external onlyOwner {
        require(services[serviceId].isActive, "Service not active");
        
        services[serviceId].isActive = false;
        emit ServiceDeregistered(serviceId);
    }
    
    function updateService(bytes32 serviceId, address newAddress) external onlyOwner {
        require(services[serviceId].isActive, "Service not active");
        
        services[serviceId].serviceAddress = newAddress;
        emit ServiceUpdated(serviceId, newAddress);
    }
    
    function getService(bytes32 serviceId) external view returns (Service memory) {
        return services[serviceId];
    }
    
    function getServicesByName(string memory serviceName) external view returns (bytes32[] memory) {
        return servicesByName[serviceName];
    }
    
    function getActiveServiceAddress(string memory serviceName) external view returns (address) {
        bytes32[] memory serviceIds = servicesByName[serviceName];
        
        for (uint256 i = serviceIds.length; i > 0; i--) {
            bytes32 serviceId = serviceIds[i - 1];
            if (services[serviceId].isActive) {
                return services[serviceId].serviceAddress;
            }
        }
        
        revert("No active service found");
    }
}

// æœåŠ¡åŸºç±»
abstract contract BaseService {
    ServiceRegistry public registry;
    string public serviceName;
    string public version;
    bytes32 public serviceId;
    
    modifier onlyRegisteredService() {
        require(registry.getService(serviceId).isActive, "Service not registered");
        _;
    }
    
    constructor(
        address _registry,
        string memory _serviceName,
        string memory _version
    ) {
        registry = ServiceRegistry(_registry);
        serviceName = _serviceName;
        version = _version;
    }
    
    function registerSelf() external {
        serviceId = registry.registerService(serviceName, version, address(this));
    }
    
    function callService(
        string memory targetServiceName,
        bytes memory data
    ) internal returns (bool success, bytes memory result) {
        address serviceAddress = registry.getActiveServiceAddress(targetServiceName);
        return serviceAddress.call(data);
    }
}

// ç”¨æˆ·æœåŠ¡
contract UserService is BaseService {
    struct User {
        address userAddress;
        string username;
        uint256 createdAt;
        bool isActive;
        mapping(string => bytes) metadata;
    }
    
    mapping(address => User) public users;
    mapping(string => address) public usernameToAddress;
    
    event UserCreated(address indexed userAddress, string username);
    event UserUpdated(address indexed userAddress);
    
    constructor(address _registry) BaseService(_registry, "UserService", "1.0.0") {}
    
    function createUser(string memory username) external {
        require(bytes(username).length > 0, "Username cannot be empty");
        require(usernameToAddress[username] == address(0), "Username already exists");
        require(!users[msg.sender].isActive, "User already exists");
        
        users[msg.sender].userAddress = msg.sender;
        users[msg.sender].username = username;
        users[msg.sender].createdAt = block.timestamp;
        users[msg.sender].isActive = true;
        
        usernameToAddress[username] = msg.sender;
        
        emit UserCreated(msg.sender, username);
    }
    
    function updateUserMetadata(string memory key, bytes memory value) external {
        require(users[msg.sender].isActive, "User not found");
        
        users[msg.sender].metadata[key] = value;
        emit UserUpdated(msg.sender);
    }
    
    function getUserMetadata(address userAddress, string memory key) 
        external view returns (bytes memory) {
        require(users[userAddress].isActive, "User not found");
        return users[userAddress].metadata[key];
    }
    
    function isUserActive(address userAddress) external view returns (bool) {
        return users[userAddress].isActive;
    }
}

// é€šçŸ¥æœåŠ¡
contract NotificationService is BaseService {
    struct Notification {
        uint256 id;
        address recipient;
        string message;
        uint256 timestamp;
        bool isRead;
    }
    
    mapping(address => Notification[]) public userNotifications;
    mapping(address => uint256) public unreadCounts;
    
    uint256 private nextNotificationId = 1;
    
    event NotificationSent(address indexed recipient, uint256 notificationId, string message);
    event NotificationRead(address indexed recipient, uint256 notificationId);
    
    constructor(address _registry) BaseService(_registry, "NotificationService", "1.0.0") {}
    
    function sendNotification(address recipient, string memory message) external onlyRegisteredService {
        // éªŒè¯ç”¨æˆ·æ˜¯å¦å­˜åœ¨
        (bool success, bytes memory result) = callService(
            "UserService",
            abi.encodeWithSignature("isUserActive(address)", recipient)
        );
        
        require(success, "Failed to verify user");
        bool isActive = abi.decode(result, (bool));
        require(isActive, "Recipient not found");
        
        Notification memory notification = Notification({
            id: nextNotificationId,
            recipient: recipient,
            message: message,
            timestamp: block.timestamp,
            isRead: false
        });
        
        userNotifications[recipient].push(notification);
        unreadCounts[recipient]++;
        
        emit NotificationSent(recipient, nextNotificationId, message);
        nextNotificationId++;
    }
    
    function markAsRead(uint256 notificationId) external {
        Notification[] storage notifications = userNotifications[msg.sender];
        
        for (uint256 i = 0; i < notifications.length; i++) {
            if (notifications[i].id == notificationId && !notifications[i].isRead) {
                notifications[i].isRead = true;
                unreadCounts[msg.sender]--;
                
                emit NotificationRead(msg.sender, notificationId);
                break;
            }
        }
    }
    
    function getUnreadCount(address user) external view returns (uint256) {
        return unreadCounts[user];
    }
    
    function getNotifications(address user) external view returns (Notification[] memory) {
        return userNotifications[user];
    }
}
```

---

## ğŸ¨ è®¾è®¡æ¨¡å¼å®ç°

### ä»£ç†æ¨¡å¼ï¼ˆProxy Patternï¼‰

```solidity
// å¯å‡çº§ä»£ç†åˆçº¦
contract UpgradeableProxy {
    // å­˜å‚¨æ§½ä½ç½®ï¼ˆé¿å…ä¸å®ç°åˆçº¦å†²çªï¼‰
    bytes32 private constant IMPLEMENTATION_SLOT = keccak256("proxy.implementation");
    bytes32 private constant ADMIN_SLOT = keccak256("proxy.admin");
    
    event Upgraded(address indexed implementation);
    event AdminChanged(address previousAdmin, address newAdmin);
    
    modifier onlyAdmin() {
        require(msg.sender == _getAdmin(), "Only admin can perform this action");
        _;
    }
    
    constructor(address _implementation, address _admin) {
        _setImplementation(_implementation);
        _setAdmin(_admin);
    }
    
    // å›é€€å‡½æ•°ï¼Œå°†è°ƒç”¨å§”æ‰˜ç»™å®ç°åˆçº¦
    fallback() external payable {
        _delegate(_getImplementation());
    }
    
    receive() external payable {
        _delegate(_getImplementation());
    }
    
    // å‡çº§å®ç°åˆçº¦
    function upgrade(address newImplementation) external onlyAdmin {
        require(newImplementation != address(0), "Invalid implementation address");
        require(newImplementation != _getImplementation(), "Same implementation");
        
        _setImplementation(newImplementation);
        emit Upgraded(newImplementation);
    }
    
    // æ›´æ”¹ç®¡ç†å‘˜
    function changeAdmin(address newAdmin) external onlyAdmin {
        require(newAdmin != address(0), "Invalid admin address");
        
        address previousAdmin = _getAdmin();
        _setAdmin(newAdmin);
        
        emit AdminChanged(previousAdmin, newAdmin);
    }
    
    // è·å–å½“å‰å®ç°åˆçº¦åœ°å€
    function implementation() external view returns (address) {
        return _getImplementation();
    }
    
    // è·å–å½“å‰ç®¡ç†å‘˜åœ°å€
    function admin() external view returns (address) {
        return _getAdmin();
    }
    
    // å§”æ‰˜è°ƒç”¨
    function _delegate(address impl) internal {
        assembly {
            // å¤åˆ¶è°ƒç”¨æ•°æ®
            calldatacopy(0, 0, calldatasize())
            
            // å§”æ‰˜è°ƒç”¨å®ç°åˆçº¦
            let result := delegatecall(gas(), impl, 0, calldatasize(), 0, 0)
            
            // å¤åˆ¶è¿”å›æ•°æ®
            returndatacopy(0, 0, returndatasize())
            
            switch result
            case 0 {
                revert(0, returndatasize())
            }
            default {
                return(0, returndatasize())
            }
        }
    }
    
    // è·å–å®ç°åˆçº¦åœ°å€
    function _getImplementation() internal view returns (address impl) {
        bytes32 slot = IMPLEMENTATION_SLOT;
        assembly {
            impl := sload(slot)
        }
    }
    
    // è®¾ç½®å®ç°åˆçº¦åœ°å€
    function _setImplementation(address impl) internal {
        bytes32 slot = IMPLEMENTATION_SLOT;
        assembly {
            sstore(slot, impl)
        }
    }
    
    // è·å–ç®¡ç†å‘˜åœ°å€
    function _getAdmin() internal view returns (address adm) {
        bytes32 slot = ADMIN_SLOT;
        assembly {
            adm := sload(slot)
        }
    }
    
    // è®¾ç½®ç®¡ç†å‘˜åœ°å€
    function _setAdmin(address adm) internal {
        bytes32 slot = ADMIN_SLOT;
        assembly {
            sstore(slot, adm)
        }
    }
}

// å®ç°åˆçº¦åŸºç±»
abstract contract Initializable {
    bool private _initialized;
    bool private _initializing;
    
    modifier initializer() {
        require(
            _initializing || !_initialized,
            "Contract instance has already been initialized"
        );
        
        bool isTopLevelCall = !_initializing;
        if (isTopLevelCall) {
            _initializing = true;
            _initialized = true;
        }
        
        _;
        
        if (isTopLevelCall) {
            _initializing = false;
        }
    }
}

// ç¤ºä¾‹å®ç°åˆçº¦ V1
contract TokenV1 is Initializable {
    mapping(address => uint256) public balances;
    mapping(address => mapping(address => uint256)) public allowances;
    
    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public totalSupply;
    
    address public owner;
    
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    
    function initialize(
        string memory _name,
        string memory _symbol,
        uint8 _decimals,
        uint256 _totalSupply
    ) external initializer {
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
        totalSupply = _totalSupply;
        owner = msg.sender;
        
        balances[msg.sender] = _totalSupply;
        emit Transfer(address(0), msg.sender, _totalSupply);
    }
    
    function transfer(address to, uint256 amount) external returns (bool) {
        require(balances[msg.sender] >= amount, "Insufficient balance");
        
        balances[msg.sender] -= amount;
        balances[to] += amount;
        
        emit Transfer(msg.sender, to, amount);
        return true;
    }
    
    function approve(address spender, uint256 amount) external returns (bool) {
        allowances[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }
    
    function transferFrom(address from, address to, uint256 amount) external returns (bool) {
        require(balances[from] >= amount, "Insufficient balance");
        require(allowances[from][msg.sender] >= amount, "Insufficient allowance");
        
        balances[from] -= amount;
        balances[to] += amount;
        allowances[from][msg.sender] -= amount;
        
        emit Transfer(from, to, amount);
        return true;
    }
}

// å‡çº§åçš„å®ç°åˆçº¦ V2
contract TokenV2 is Initializable {
    mapping(address => uint256) public balances;
    mapping(address => mapping(address => uint256)) public allowances;
    
    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public totalSupply;
    
    address public owner;
    
    // V2 æ–°å¢åŠŸèƒ½
    mapping(address => bool) public blacklist;
    bool public paused;
    uint256 public maxTransferAmount;
    
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    event Blacklisted(address indexed account);
    event Unblacklisted(address indexed account);
    event Paused();
    event Unpaused();
    
    modifier onlyOwner() {
        require(msg.sender == owner, "Only owner");
        _;
    }
    
    modifier whenNotPaused() {
        require(!paused, "Contract is paused");
        _;
    }
    
    modifier notBlacklisted(address account) {
        require(!blacklist[account], "Account is blacklisted");
        _;
    }
    
    // V2 åˆå§‹åŒ–å‡½æ•°ï¼ˆåªèƒ½è°ƒç”¨ä¸€æ¬¡ï¼‰
    function initializeV2(uint256 _maxTransferAmount) external {
        require(maxTransferAmount == 0, "Already initialized V2");
        maxTransferAmount = _maxTransferAmount;
    }
    
    function transfer(address to, uint256 amount) 
        external 
        whenNotPaused 
        notBlacklisted(msg.sender) 
        notBlacklisted(to) 
        returns (bool) 
    {
        require(amount <= maxTransferAmount, "Amount exceeds maximum");
        require(balances[msg.sender] >= amount, "Insufficient balance");
        
        balances[msg.sender] -= amount;
        balances[to] += amount;
        
        emit Transfer(msg.sender, to, amount);
        return true;
    }
    
    function approve(address spender, uint256 amount) 
        external 
        whenNotPaused 
        notBlacklisted(msg.sender) 
        returns (bool) 
    {
        allowances[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }
    
    function transferFrom(address from, address to, uint256 amount) 
        external 
        whenNotPaused 
        notBlacklisted(from) 
        notBlacklisted(to) 
        returns (bool) 
    {
        require(amount <= maxTransferAmount, "Amount exceeds maximum");
        require(balances[from] >= amount, "Insufficient balance");
        require(allowances[from][msg.sender] >= amount, "Insufficient allowance");
        
        balances[from] -= amount;
        balances[to] += amount;
        allowances[from][msg.sender] -= amount;
        
        emit Transfer(from, to, amount);
        return true;
    }
    
    // V2 æ–°å¢ç®¡ç†åŠŸèƒ½
    function addToBlacklist(address account) external onlyOwner {
        blacklist[account] = true;
        emit Blacklisted(account);
    }
    
    function removeFromBlacklist(address account) external onlyOwner {
        blacklist[account] = false;
        emit Unblacklisted(account);
    }
    
    function pause() external onlyOwner {
        paused = true;
        emit Paused();
    }
    
    function unpause() external onlyOwner {
        paused = false;
        emit Unpaused();
    }
    
    function setMaxTransferAmount(uint256 _maxTransferAmount) external onlyOwner {
        maxTransferAmount = _maxTransferAmount;
    }
}
```

### å·¥å‚æ¨¡å¼ï¼ˆFactory Patternï¼‰

```solidity
// æŠ½è±¡äº§å“æ¥å£
interface IToken {
    function name() external view returns (string memory);
    function symbol() external view returns (string memory);
    function decimals() external view returns (uint8);
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address to, uint256 amount) external returns (bool);
}

// å…·ä½“äº§å“ï¼šæ ‡å‡†ä»£å¸
contract StandardToken is IToken {
    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;
    
    string private _name;
    string private _symbol;
    uint8 private _decimals;
    uint256 private _totalSupply;
    
    constructor(
        string memory name_,
        string memory symbol_,
        uint8 decimals_,
        uint256 totalSupply_
    ) {
        _name = name_;
        _symbol = symbol_;
        _decimals = decimals_;
        _totalSupply = totalSupply_;
        _balances[msg.sender] = totalSupply_;
    }
    
    function name() external view override returns (string memory) {
        return _name;
    }
    
    function symbol() external view override returns (string memory) {
        return _symbol;
    }
    
    function decimals() external view override returns (uint8) {
        return _decimals;
    }
    
    function totalSupply() external view override returns (uint256) {
        return _totalSupply;
    }
    
    function balanceOf(address account) external view override returns (uint256) {
        return _balances[account];
    }
    
    function transfer(address to, uint256 amount) external override returns (bool) {
        require(_balances[msg.sender] >= amount, "Insufficient balance");
        
        _balances[msg.sender] -= amount;
        _balances[to] += amount;
        
        return true;
    }
}

// å…·ä½“äº§å“ï¼šå¯é“¸é€ ä»£å¸
contract MintableToken is IToken {
    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;
    
    string private _name;
    string private _symbol;
    uint8 private _decimals;
    uint256 private _totalSupply;
    
    address public owner;
    
    modifier onlyOwner() {
        require(msg.sender == owner, "Only owner");
        _;
    }
    
    constructor(
        string memory name_,
        string memory symbol_,
        uint8 decimals_
    ) {
        _name = name_;
        _symbol = symbol_;
        _decimals = decimals_;
        owner = msg.sender;
    }
    
    function name() external view override returns (string memory) {
        return _name;
    }
    
    function symbol() external view override returns (string memory) {
        return _symbol;
    }
    
    function decimals() external view override returns (uint8) {
        return _decimals;
    }
    
    function totalSupply() external view override returns (uint256) {
        return _totalSupply;
    }
    
    function balanceOf(address account) external view override returns (uint256) {
        return _balances[account];
    }
    
    function transfer(address to, uint256 amount) external override returns (bool) {
        require(_balances[msg.sender] >= amount, "Insufficient balance");
        
        _balances[msg.sender] -= amount;
        _balances[to] += amount;
        
        return true;
    }
    
    function mint(address to, uint256 amount) external onlyOwner {
        _balances[to] += amount;
        _totalSupply += amount;
    }
    
    function burn(uint256 amount) external {
        require(_balances[msg.sender] >= amount, "Insufficient balance");
        
        _balances[msg.sender] -= amount;
        _totalSupply -= amount;
    }
}

// å…·ä½“äº§å“ï¼šå¸¦è´¹ç”¨çš„ä»£å¸
contract FeeToken is IToken {
    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;
    
    string private _name;
    string private _symbol;
    uint8 private _decimals;
    uint256 private _totalSupply;
    
    address public feeCollector;
    uint256 public feeRate; // åŸºç‚¹ (1 = 0.01%)
    
    constructor(
        string memory name_,
        string memory symbol_,
        uint8 decimals_,
        uint256 totalSupply_,
        address feeCollector_,
        uint256 feeRate_
    ) {
        _name = name_;
        _symbol = symbol_;
        _decimals = decimals_;
        _totalSupply = totalSupply_;
        feeCollector = feeCollector_;
        feeRate = feeRate_;
        _balances[msg.sender] = totalSupply_;
    }
    
    function name() external view override returns (string memory) {
        return _name;
    }
    
    function symbol() external view override returns (string memory) {
        return _symbol;
    }
    
    function decimals() external view override returns (uint8) {
        return _decimals;
    }
    
    function totalSupply() external view override returns (uint256) {
        return _totalSupply;
    }
    
    function balanceOf(address account) external view override returns (uint256) {
        return _balances[account];
    }
    
    function transfer(address to, uint256 amount) external override returns (bool) {
        require(_balances[msg.sender] >= amount, "Insufficient balance");
        
        uint256 fee = (amount * feeRate) / 10000;
        uint256 netAmount = amount - fee;
        
        _balances[msg.sender] -= amount;
        _balances[to] += netAmount;
        _balances[feeCollector] += fee;
        
        return true;
    }
}

// æŠ½è±¡å·¥å‚
abstract contract TokenFactory {
    event TokenCreated(address indexed token, address indexed creator, string tokenType);
    
    function createToken(
        string memory name,
        string memory symbol,
        uint8 decimals,
        bytes memory params
    ) external virtual returns (address);
    
    function getTokenType() external view virtual returns (string memory);
}

// å…·ä½“å·¥å‚ï¼šæ ‡å‡†ä»£å¸å·¥å‚
contract StandardTokenFactory is TokenFactory {
    function createToken(
        string memory name,
        string memory symbol,
        uint8 decimals,
        bytes memory params
    ) external override returns (address) {
        uint256 totalSupply = abi.decode(params, (uint256));
        
        StandardToken token = new StandardToken(name, symbol, decimals, totalSupply);
        
        emit TokenCreated(address(token), msg.sender, "Standard");
        return address(token);
    }
    
    function getTokenType() external pure override returns (string memory) {
        return "Standard";
    }
}

// å…·ä½“å·¥å‚ï¼šå¯é“¸é€ ä»£å¸å·¥å‚
contract MintableTokenFactory is TokenFactory {
    function createToken(
        string memory name,
        string memory symbol,
        uint8 decimals,
        bytes memory params
    ) external override returns (address) {
        // params ä¸ºç©ºï¼Œå› ä¸ºå¯é“¸é€ ä»£å¸ä¸éœ€è¦åˆå§‹ä¾›åº”é‡
        
        MintableToken token = new MintableToken(name, symbol, decimals);
        
        emit TokenCreated(address(token), msg.sender, "Mintable");
        return address(token);
    }
    
    function getTokenType() external pure override returns (string memory) {
        return "Mintable";
    }
}

// å…·ä½“å·¥å‚ï¼šå¸¦è´¹ç”¨ä»£å¸å·¥å‚
contract FeeTokenFactory is TokenFactory {
    function createToken(
        string memory name,
        string memory symbol,
        uint8 decimals,
        bytes memory params
    ) external override returns (address) {
        (uint256 totalSupply, address feeCollector, uint256 feeRate) = 
            abi.decode(params, (uint256, address, uint256));
        
        FeeToken token = new FeeToken(
            name, 
            symbol, 
            decimals, 
            totalSupply, 
            feeCollector, 
            feeRate
        );
        
        emit TokenCreated(address(token), msg.sender, "Fee");
        return address(token);
    }
    
    function getTokenType() external pure override returns (string memory) {
        return "Fee";
    }
}

// å·¥å‚ç®¡ç†å™¨
contract TokenFactoryManager {
    mapping(string => address) public factories;
    mapping(address => bool) public authorizedFactories;
    
    address public owner;
    
    event FactoryRegistered(string indexed tokenType, address indexed factory);
    event TokenCreated(address indexed token, string tokenType, address indexed creator);
    
    modifier onlyOwner() {
        require(msg.sender == owner, "Only owner");
        _;
    }
    
    constructor() {
        owner = msg.sender;
    }
    
    function registerFactory(string memory tokenType, address factory) external onlyOwner {
        require(factory != address(0), "Invalid factory address");
        require(factories[tokenType] == address(0), "Factory already registered");
        
        factories[tokenType] = factory;
        authorizedFactories[factory] = true;
        
        emit FactoryRegistered(tokenType, factory);
    }
    
    function createToken(
        string memory tokenType,
        string memory name,
        string memory symbol,
        uint8 decimals,
        bytes memory params
    ) external returns (address) {
        address factory = factories[tokenType];
        require(factory != address(0), "Factory not found");
        
        address token = TokenFactory(factory).createToken(name, symbol, decimals, params);
        
        emit TokenCreated(token, tokenType, msg.sender);
        return token;
    }
    
    function getFactory(string memory tokenType) external view returns (address) {
        return factories[tokenType];
    }
    
    function isAuthorizedFactory(address factory) external view returns (bool) {
        return authorizedFactories[factory];
    }
}
```

### è§‚å¯Ÿè€…æ¨¡å¼ï¼ˆObserver Patternï¼‰

```solidity
// è§‚å¯Ÿè€…æ¥å£
interface IObserver {
    function update(address subject, bytes memory data) external;
}

// ä¸»é¢˜æ¥å£
interface ISubject {
    function attach(address observer) external;
    function detach(address observer) external;
    function notify(bytes memory data) external;
}

// å…·ä½“ä¸»é¢˜ï¼šä»·æ ¼é¢„è¨€æœº
contract PriceOracle is ISubject {
    struct PriceData {
        uint256 price;
        uint256 timestamp;
        uint256 confidence;
    }
    
    mapping(string => PriceData) public prices;
    mapping(address => bool) public observers;
    address[] public observerList;
    
    address public owner;
    
    event PriceUpdated(string indexed symbol, uint256 price, uint256 timestamp);
    event ObserverAttached(address indexed observer);
    event ObserverDetached(address indexed observer);
    
    modifier onlyOwner() {
        require(msg.sender == owner, "Only owner");
        _;
    }
    
    constructor() {
        owner = msg.sender;
    }
    
    function attach(address observer) external override onlyOwner {
        require(observer != address(0), "Invalid observer address");
        require(!observers[observer], "Observer already attached");
        
        observers[observer] = true;
        observerList.push(observer);
        
        emit ObserverAttached(observer);
    }
    
    function detach(address observer) external override onlyOwner {
        require(observers[observer], "Observer not attached");
        
        observers[observer] = false;
        
        // ä»æ•°ç»„ä¸­ç§»é™¤
        for (uint256 i = 0; i < observerList.length; i++) {
            if (observerList[i] == observer) {
                observerList[i] = observerList[observerList.length - 1];
                observerList.pop();
                break;
            }
        }
        
        emit ObserverDetached(observer);
    }
    
    function notify(bytes memory data) public override {
        for (uint256 i = 0; i < observerList.length; i++) {
            try IObserver(observerList[i]).update(address(this), data) {
                // æˆåŠŸé€šçŸ¥
            } catch {
                // å¿½ç•¥å¤±è´¥çš„è§‚å¯Ÿè€…
            }
        }
    }
    
    function updatePrice(
        string memory symbol,
        uint256 price,
        uint256 confidence
    ) external onlyOwner {
        prices[symbol] = PriceData({
            price: price,
            timestamp: block.timestamp,
            confidence: confidence
        });
        
        bytes memory data = abi.encode(symbol, price, block.timestamp, confidence);
        notify(data);
        
        emit PriceUpdated(symbol, price, block.timestamp);
    }
    
    function getPrice(string memory symbol) external view returns (PriceData memory) {
        return prices[symbol];
    }
}

// å…·ä½“è§‚å¯Ÿè€…ï¼šäº¤æ˜“ç­–ç•¥
contract TradingStrategy is IObserver {
    struct Position {
        string symbol;
        uint256 amount;
        uint256 entryPrice;
        uint256 timestamp;
        bool isLong;
    }
    
    mapping(address => Position[]) public userPositions;
    mapping(string => uint256) public thresholds;
    
    address public oracle;
    address public owner;
    
    event PositionOpened(address indexed user, string symbol, uint256 amount, bool isLong);
    event PositionClosed(address indexed user, string symbol, uint256 amount);
    event ThresholdTriggered(string symbol, uint256 price, uint256 threshold);
    
    modifier onlyOwner() {
        require(msg.sender == owner, "Only owner");
        _;
    }
    
    modifier onlyOracle() {
        require(msg.sender == oracle, "Only oracle can call");
        _;
    }
    
    constructor(address _oracle) {
        oracle = _oracle;
        owner = msg.sender;
    }
    
    function update(address subject, bytes memory data) external override onlyOracle {
        require(subject == oracle, "Invalid subject");
        
        (string memory symbol, uint256 price, uint256 timestamp, uint256 confidence) = 
            abi.decode(data, (string, uint256, uint256, uint256));
        
        // æ£€æŸ¥é˜ˆå€¼è§¦å‘
        if (thresholds[symbol] > 0 && price >= thresholds[symbol]) {
            emit ThresholdTriggered(symbol, price, thresholds[symbol]);
            _executeThresholdStrategy(symbol, price);
        }
        
        // æ£€æŸ¥æ­¢æŸ/æ­¢ç›ˆ
        _checkStopLoss(symbol, price);
    }
    
    function setThreshold(string memory symbol, uint256 threshold) external onlyOwner {
        thresholds[symbol] = threshold;
    }
    
    function openPosition(
        string memory symbol,
        uint256 amount,
        bool isLong
    ) external {
        // è·å–å½“å‰ä»·æ ¼
        (uint256 currentPrice,,,) = abi.decode(
            abi.encode(PriceOracle(oracle).getPrice(symbol)),
            (uint256, uint256, uint256, uint256)
        );
        
        Position memory newPosition = Position({
            symbol: symbol,
            amount: amount,
            entryPrice: currentPrice,
            timestamp: block.timestamp,
            isLong: isLong
        });
        
        userPositions[msg.sender].push(newPosition);
        
        emit PositionOpened(msg.sender, symbol, amount, isLong);
    }
    
    function _executeThresholdStrategy(string memory symbol, uint256 price) internal {
        // å®ç°é˜ˆå€¼è§¦å‘ç­–ç•¥
        // è¿™é‡Œå¯ä»¥è‡ªåŠ¨å¼€ä»“æˆ–å¹³ä»“
    }
    
    function _checkStopLoss(string memory symbol, uint256 currentPrice) internal {
        // æ£€æŸ¥æ‰€æœ‰ç”¨æˆ·çš„æ­¢æŸæ¡ä»¶
        // å®ç°æ­¢æŸé€»è¾‘
    }
    
    function getUserPositions(address user) external view returns (Position[] memory) {
        return userPositions[user];
    }
}

// å…·ä½“è§‚å¯Ÿè€…ï¼šé£é™©ç®¡ç†
contract RiskManager is IObserver {
    struct RiskMetrics {
        uint256 volatility;
        uint256 maxDrawdown;
        uint256 sharpeRatio;
        uint256 lastUpdate;
    }
    
    mapping(string => RiskMetrics) public riskMetrics;
    mapping(string => uint256[]) public priceHistory;
    
    address public oracle;
    address public owner;
    
    uint256 public constant MAX_HISTORY_LENGTH = 100;
    uint256 public constant VOLATILITY_THRESHOLD = 5000; // 50%
    
    event RiskAlert(string symbol, string riskType, uint256 value);
    event RiskMetricsUpdated(string symbol, uint256 volatility, uint256 maxDrawdown);
    
    modifier onlyOwner() {
        require(msg.sender == owner, "Only owner");
        _;
    }
    
    modifier onlyOracle() {
        require(msg.sender == oracle, "Only oracle can call");
        _;
    }
    
    constructor(address _oracle) {
        oracle = _oracle;
        owner = msg.sender;
    }
    
    function update(address subject, bytes memory data) external override onlyOracle {
        require(subject == oracle, "Invalid subject");
        
        (string memory symbol, uint256 price, uint256 timestamp, uint256 confidence) = 
            abi.decode(data, (string, uint256, uint256, uint256));
        
        // æ›´æ–°ä»·æ ¼å†å²
        _updatePriceHistory(symbol, price);
        
        // è®¡ç®—é£é™©æŒ‡æ ‡
        _calculateRiskMetrics(symbol);
        
        // æ£€æŸ¥é£é™©é˜ˆå€¼
        _checkRiskThresholds(symbol);
    }
    
    function _updatePriceHistory(string memory symbol, uint256 price) internal {
        uint256[] storage history = priceHistory[symbol];
        
        history.push(price);
        
        // ä¿æŒå†å²é•¿åº¦é™åˆ¶
        if (history.length > MAX_HISTORY_LENGTH) {
            // ç§»é™¤æœ€æ—§çš„ä»·æ ¼
            for (uint256 i = 0; i < history.length - 1; i++) {
                history[i] = history[i + 1];
            }
            history.pop();
        }
    }
    
    function _calculateRiskMetrics(string memory symbol) internal {
        uint256[] storage history = priceHistory[symbol];
        
        if (history.length < 2) return;
        
        // è®¡ç®—æ³¢åŠ¨ç‡ï¼ˆç®€åŒ–ç‰ˆï¼‰
        uint256 volatility = _calculateVolatility(history);
        
        // è®¡ç®—æœ€å¤§å›æ’¤
        uint256 maxDrawdown = _calculateMaxDrawdown(history);
        
        riskMetrics[symbol] = RiskMetrics({
            volatility: volatility,
            maxDrawdown: maxDrawdown,
            sharpeRatio: 0, // ç®€åŒ–ï¼Œå®é™…éœ€è¦æ›´å¤æ‚è®¡ç®—
            lastUpdate: block.timestamp
        });
        
        emit RiskMetricsUpdated(symbol, volatility, maxDrawdown);
    }
    
    function _calculateVolatility(uint256[] storage prices) internal view returns (uint256) {
        if (prices.length < 2) return 0;
        
        // è®¡ç®—æ”¶ç›Šç‡çš„æ ‡å‡†å·®ï¼ˆç®€åŒ–ç‰ˆï¼‰
        uint256 sum = 0;
        uint256 sumSquares = 0;
        uint256 count = prices.length - 1;
        
        for (uint256 i = 1; i < prices.length; i++) {
            uint256 return_ = (prices[i] * 10000) / prices[i - 1]; // åŸºç‚¹è¡¨ç¤º
            sum += return_;
            sumSquares += return_ * return_;
        }
        
        uint256 mean = sum / count;
        uint256 variance = (sumSquares / count) - (mean * mean);
        
        return _sqrt(variance);
    }
    
    function _calculateMaxDrawdown(uint256[] storage prices) internal view returns (uint256) {
        if (prices.length < 2) return 0;
        
        uint256 peak = prices[0];
        uint256 maxDrawdown = 0;
        
        for (uint256 i = 1; i < prices.length; i++) {
            if (prices[i] > peak) {
                peak = prices[i];
            } else {
                uint256 drawdown = ((peak - prices[i]) * 10000) / peak; // åŸºç‚¹è¡¨ç¤º
                if (drawdown > maxDrawdown) {
                    maxDrawdown = drawdown;
                }
            }
        }
        
        return maxDrawdown;
    }
    
    function _checkRiskThresholds(string memory symbol) internal {
        RiskMetrics storage metrics = riskMetrics[symbol];
        
        if (metrics.volatility > VOLATILITY_THRESHOLD) {
            emit RiskAlert(symbol, "HIGH_VOLATILITY", metrics.volatility);
        }
        
        if (metrics.maxDrawdown > 2000) { // 20%
            emit RiskAlert(symbol, "HIGH_DRAWDOWN", metrics.maxDrawdown);
        }
    }
    
    function _sqrt(uint256 x) internal pure returns (uint256) {
        if (x == 0) return 0;
        uint256 z = (x + 1) / 2;
        uint256 y = x;
        while (z < y) {
            y = z;
            z = (x / z + z) / 2;
        }
        return y;
    }
    
    function getRiskMetrics(string memory symbol) external view returns (RiskMetrics memory) {
        return riskMetrics[symbol];
    }
    
    function getPriceHistory(string memory symbol) external view returns (uint256[] memory) {
        return priceHistory[symbol];
    }
}
```

---

## ğŸ”§ æ¨¡å—åŒ–è®¾è®¡å®è·µ

### åº“åˆçº¦è®¾è®¡

```solidity
// æ•°å­¦è¿ç®—åº“
library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");
        return c;
    }
    
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, "SafeMath: subtraction overflow");
        return a - b;
    }
    
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) return 0;
        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");
        return c;
    }
    
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0, "SafeMath: division by zero");
        return a / b;
    }
    
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0, "SafeMath: modulo by zero");
        return a % b;
    }
}

// åœ°å€å·¥å…·åº“
library Address {
    function isContract(address account) internal view returns (bool) {
        uint256 size;
        assembly {
            size := extcodesize(account)
        }
        return size > 0;
    }
    
    function sendValue(address payable recipient, uint256 amount) internal {
        require(address(this).balance >= amount, "Address: insufficient balance");
        
        (bool success, ) = recipient.call{value: amount}("");
        require(success, "Address: unable to send value, recipient may have reverted");
    }
    
    function functionCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionCall(target, data, "Address: low-level call failed");
    }
    
    function functionCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal returns (bytes memory) {
        return functionCallWithValue(target, data, 0, errorMessage);
    }
    
    function functionCallWithValue(
        address target,
        bytes memory data,
        uint256 value,
        string memory errorMessage
    ) internal returns (bytes memory) {
        require(address(this).balance >= value, "Address: insufficient balance for call");
        require(isContract(target), "Address: call to non-contract");
        
        (bool success, bytes memory returndata) = target.call{value: value}(data);
        return _verifyCallResult(success, returndata, errorMessage);
    }
    
    function _verifyCallResult(
        bool success,
        bytes memory returndata,
        string memory errorMessage
    ) private pure returns (bytes memory) {
        if (success) {
            return returndata;
        } else {
            if (returndata.length > 0) {
                assembly {
                    let returndata_size := mload(returndata)
                    revert(add(32, returndata), returndata_size)
                }
            } else {
                revert(errorMessage);
            }
        }
    }
}

// å­—ç¬¦ä¸²å·¥å…·åº“
library Strings {
    bytes16 private constant _HEX_SYMBOLS = "0123456789abcdef";
    
    function toString(uint256 value) internal pure returns (string memory) {
        if (value == 0) {
            return "0";
        }
        uint256 temp = value;
        uint256 digits;
        while (temp != 0) {
            digits++;
            temp /= 10;
        }
        bytes memory buffer = new bytes(digits);
        while (value != 0) {
            digits -= 1;
            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));
            value /= 10;
        }
        return string(buffer);
    }
    
    function toHexString(uint256 value) internal pure returns (string memory) {
        if (value == 0) {
            return "0x00";
        }
        uint256 temp = value;
        uint256 length = 0;
        while (temp != 0) {
            length++;
            temp >>= 8;
        }
        return toHexString(value, length);
    }
    
    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {
        bytes memory buffer = new bytes(2 * length + 2);
        buffer[0] = "0";
        buffer[1] = "x";
        for (uint256 i = 2 * length + 1; i > 1; --i) {
            buffer[i] = _HEX_SYMBOLS[value & 0xf];
            value >>= 4;
        }
        require(value == 0, "Strings: hex length insufficient");
        return string(buffer);
    }
}

// åŠ å¯†å·¥å…·åº“
library Cryptography {
    function hash(bytes memory data) internal pure returns (bytes32) {
        return keccak256(data);
    }
    
    function hashPair(bytes32 a, bytes32 b) internal pure returns (bytes32) {
        return a < b ? keccak256(abi.encodePacked(a, b)) : keccak256(abi.encodePacked(b, a));
    }
    
    function verify(
        bytes32 hash,
        bytes32 r,
        bytes32 s,
        uint8 v
    ) internal pure returns (address) {
        require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, "Invalid signature 's' value");
        require(v == 27 || v == 28, "Invalid signature 'v' value");
        
        address signer = ecrecover(hash, v, r, s);
        require(signer != address(0), "Invalid signature");
        
        return signer;
    }
    
    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", hash));
    }
    
    function generateMerkleRoot(bytes32[] memory leaves) internal pure returns (bytes32) {
        require(leaves.length > 0, "Empty leaves array");
        
        if (leaves.length == 1) {
            return leaves[0];
        }
        
        bytes32[] memory currentLevel = leaves;
        
        while (currentLevel.length > 1) {
            bytes32[] memory nextLevel = new bytes32[]((currentLevel.length + 1) / 2);
            
            for (uint256 i = 0; i < currentLevel.length; i += 2) {
                if (i + 1 < currentLevel.length) {
                    nextLevel[i / 2] = hashPair(currentLevel[i], currentLevel[i + 1]);
                } else {
                    nextLevel[i / 2] = currentLevel[i];
                }
            }
            
            currentLevel = nextLevel;
        }
        
        return currentLevel[0];
    }
    
    function verifyMerkleProof(
        bytes32[] memory proof,
        bytes32 root,
        bytes32 leaf
    ) internal pure returns (bool) {
        bytes32 computedHash = leaf;
        
        for (uint256 i = 0; i < proof.length; i++) {
            computedHash = hashPair(computedHash, proof[i]);
        }
        
        return computedHash == root;
    }
}
```

### æ’ä»¶æ¶æ„ç³»ç»Ÿ

```solidity
// æ’ä»¶æ¥å£
interface IPlugin {
    function getName() external view returns (string memory);
    function getVersion() external view returns (string memory);
    function initialize(bytes memory params) external;
    function execute(bytes memory input) external returns (bytes memory);
    function isActive() external view returns (bool);
}

// æ’ä»¶ç®¡ç†å™¨
contract PluginManager {
    struct Plugin {
        address pluginAddress;
        string name;
        string version;
        bool isActive;
        bool isInstalled;
        uint256 installedAt;
        mapping(string => bytes) metadata;
    }
    
    mapping(bytes32 => Plugin) public plugins;
    mapping(string => bytes32) public pluginsByName;
    bytes32[] public installedPlugins;
    
    address public owner;
    bool public paused;
    
    event PluginInstalled(bytes32 indexed pluginId, string name, address pluginAddress);
    event PluginUninstalled(bytes32 indexed pluginId, string name);
    event PluginActivated(bytes32 indexed pluginId);
    event PluginDeactivated(bytes32 indexed pluginId);
    
    modifier onlyOwner() {
        require(msg.sender == owner, "Only owner");
        _;
    }
    
    modifier whenNotPaused() {
        require(!paused, "System is paused");
        _;
    }
    
    constructor() {
        owner = msg.sender;
    }
    
    function installPlugin(
        address pluginAddress,
        bytes memory initParams
    ) external onlyOwner whenNotPaused returns (bytes32) {
        require(pluginAddress != address(0), "Invalid plugin address");
        require(Address.isContract(pluginAddress), "Not a contract");
        
        IPlugin plugin = IPlugin(pluginAddress);
        string memory name = plugin.getName();
        string memory version = plugin.getVersion();
        
        bytes32 pluginId = keccak256(abi.encodePacked(name, version, block.timestamp));
        require(!plugins[pluginId].isInstalled, "Plugin already installed");
        
        // åˆå§‹åŒ–æ’ä»¶
        plugin.initialize(initParams);
        
        plugins[pluginId].pluginAddress = pluginAddress;
        plugins[pluginId].name = name;
        plugins[pluginId].version = version;
        plugins[pluginId].isActive = true;
        plugins[pluginId].isInstalled = true;
        plugins[pluginId].installedAt = block.timestamp;
        
        pluginsByName[name] = pluginId;
        installedPlugins.push(pluginId);
        
        emit PluginInstalled(pluginId, name, pluginAddress);
        return pluginId;
    }
    
    function uninstallPlugin(bytes32 pluginId) external onlyOwner {
        require(plugins[pluginId].isInstalled, "Plugin not installed");
        
        plugins[pluginId].isInstalled = false;
        plugins[pluginId].isActive = false;
        
        // ä»æ•°ç»„ä¸­ç§»é™¤
        for (uint256 i = 0; i < installedPlugins.length; i++) {
            if (installedPlugins[i] == pluginId) {
                installedPlugins[i] = installedPlugins[installedPlugins.length - 1];
                installedPlugins.pop();
                break;
            }
        }
        
        emit PluginUninstalled(pluginId, plugins[pluginId].name);
    }
    
    function activatePlugin(bytes32 pluginId) external onlyOwner {
        require(plugins[pluginId].isInstalled, "Plugin not installed");
        require(!plugins[pluginId].isActive, "Plugin already active");
        
        plugins[pluginId].isActive = true;
        emit PluginActivated(pluginId);
    }
    
    function deactivatePlugin(bytes32 pluginId) external onlyOwner {
        require(plugins[pluginId].isInstalled, "Plugin not installed");
        require(plugins[pluginId].isActive, "Plugin already inactive");
        
        plugins[pluginId].isActive = false;
        emit PluginDeactivated(pluginId);
    }
    
    function executePlugin(
        string memory pluginName,
        bytes memory input
    ) external whenNotPaused returns (bytes memory) {
        bytes32 pluginId = pluginsByName[pluginName];
        require(plugins[pluginId].isInstalled, "Plugin not installed");
        require(plugins[pluginId].isActive, "Plugin not active");
        
        IPlugin plugin = IPlugin(plugins[pluginId].pluginAddress);
        return plugin.execute(input);
    }
    
    function getInstalledPlugins() external view returns (bytes32[] memory) {
        return installedPlugins;
    }
    
    function getPluginInfo(bytes32 pluginId) external view returns (
        address pluginAddress,
        string memory name,
        string memory version,
        bool isActive,
        bool isInstalled,
        uint256 installedAt
    ) {
        Plugin storage plugin = plugins[pluginId];
        return (
            plugin.pluginAddress,
            plugin.name,
            plugin.version,
            plugin.isActive,
            plugin.isInstalled,
            plugin.installedAt
        );
    }
}

// ç¤ºä¾‹æ’ä»¶ï¼šæ•°æ®éªŒè¯æ’ä»¶
contract DataValidationPlugin is IPlugin {
    string private constant NAME = "DataValidation";
    string private constant VERSION = "1.0.0";
    
    bool private _isActive;
    address private _manager;
    
    struct ValidationRule {
        string fieldName;
        string ruleType; // "required", "minLength", "maxLength", "pattern"
        bytes ruleValue;
    }
    
    mapping(string => ValidationRule[]) public validationRules;
    
    modifier onlyManager() {
        require(msg.sender == _manager, "Only manager can call");
        _;
    }
    
    function getName() external pure override returns (string memory) {
        return NAME;
    }
    
    function getVersion() external pure override returns (string memory) {
        return VERSION;
    }
    
    function initialize(bytes memory params) external override {
        require(_manager == address(0), "Already initialized");
        
        _manager = msg.sender;
        _isActive = true;
        
        // è§£æåˆå§‹åŒ–å‚æ•°
        if (params.length > 0) {
            // å¯ä»¥è®¾ç½®é»˜è®¤éªŒè¯è§„åˆ™
        }
    }
    
    function execute(bytes memory input) external override onlyManager returns (bytes memory) {
        require(_isActive, "Plugin not active");
        
        (string memory schema, bytes memory data) = abi.decode(input, (string, bytes));
        
        bool isValid = _validateData(schema, data);
        return abi.encode(isValid);
    }
    
    function isActive() external view override returns (bool) {
        return _isActive;
    }
    
    function addValidationRule(
        string memory schema,
        string memory fieldName,
        string memory ruleType,
        bytes memory ruleValue
    ) external onlyManager {
        validationRules[schema].push(ValidationRule({
            fieldName: fieldName,
            ruleType: ruleType,
            ruleValue: ruleValue
        }));
    }
    
    function _validateData(string memory schema, bytes memory data) internal view returns (bool) {
        ValidationRule[] storage rules = validationRules[schema];
        
        for (uint256 i = 0; i < rules.length; i++) {
            ValidationRule storage rule = rules[i];
            
            if (!_validateField(data, rule)) {
                return false;
            }
        }
        
        return true;
    }
    
    function _validateField(bytes memory data, ValidationRule storage rule) internal pure returns (bool) {
        // ç®€åŒ–çš„éªŒè¯é€»è¾‘
        if (keccak256(bytes(rule.ruleType)) == keccak256(bytes("required"))) {
            return data.length > 0;
        }
        
        if (keccak256(bytes(rule.ruleType)) == keccak256(bytes("minLength"))) {
            uint256 minLength = abi.decode(rule.ruleValue, (uint256));
            return data.length >= minLength;
        }
        
        if (keccak256(bytes(rule.ruleType)) == keccak256(bytes("maxLength"))) {
            uint256 maxLength = abi.decode(rule.ruleValue, (uint256));
            return data.length <= maxLength;
        }
        
        return true;
    }
}
```

---

## ğŸ“š å­¦ä¹ å¿ƒå¾—ä¸æ€»ç»“

### ç³»ç»Ÿæ¶æ„è®¾è®¡è¦ç‚¹

1. **åˆ†å±‚æ¶æ„çš„ä¼˜åŠ¿**
   - èŒè´£åˆ†ç¦»ï¼šæ¯å±‚ä¸“æ³¨äºç‰¹å®šåŠŸèƒ½
   - å¯ç»´æŠ¤æ€§ï¼šä¿®æ”¹æŸå±‚ä¸å½±å“å…¶ä»–å±‚
   - å¯æµ‹è¯•æ€§ï¼šæ¯å±‚å¯ç‹¬ç«‹æµ‹è¯•
   - å¯æ‰©å±•æ€§ï¼šæ˜“äºæ·»åŠ æ–°åŠŸèƒ½

2. **å¾®æœåŠ¡æ¶æ„çš„å®è·µ**
   - æœåŠ¡ç‹¬ç«‹ï¼šæ¯ä¸ªæœåŠ¡å¯ç‹¬ç«‹éƒ¨ç½²å’Œå‡çº§
   - æ¾è€¦åˆï¼šæœåŠ¡é—´é€šè¿‡æ¥å£é€šä¿¡
   - å®¹é”™æ€§ï¼šå•ä¸ªæœåŠ¡æ•…éšœä¸å½±å“æ•´ä½“ç³»ç»Ÿ
   - å¯ä¼¸ç¼©æ€§ï¼šå¯æ ¹æ®éœ€æ±‚æ‰©å±•ç‰¹å®šæœåŠ¡

### è®¾è®¡æ¨¡å¼åº”ç”¨å¿ƒå¾—

1. **ä»£ç†æ¨¡å¼çš„ä»·å€¼**
   - åˆçº¦å‡çº§ï¼šè§£å†³åŒºå—é“¾ä¸å¯å˜æ€§é—®é¢˜
   - è®¿é—®æ§åˆ¶ï¼šç»Ÿä¸€ç®¡ç†æƒé™éªŒè¯
   - æ€§èƒ½ä¼˜åŒ–ï¼šå»¶è¿ŸåŠ è½½å’Œç¼“å­˜æœºåˆ¶
   - å®‰å…¨å¢å¼ºï¼šéš”ç¦»æ ¸å¿ƒé€»è¾‘å’Œå¤–éƒ¨è°ƒç”¨

2. **å·¥å‚æ¨¡å¼çš„å®ç”¨æ€§**
   - å¯¹è±¡åˆ›å»ºï¼šç»Ÿä¸€ç®¡ç†å¤æ‚å¯¹è±¡çš„åˆ›å»ºè¿‡ç¨‹
   - ç±»å‹å®‰å…¨ï¼šç¼–è¯‘æ—¶ç¡®ä¿å¯¹è±¡ç±»å‹æ­£ç¡®
   - æ‰©å±•æ€§ï¼šæ˜“äºæ·»åŠ æ–°çš„äº§å“ç±»å‹
   - é…ç½®ç®¡ç†ï¼šé›†ä¸­ç®¡ç†åˆ›å»ºå‚æ•°

3. **è§‚å¯Ÿè€…æ¨¡å¼çš„åº”ç”¨åœºæ™¯**
   - äº‹ä»¶é©±åŠ¨ï¼šå®ç°æ¾è€¦åˆçš„äº‹ä»¶å¤„ç†
   - å®æ—¶æ›´æ–°ï¼šè‡ªåŠ¨åŒæ­¥çŠ¶æ€å˜åŒ–
   - æ‰©å±•æ€§ï¼šæ˜“äºæ·»åŠ æ–°çš„è§‚å¯Ÿè€…
   - è§£è€¦åˆï¼šä¸»é¢˜å’Œè§‚å¯Ÿè€…ç‹¬ç«‹å˜åŒ–

### æ¨¡å—åŒ–è®¾è®¡å®è·µ

1. **åº“åˆçº¦çš„è®¾è®¡åŸåˆ™**
   - çº¯å‡½æ•°ï¼šæ— çŠ¶æ€ï¼Œå¯é‡ç”¨
   - å®‰å…¨æ€§ï¼šé˜²æ­¢æº¢å‡ºå’Œå¼‚å¸¸
   - æ•ˆç‡æ€§ï¼šä¼˜åŒ–Gasæ¶ˆè€—
   - é€šç”¨æ€§ï¼šé€‚ç”¨äºå¤šç§åœºæ™¯

2. **æ’ä»¶æ¶æ„çš„ä¼˜åŠ¿**
   - åŠŸèƒ½æ‰©å±•ï¼šåŠ¨æ€æ·»åŠ æ–°åŠŸèƒ½
   - ç‰ˆæœ¬ç®¡ç†ï¼šæ”¯æŒæ’ä»¶ç‰ˆæœ¬æ§åˆ¶
   - éš”ç¦»æ€§ï¼šæ’ä»¶æ•…éšœä¸å½±å“æ ¸å¿ƒç³»ç»Ÿ
   - çµæ´»æ€§ï¼šå¯æ ¹æ®éœ€æ±‚å¯ç”¨/ç¦ç”¨åŠŸèƒ½

### å®è·µå»ºè®®

1. **æ¶æ„è®¾è®¡é˜¶æ®µ**
   - æ˜ç¡®ç³»ç»Ÿè¾¹ç•Œå’ŒèŒè´£åˆ’åˆ†
   - é€‰æ‹©åˆé€‚çš„æ¶æ„æ¨¡å¼
   - è€ƒè™‘æœªæ¥æ‰©å±•éœ€æ±‚
   - è®¾è®¡æ¸…æ™°çš„æ¥å£è§„èŒƒ

2. **å¼€å‘å®æ–½é˜¶æ®µ**
   - éµå¾ªSOLIDåŸåˆ™
   - ç¼–å†™å®Œæ•´çš„å•å…ƒæµ‹è¯•
   - ä½¿ç”¨è®¾è®¡æ¨¡å¼è§£å†³å¸¸è§é—®é¢˜
   - ä¿æŒä»£ç çš„å¯è¯»æ€§å’Œå¯ç»´æŠ¤æ€§

3. **éƒ¨ç½²è¿ç»´é˜¶æ®µ**
   - å®æ–½æ¸è¿›å¼éƒ¨ç½²ç­–ç•¥
   - å»ºç«‹å®Œå–„çš„ç›‘æ§ä½“ç³»
   - å‡†å¤‡åº”æ€¥å“åº”æ–¹æ¡ˆ
   - å®šæœŸè¿›è¡Œå®‰å…¨å®¡è®¡

### æœªæ¥å‘å±•æ–¹å‘

1. **æŠ€æœ¯è¶‹åŠ¿**
   - Layer 2è§£å†³æ–¹æ¡ˆçš„æ¶æ„è®¾è®¡
   - è·¨é“¾äº’æ“ä½œæ€§æ¶æ„
   - å»ä¸­å¿ƒåŒ–èº«ä»½ç³»ç»Ÿæ¶æ„
   - å¯æŒç»­å‘å±•çš„ç»æµæ¨¡å‹è®¾è®¡

2. **å­¦ä¹ è®¡åˆ’**
   - æ·±å…¥ç ”ç©¶ä¼ä¸šçº§æ¶æ„æ¨¡å¼
   - å­¦ä¹ åˆ†å¸ƒå¼ç³»ç»Ÿè®¾è®¡åŸç†
   - æŒæ¡æ€§èƒ½ä¼˜åŒ–å’Œå®‰å…¨åŠ å›ºæŠ€æœ¯
   - å…³æ³¨æ–°å…´æŠ€æœ¯å’Œæœ€ä½³å®è·µ

é€šè¿‡ç³»ç»Ÿæ€§çš„æ¶æ„è®¾è®¡å’Œæ¨¡å¼åº”ç”¨ï¼Œæˆ‘ä»¬å¯ä»¥æ„å»ºå‡ºæ›´åŠ å¥å£®ã€å¯ç»´æŠ¤å’Œå¯æ‰©å±•çš„æ™ºèƒ½åˆçº¦ç³»ç»Ÿã€‚è¿™ä¸ä»…æé«˜äº†å¼€å‘æ•ˆç‡ï¼Œä¹Ÿä¸ºé¡¹ç›®çš„é•¿æœŸæˆåŠŸå¥ å®šäº†åšå®åŸºç¡€ã€‚