# 03_课堂重点记录

**学生**：杜俊哲  
**学号**：2023111182  
**专业**：计算机科学与技术  
**学习特色**：专注于DeFi协议开发  

---

## 学习目标与个人定位

作为专注于DeFi协议开发的学习者，我致力于掌握去中心化金融的核心技术和创新应用。通过深入学习各类DeFi协议的设计原理和实现方式，建立完整的DeFi生态系统开发能力。

---

## 第一周：DeFi基础协议与AMM机制

### 课堂重点

#### 1. 自动化做市商(AMM)基础

```solidity
/**
 * @title SimpleAMM
 * @dev 简单的自动化做市商合约
 */
contract SimpleAMM {
    using SafeMath for uint256;
    
    // ✅ 代币合约
    IERC20 public tokenA;
    IERC20 public tokenB;
    
    // ✅ 流动性池储备
    uint256 public reserveA;
    uint256 public reserveB;
    
    // ✅ 流动性代币
    uint256 public totalSupply;
    mapping(address => uint256) public balanceOf;
    
    // ✅ 事件
    event Mint(address indexed to, uint256 amount);
    event Burn(address indexed to, uint256 amount);
    event Swap(address indexed user, uint256 amountIn, uint256 amountOut, address tokenIn);
    event Sync(uint256 reserveA, uint256 reserveB);
    
    constructor(address _tokenA, address _tokenB) {
        tokenA = IERC20(_tokenA);
        tokenB = IERC20(_tokenB);
    }
    
    // ✅ 添加流动性
    function addLiquidity(
        uint256 amountA,
        uint256 amountB
    ) external returns (uint256 liquidity) {
        tokenA.transferFrom(msg.sender, address(this), amountA);
        tokenB.transferFrom(msg.sender, address(this), amountB);
        
        if (totalSupply == 0) {
            liquidity = sqrt(amountA.mul(amountB));
        } else {
            liquidity = min(
                amountA.mul(totalSupply) / reserveA,
                amountB.mul(totalSupply) / reserveB
            );
        }
        
        require(liquidity > 0, "SimpleAMM: insufficient liquidity minted");
        
        balanceOf[msg.sender] = balanceOf[msg.sender].add(liquidity);
        totalSupply = totalSupply.add(liquidity);
        
        _update();
        emit Mint(msg.sender, liquidity);
    }
    
    // ✅ 移除流动性
    function removeLiquidity(uint256 liquidity) external returns (uint256 amountA, uint256 amountB) {
        require(balanceOf[msg.sender] >= liquidity, "SimpleAMM: insufficient balance");
        
        uint256 totalSupply_ = totalSupply;
        amountA = liquidity.mul(reserveA) / totalSupply_;
        amountB = liquidity.mul(reserveB) / totalSupply_;
        
        require(amountA > 0 && amountB > 0, "SimpleAMM: insufficient liquidity burned");
        
        balanceOf[msg.sender] = balanceOf[msg.sender].sub(liquidity);
        totalSupply = totalSupply.sub(liquidity);
        
        tokenA.transfer(msg.sender, amountA);
        tokenB.transfer(msg.sender, amountB);
        
        _update();
        emit Burn(msg.sender, liquidity);
    }
    
    // ✅ 代币交换
    function swapAForB(uint256 amountAIn) external returns (uint256 amountBOut) {
        require(amountAIn > 0, "SimpleAMM: insufficient input amount");
        
        uint256 amountBOutWithFee = getAmountOut(amountAIn, reserveA, reserveB);
        require(amountBOutWithFee > 0, "SimpleAMM: insufficient output amount");
        
        tokenA.transferFrom(msg.sender, address(this), amountAIn);
        tokenB.transfer(msg.sender, amountBOutWithFee);
        
        _update();
        emit Swap(msg.sender, amountAIn, amountBOutWithFee, address(tokenA));
        
        return amountBOutWithFee;
    }
    
    function swapBForA(uint256 amountBIn) external returns (uint256 amountAOut) {
        require(amountBIn > 0, "SimpleAMM: insufficient input amount");
        
        uint256 amountAOutWithFee = getAmountOut(amountBIn, reserveB, reserveA);
        require(amountAOutWithFee > 0, "SimpleAMM: insufficient output amount");
        
        tokenB.transferFrom(msg.sender, address(this), amountBIn);
        tokenA.transfer(msg.sender, amountAOutWithFee);
        
        _update();
        emit Swap(msg.sender, amountBIn, amountAOutWithFee, address(tokenB));
        
        return amountAOutWithFee;
    }
    
    // ✅ 计算输出金额（含手续费）
    function getAmountOut(
        uint256 amountIn,
        uint256 reserveIn,
        uint256 reserveOut
    ) public pure returns (uint256 amountOut) {
        require(amountIn > 0, "SimpleAMM: insufficient input amount");
        require(reserveIn > 0 && reserveOut > 0, "SimpleAMM: insufficient liquidity");
        
        uint256 amountInWithFee = amountIn.mul(997); // 0.3% 手续费
        uint256 numerator = amountInWithFee.mul(reserveOut);
        uint256 denominator = reserveIn.mul(1000).add(amountInWithFee);
        amountOut = numerator / denominator;
    }
    
    // ✅ 更新储备
    function _update() private {
        reserveA = tokenA.balanceOf(address(this));
        reserveB = tokenB.balanceOf(address(this));
        emit Sync(reserveA, reserveB);
    }
    
    // ✅ 辅助函数
    function sqrt(uint256 y) internal pure returns (uint256 z) {
        if (y > 3) {
            z = y;
            uint256 x = y / 2 + 1;
            while (x < z) {
                z = x;
                x = (y / x + x) / 2;
            }
        } else if (y != 0) {
            z = 1;
        }
    }
    
    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {
        z = x < y ? x : y;
    }
}
```

#### 2. 流动性挖矿协议

```solidity
/**
 * @title LiquidityMining
 * @dev 流动性挖矿合约
 */
contract LiquidityMining {
    using SafeMath for uint256;
    
    // ✅ 奖励代币
    IERC20 public rewardToken;
    
    // ✅ 挖矿池信息
    struct PoolInfo {
        IERC20 lpToken;           // LP代币合约
        uint256 allocPoint;       // 分配点数
        uint256 lastRewardBlock;  // 最后奖励区块
        uint256 accRewardPerShare; // 累积每股奖励
        uint256 totalStaked;      // 总质押量
    }
    
    // ✅ 用户信息
    struct UserInfo {
        uint256 amount;     // 质押数量
        uint256 rewardDebt; // 奖励债务
        uint256 pendingRewards; // 待领取奖励
    }
    
    // ✅ 状态变量
    PoolInfo[] public poolInfo;
    mapping(uint256 => mapping(address => UserInfo)) public userInfo;
    
    uint256 public rewardPerBlock;
    uint256 public totalAllocPoint = 0;
    uint256 public startBlock;
    
    // ✅ 事件
    event Deposit(address indexed user, uint256 indexed pid, uint256 amount);
    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);
    event Harvest(address indexed user, uint256 indexed pid, uint256 amount);
    event PoolAdded(uint256 indexed pid, address lpToken, uint256 allocPoint);
    
    constructor(
        IERC20 _rewardToken,
        uint256 _rewardPerBlock,
        uint256 _startBlock
    ) {
        rewardToken = _rewardToken;
        rewardPerBlock = _rewardPerBlock;
        startBlock = _startBlock;
    }
    
    // ✅ 添加挖矿池
    function addPool(
        uint256 _allocPoint,
        IERC20 _lpToken,
        bool _withUpdate
    ) external {
        if (_withUpdate) {
            massUpdatePools();
        }
        
        uint256 lastRewardBlock = block.number > startBlock ? block.number : startBlock;
        totalAllocPoint = totalAllocPoint.add(_allocPoint);
        
        poolInfo.push(PoolInfo({
            lpToken: _lpToken,
            allocPoint: _allocPoint,
            lastRewardBlock: lastRewardBlock,
            accRewardPerShare: 0,
            totalStaked: 0
        }));
        
        emit PoolAdded(poolInfo.length - 1, address(_lpToken), _allocPoint);
    }
    
    // ✅ 更新池子奖励
    function updatePool(uint256 _pid) public {
        PoolInfo storage pool = poolInfo[_pid];
        
        if (block.number <= pool.lastRewardBlock) {
            return;
        }
        
        if (pool.totalStaked == 0) {
            pool.lastRewardBlock = block.number;
            return;
        }
        
        uint256 multiplier = block.number.sub(pool.lastRewardBlock);
        uint256 reward = multiplier.mul(rewardPerBlock).mul(pool.allocPoint).div(totalAllocPoint);
        
        pool.accRewardPerShare = pool.accRewardPerShare.add(
            reward.mul(1e12).div(pool.totalStaked)
        );
        pool.lastRewardBlock = block.number;
    }
    
    // ✅ 批量更新池子
    function massUpdatePools() public {
        uint256 length = poolInfo.length;
        for (uint256 pid = 0; pid < length; ++pid) {
            updatePool(pid);
        }
    }
    
    // ✅ 质押LP代币
    function deposit(uint256 _pid, uint256 _amount) external {
        PoolInfo storage pool = poolInfo[_pid];
        UserInfo storage user = userInfo[_pid][msg.sender];
        
        updatePool(_pid);
        
        if (user.amount > 0) {
            uint256 pending = user.amount.mul(pool.accRewardPerShare).div(1e12).sub(user.rewardDebt);
            if (pending > 0) {
                user.pendingRewards = user.pendingRewards.add(pending);
            }
        }
        
        if (_amount > 0) {
            pool.lpToken.transferFrom(msg.sender, address(this), _amount);
            user.amount = user.amount.add(_amount);
            pool.totalStaked = pool.totalStaked.add(_amount);
        }
        
        user.rewardDebt = user.amount.mul(pool.accRewardPerShare).div(1e12);
        emit Deposit(msg.sender, _pid, _amount);
    }
    
    // ✅ 提取LP代币
    function withdraw(uint256 _pid, uint256 _amount) external {
        PoolInfo storage pool = poolInfo[_pid];
        UserInfo storage user = userInfo[_pid][msg.sender];
        
        require(user.amount >= _amount, "LiquidityMining: insufficient balance");
        
        updatePool(_pid);
        
        uint256 pending = user.amount.mul(pool.accRewardPerShare).div(1e12).sub(user.rewardDebt);
        if (pending > 0) {
            user.pendingRewards = user.pendingRewards.add(pending);
        }
        
        if (_amount > 0) {
            user.amount = user.amount.sub(_amount);
            pool.totalStaked = pool.totalStaked.sub(_amount);
            pool.lpToken.transfer(msg.sender, _amount);
        }
        
        user.rewardDebt = user.amount.mul(pool.accRewardPerShare).div(1e12);
        emit Withdraw(msg.sender, _pid, _amount);
    }
    
    // ✅ 收获奖励
    function harvest(uint256 _pid) external {
        PoolInfo storage pool = poolInfo[_pid];
        UserInfo storage user = userInfo[_pid][msg.sender];
        
        updatePool(_pid);
        
        uint256 pending = user.amount.mul(pool.accRewardPerShare).div(1e12).sub(user.rewardDebt);
        uint256 totalReward = user.pendingRewards.add(pending);
        
        if (totalReward > 0) {
            user.pendingRewards = 0;
            rewardToken.transfer(msg.sender, totalReward);
            emit Harvest(msg.sender, _pid, totalReward);
        }
        
        user.rewardDebt = user.amount.mul(pool.accRewardPerShare).div(1e12);
    }
    
    // ✅ 查看待收获奖励
    function pendingReward(uint256 _pid, address _user) external view returns (uint256) {
        PoolInfo storage pool = poolInfo[_pid];
        UserInfo storage user = userInfo[_pid][_user];
        
        uint256 accRewardPerShare = pool.accRewardPerShare;
        
        if (block.number > pool.lastRewardBlock && pool.totalStaked != 0) {
            uint256 multiplier = block.number.sub(pool.lastRewardBlock);
            uint256 reward = multiplier.mul(rewardPerBlock).mul(pool.allocPoint).div(totalAllocPoint);
            accRewardPerShare = accRewardPerShare.add(reward.mul(1e12).div(pool.totalStaked));
        }
        
        return user.amount.mul(accRewardPerShare).div(1e12).sub(user.rewardDebt).add(user.pendingRewards);
    }
}
```

### 核心技能掌握
1. **AMM机制**：恒定乘积公式、滑点计算、手续费机制
2. **流动性管理**：添加/移除流动性、LP代币机制
3. **激励机制**：流动性挖矿、奖励分发、质押机制

### 项目记录
- 实现了基础的AMM交换协议
- 开发了流动性挖矿激励系统
- 建立了多池子管理机制

---

## 第二周：借贷协议与利率模型

### 课堂重点

#### 1. 去中心化借贷协议

```solidity
/**
 * @title LendingProtocol
 * @dev 去中心化借贷协议
 */
contract LendingProtocol {
    using SafeMath for uint256;
    
    // ✅ 资产信息
    struct AssetInfo {
        IERC20 token;
        uint256 totalSupply;      // 总供应量
        uint256 totalBorrow;      // 总借贷量
        uint256 supplyRate;       // 存款利率
        uint256 borrowRate;       // 借贷利率
        uint256 collateralFactor; // 抵押因子
        uint256 liquidationThreshold; // 清算阈值
        bool isActive;
    }
    
    // ✅ 用户账户信息
    struct UserAccount {
        mapping(address => uint256) supplied;  // 供应量
        mapping(address => uint256) borrowed;  // 借贷量
        uint256 totalCollateralValue;         // 总抵押价值
        uint256 totalBorrowValue;             // 总借贷价值
        uint256 healthFactor;                 // 健康因子
    }
    
    // ✅ 状态变量
    mapping(address => AssetInfo) public assets;
    mapping(address => UserAccount) public userAccounts;
    address[] public supportedAssets;
    
    // ✅ 利率模型
    uint256 public constant BASE_RATE = 2e16;      // 2% 基础利率
    uint256 public constant SLOPE1 = 4e16;         // 4% 斜率1
    uint256 public constant SLOPE2 = 100e16;       // 100% 斜率2
    uint256 public constant OPTIMAL_UTILIZATION = 80e16; // 80% 最优利用率
    
    // ✅ 价格预言机
    mapping(address => uint256) public assetPrices;
    
    // ✅ 事件
    event Supply(address indexed user, address indexed asset, uint256 amount);
    event Withdraw(address indexed user, address indexed asset, uint256 amount);
    event Borrow(address indexed user, address indexed asset, uint256 amount);
    event Repay(address indexed user, address indexed asset, uint256 amount);
    event Liquidation(address indexed liquidator, address indexed borrower, address indexed asset, uint256 amount);
    
    // ✅ 添加支持的资产
    function addAsset(
        address _token,
        uint256 _collateralFactor,
        uint256 _liquidationThreshold
    ) external {
        require(!assets[_token].isActive, "LendingProtocol: asset already exists");
        
        assets[_token] = AssetInfo({
            token: IERC20(_token),
            totalSupply: 0,
            totalBorrow: 0,
            supplyRate: 0,
            borrowRate: 0,
            collateralFactor: _collateralFactor,
            liquidationThreshold: _liquidationThreshold,
            isActive: true
        });
        
        supportedAssets.push(_token);
    }
    
    // ✅ 供应资产
    function supply(address _asset, uint256 _amount) external {
        require(assets[_asset].isActive, "LendingProtocol: asset not supported");
        require(_amount > 0, "LendingProtocol: invalid amount");
        
        AssetInfo storage asset = assets[_asset];
        UserAccount storage account = userAccounts[msg.sender];
        
        // 转移代币
        asset.token.transferFrom(msg.sender, address(this), _amount);
        
        // 更新状态
        asset.totalSupply = asset.totalSupply.add(_amount);
        account.supplied[_asset] = account.supplied[_asset].add(_amount);
        
        // 更新利率
        _updateRates(_asset);
        
        // 更新用户账户价值
        _updateAccountValue(msg.sender);
        
        emit Supply(msg.sender, _asset, _amount);
    }
    
    // ✅ 提取资产
    function withdraw(address _asset, uint256 _amount) external {
        require(assets[_asset].isActive, "LendingProtocol: asset not supported");
        
        UserAccount storage account = userAccounts[msg.sender];
        require(account.supplied[_asset] >= _amount, "LendingProtocol: insufficient balance");
        
        // 检查健康因子
        _updateAccountValue(msg.sender);
        require(_canWithdraw(msg.sender, _asset, _amount), "LendingProtocol: insufficient collateral");
        
        AssetInfo storage asset = assets[_asset];
        
        // 更新状态
        asset.totalSupply = asset.totalSupply.sub(_amount);
        account.supplied[_asset] = account.supplied[_asset].sub(_amount);
        
        // 转移代币
        asset.token.transfer(msg.sender, _amount);
        
        // 更新利率
        _updateRates(_asset);
        
        // 更新用户账户价值
        _updateAccountValue(msg.sender);
        
        emit Withdraw(msg.sender, _asset, _amount);
    }
    
    // ✅ 借贷资产
    function borrow(address _asset, uint256 _amount) external {
        require(assets[_asset].isActive, "LendingProtocol: asset not supported");
        require(_amount > 0, "LendingProtocol: invalid amount");
        
        AssetInfo storage asset = assets[_asset];
        require(asset.totalSupply >= asset.totalBorrow.add(_amount), "LendingProtocol: insufficient liquidity");
        
        // 检查借贷能力
        _updateAccountValue(msg.sender);
        require(_canBorrow(msg.sender, _asset, _amount), "LendingProtocol: insufficient collateral");
        
        UserAccount storage account = userAccounts[msg.sender];
        
        // 更新状态
        asset.totalBorrow = asset.totalBorrow.add(_amount);
        account.borrowed[_asset] = account.borrowed[_asset].add(_amount);
        
        // 转移代币
        asset.token.transfer(msg.sender, _amount);
        
        // 更新利率
        _updateRates(_asset);
        
        // 更新用户账户价值
        _updateAccountValue(msg.sender);
        
        emit Borrow(msg.sender, _asset, _amount);
    }
    
    // ✅ 还款
    function repay(address _asset, uint256 _amount) external {
        require(assets[_asset].isActive, "LendingProtocol: asset not supported");
        
        UserAccount storage account = userAccounts[msg.sender];
        uint256 borrowBalance = account.borrowed[_asset];
        
        if (_amount > borrowBalance) {
            _amount = borrowBalance;
        }
        
        AssetInfo storage asset = assets[_asset];
        
        // 转移代币
        asset.token.transferFrom(msg.sender, address(this), _amount);
        
        // 更新状态
        asset.totalBorrow = asset.totalBorrow.sub(_amount);
        account.borrowed[_asset] = account.borrowed[_asset].sub(_amount);
        
        // 更新利率
        _updateRates(_asset);
        
        // 更新用户账户价值
        _updateAccountValue(msg.sender);
        
        emit Repay(msg.sender, _asset, _amount);
    }
    
    // ✅ 清算
    function liquidate(
        address _borrower,
        address _assetBorrowed,
        address _assetCollateral,
        uint256 _amount
    ) external {
        _updateAccountValue(_borrower);
        
        UserAccount storage borrowerAccount = userAccounts[_borrower];
        require(borrowerAccount.healthFactor < 1e18, "LendingProtocol: account is healthy");
        
        require(
            borrowerAccount.borrowed[_assetBorrowed] >= _amount,
            "LendingProtocol: amount exceeds borrowed"
        );
        
        // 计算清算奖励
        uint256 collateralAmount = _calculateLiquidationAmount(
            _assetBorrowed,
            _assetCollateral,
            _amount
        );
        
        require(
            borrowerAccount.supplied[_assetCollateral] >= collateralAmount,
            "LendingProtocol: insufficient collateral"
        );
        
        // 执行清算
        AssetInfo storage borrowedAsset = assets[_assetBorrowed];
        borrowedAsset.token.transferFrom(msg.sender, address(this), _amount);
        
        // 更新借贷者状态
        borrowedAsset.totalBorrow = borrowedAsset.totalBorrow.sub(_amount);
        borrowerAccount.borrowed[_assetBorrowed] = borrowerAccount.borrowed[_assetBorrowed].sub(_amount);
        borrowerAccount.supplied[_assetCollateral] = borrowerAccount.supplied[_assetCollateral].sub(collateralAmount);
        
        // 转移抵押品给清算者
        AssetInfo storage collateralAsset = assets[_assetCollateral];
        collateralAsset.totalSupply = collateralAsset.totalSupply.sub(collateralAmount);
        collateralAsset.token.transfer(msg.sender, collateralAmount);
        
        // 更新利率
        _updateRates(_assetBorrowed);
        _updateRates(_assetCollateral);
        
        // 更新账户价值
        _updateAccountValue(_borrower);
        
        emit Liquidation(msg.sender, _borrower, _assetBorrowed, _amount);
    }
    
    // ✅ 更新利率模型
    function _updateRates(address _asset) internal {
        AssetInfo storage asset = assets[_asset];
        
        if (asset.totalSupply == 0) {
            asset.supplyRate = 0;
            asset.borrowRate = BASE_RATE;
            return;
        }
        
        uint256 utilization = asset.totalBorrow.mul(1e18).div(asset.totalSupply);
        
        if (utilization <= OPTIMAL_UTILIZATION) {
            asset.borrowRate = BASE_RATE.add(
                utilization.mul(SLOPE1).div(OPTIMAL_UTILIZATION)
            );
        } else {
            uint256 excessUtilization = utilization.sub(OPTIMAL_UTILIZATION);
            asset.borrowRate = BASE_RATE.add(SLOPE1).add(
                excessUtilization.mul(SLOPE2).div(1e18 - OPTIMAL_UTILIZATION)
            );
        }
        
        asset.supplyRate = asset.borrowRate.mul(utilization).div(1e18).mul(90).div(100); // 90% 给供应者
    }
    
    // ✅ 更新用户账户价值
    function _updateAccountValue(address _user) internal {
        UserAccount storage account = userAccounts[_user];
        
        uint256 totalCollateralValue = 0;
        uint256 totalBorrowValue = 0;
        
        for (uint256 i = 0; i < supportedAssets.length; i++) {
            address asset = supportedAssets[i];
            uint256 price = assetPrices[asset];
            
            // 计算抵押价值
            uint256 suppliedValue = account.supplied[asset].mul(price).div(1e18);
            totalCollateralValue = totalCollateralValue.add(
                suppliedValue.mul(assets[asset].collateralFactor).div(1e18)
            );
            
            // 计算借贷价值
            uint256 borrowedValue = account.borrowed[asset].mul(price).div(1e18);
            totalBorrowValue = totalBorrowValue.add(borrowedValue);
        }
        
        account.totalCollateralValue = totalCollateralValue;
        account.totalBorrowValue = totalBorrowValue;
        
        if (totalBorrowValue > 0) {
            account.healthFactor = totalCollateralValue.mul(1e18).div(totalBorrowValue);
        } else {
            account.healthFactor = type(uint256).max;
        }
    }
    
    // ✅ 检查是否可以提取
    function _canWithdraw(address _user, address _asset, uint256 _amount) internal view returns (bool) {
        UserAccount storage account = userAccounts[_user];
        
        if (account.totalBorrowValue == 0) {
            return true;
        }
        
        uint256 assetPrice = assetPrices[_asset];
        uint256 withdrawValue = _amount.mul(assetPrice).div(1e18);
        uint256 collateralValue = withdrawValue.mul(assets[_asset].collateralFactor).div(1e18);
        
        return account.totalCollateralValue.sub(collateralValue).mul(1e18).div(account.totalBorrowValue) >= 1.2e18;
    }
    
    // ✅ 检查是否可以借贷
    function _canBorrow(address _user, address _asset, uint256 _amount) internal view returns (bool) {
        UserAccount storage account = userAccounts[_user];
        
        uint256 assetPrice = assetPrices[_asset];
        uint256 borrowValue = _amount.mul(assetPrice).div(1e18);
        uint256 newTotalBorrowValue = account.totalBorrowValue.add(borrowValue);
        
        return account.totalCollateralValue >= newTotalBorrowValue.mul(1.2e18).div(1e18);
    }
    
    // ✅ 计算清算金额
    function _calculateLiquidationAmount(
        address _assetBorrowed,
        address _assetCollateral,
        uint256 _amount
    ) internal view returns (uint256) {
        uint256 borrowedPrice = assetPrices[_assetBorrowed];
        uint256 collateralPrice = assetPrices[_assetCollateral];
        
        uint256 borrowedValue = _amount.mul(borrowedPrice).div(1e18);
        uint256 collateralAmount = borrowedValue.mul(1e18).div(collateralPrice);
        
        // 10% 清算奖励
        return collateralAmount.mul(110).div(100);
    }
    
    // ✅ 设置资产价格（仅用于演示）
    function setAssetPrice(address _asset, uint256 _price) external {
        assetPrices[_asset] = _price;
    }
    
    // ✅ 获取用户账户信息
    function getUserAccountInfo(address _user) external view returns (
        uint256 totalCollateralValue,
        uint256 totalBorrowValue,
        uint256 healthFactor
    ) {
        UserAccount storage account = userAccounts[_user];
        return (
            account.totalCollateralValue,
            account.totalBorrowValue,
            account.healthFactor
        );
    }
    
    // ✅ 获取资产利率
    function getAssetRates(address _asset) external view returns (
        uint256 supplyRate,
        uint256 borrowRate,
        uint256 utilization
    ) {
        AssetInfo storage asset = assets[_asset];
        
        uint256 util = 0;
        if (asset.totalSupply > 0) {
            util = asset.totalBorrow.mul(1e18).div(asset.totalSupply);
        }
        
        return (asset.supplyRate, asset.borrowRate, util);
    }
}
```

### 核心技能掌握
1. **借贷机制**：抵押借贷、利率计算、健康因子管理
2. **风险控制**：清算机制、抵押因子、风险评估
3. **利率模型**：动态利率、最优利用率、激励机制

### 项目记录
- 实现了完整的借贷协议架构
- 开发了动态利率模型
- 建立了清算和风险管理机制

---

## 第三周：衍生品协议与期权交易

### 课堂重点

#### 1. 去中心化期权协议

```solidity
/**
 * @title OptionsProtocol
 * @dev 去中心化期权交易协议
 */
contract OptionsProtocol {
    using SafeMath for uint256;
    
    // ✅ 期权类型
    enum OptionType { Call, Put }
    enum OptionStatus { Active, Exercised, Expired }
    
    // ✅ 期权信息
    struct Option {
        uint256 id;
        address creator;          // 期权创建者
        address buyer;           // 期权购买者
        IERC20 underlying;       // 标的资产
        IERC20 strike;          // 行权资产
        uint256 strikePrice;    // 行权价格
        uint256 premium;        // 期权费
        uint256 amount;         // 期权数量
        uint256 expiration;     // 到期时间
        OptionType optionType;  // 期权类型
        OptionStatus status;    // 期权状态
        bool isAmerican;        // 是否为美式期权
    }
    
    // ✅ 流动性池
    struct LiquidityPool {
        IERC20 token;
        uint256 totalLiquidity;
        uint256 availableLiquidity;
        uint256 lockedLiquidity;
        mapping(address => uint256) userLiquidity;
        uint256 totalShares;
        mapping(address => uint256) userShares;
    }
    
    // ✅ 状态变量
    mapping(uint256 => Option) public options;
    mapping(address => LiquidityPool) public liquidityPools;
    mapping(address => uint256[]) public userOptions;
    
    uint256 public nextOptionId = 1;
    uint256 public constant SECONDS_PER_DAY = 86400;
    
    // ✅ 价格预言机
    mapping(address => uint256) public assetPrices;
    
    // ✅ 事件
    event OptionCreated(uint256 indexed optionId, address indexed creator, OptionType optionType);
    event OptionPurchased(uint256 indexed optionId, address indexed buyer, uint256 premium);
    event OptionExercised(uint256 indexed optionId, address indexed exerciser, uint256 profit);
    event LiquidityAdded(address indexed user, address indexed token, uint256 amount);
    event LiquidityRemoved(address indexed user, address indexed token, uint256 amount);
    
    // ✅ 创建期权
    function createOption(
        address _underlying,
        address _strike,
        uint256 _strikePrice,
        uint256 _amount,
        uint256 _expiration,
        OptionType _optionType,
        bool _isAmerican
    ) external returns (uint256) {
        require(_expiration > block.timestamp, "OptionsProtocol: invalid expiration");
        require(_amount > 0, "OptionsProtocol: invalid amount");
        require(_strikePrice > 0, "OptionsProtocol: invalid strike price");
        
        // 计算期权费
        uint256 premium = _calculatePremium(
            _underlying,
            _strike,
            _strikePrice,
            _amount,
            _expiration,
            _optionType
        );
        
        uint256 optionId = nextOptionId++;
        
        options[optionId] = Option({
            id: optionId,
            creator: msg.sender,
            buyer: address(0),
            underlying: IERC20(_underlying),
            strike: IERC20(_strike),
            strikePrice: _strikePrice,
            premium: premium,
            amount: _amount,
            expiration: _expiration,
            optionType: _optionType,
            status: OptionStatus.Active,
            isAmerican: _isAmerican
        });
        
        userOptions[msg.sender].push(optionId);
        
        // 锁定抵押品
        if (_optionType == OptionType.Call) {
            IERC20(_underlying).transferFrom(msg.sender, address(this), _amount);
        } else {
            uint256 collateral = _amount.mul(_strikePrice).div(1e18);
            IERC20(_strike).transferFrom(msg.sender, address(this), collateral);
        }
        
        emit OptionCreated(optionId, msg.sender, _optionType);
        return optionId;
    }
    
    // ✅ 购买期权
    function purchaseOption(uint256 _optionId) external {
        Option storage option = options[_optionId];
        
        require(option.status == OptionStatus.Active, "OptionsProtocol: option not active");
        require(option.buyer == address(0), "OptionsProtocol: option already purchased");
        require(option.expiration > block.timestamp, "OptionsProtocol: option expired");
        require(msg.sender != option.creator, "OptionsProtocol: cannot buy own option");
        
        // 支付期权费
        option.strike.transferFrom(msg.sender, option.creator, option.premium);
        
        option.buyer = msg.sender;
        userOptions[msg.sender].push(_optionId);
        
        emit OptionPurchased(_optionId, msg.sender, option.premium);
    }
    
    // ✅ 行权期权
    function exerciseOption(uint256 _optionId) external {
        Option storage option = options[_optionId];
        
        require(option.buyer == msg.sender, "OptionsProtocol: not option buyer");
        require(option.status == OptionStatus.Active, "OptionsProtocol: option not active");
        
        if (!option.isAmerican) {
            require(block.timestamp >= option.expiration, "OptionsProtocol: not yet expired");
        }
        
        require(block.timestamp <= option.expiration, "OptionsProtocol: option expired");
        
        uint256 currentPrice = assetPrices[address(option.underlying)];
        uint256 profit = 0;
        
        if (option.optionType == OptionType.Call) {
            require(currentPrice > option.strikePrice, "OptionsProtocol: option out of money");
            
            profit = currentPrice.sub(option.strikePrice).mul(option.amount).div(1e18);
            
            // 支付行权价格
            option.strike.transferFrom(msg.sender, option.creator, option.amount.mul(option.strikePrice).div(1e18));
            
            // 转移标的资产
            option.underlying.transfer(msg.sender, option.amount);
            
        } else { // Put option
            require(currentPrice < option.strikePrice, "OptionsProtocol: option out of money");
            
            profit = option.strikePrice.sub(currentPrice).mul(option.amount).div(1e18);
            
            // 转移标的资产给创建者
            option.underlying.transferFrom(msg.sender, option.creator, option.amount);
            
            // 支付行权价格
            option.strike.transfer(msg.sender, option.amount.mul(option.strikePrice).div(1e18));
        }
        
        option.status = OptionStatus.Exercised;
        
        emit OptionExercised(_optionId, msg.sender, profit);
    }
    
    // ✅ 添加流动性
    function addLiquidity(address _token, uint256 _amount) external {
        require(_amount > 0, "OptionsProtocol: invalid amount");
        
        LiquidityPool storage pool = liquidityPools[_token];
        
        IERC20(_token).transferFrom(msg.sender, address(this), _amount);
        
        uint256 shares;
        if (pool.totalShares == 0) {
            shares = _amount;
        } else {
            shares = _amount.mul(pool.totalShares).div(pool.totalLiquidity);
        }
        
        pool.userLiquidity[msg.sender] = pool.userLiquidity[msg.sender].add(_amount);
        pool.userShares[msg.sender] = pool.userShares[msg.sender].add(shares);
        pool.totalLiquidity = pool.totalLiquidity.add(_amount);
        pool.availableLiquidity = pool.availableLiquidity.add(_amount);
        pool.totalShares = pool.totalShares.add(shares);
        
        if (address(pool.token) == address(0)) {
            pool.token = IERC20(_token);
        }
        
        emit LiquidityAdded(msg.sender, _token, _amount);
    }
    
    // ✅ 移除流动性
    function removeLiquidity(address _token, uint256 _shares) external {
        LiquidityPool storage pool = liquidityPools[_token];
        
        require(pool.userShares[msg.sender] >= _shares, "OptionsProtocol: insufficient shares");
        
        uint256 amount = _shares.mul(pool.totalLiquidity).div(pool.totalShares);
        require(pool.availableLiquidity >= amount, "OptionsProtocol: insufficient available liquidity");
        
        pool.userShares[msg.sender] = pool.userShares[msg.sender].sub(_shares);
        pool.userLiquidity[msg.sender] = pool.userLiquidity[msg.sender].sub(amount);
        pool.totalShares = pool.totalShares.sub(_shares);
        pool.totalLiquidity = pool.totalLiquidity.sub(amount);
        pool.availableLiquidity = pool.availableLiquidity.sub(amount);
        
        pool.token.transfer(msg.sender, amount);
        
        emit LiquidityRemoved(msg.sender, _token, amount);
    }
    
    // ✅ 计算期权费（Black-Scholes简化版）
    function _calculatePremium(
        address _underlying,
        address _strike,
        uint256 _strikePrice,
        uint256 _amount,
        uint256 _expiration,
        OptionType _optionType
    ) internal view returns (uint256) {
        uint256 currentPrice = assetPrices[_underlying];
        uint256 timeToExpiration = _expiration.sub(block.timestamp).div(SECONDS_PER_DAY);
        
        // 简化的期权定价模型
        uint256 intrinsicValue = 0;
        
        if (_optionType == OptionType.Call && currentPrice > _strikePrice) {
            intrinsicValue = currentPrice.sub(_strikePrice);
        } else if (_optionType == OptionType.Put && _strikePrice > currentPrice) {
            intrinsicValue = _strikePrice.sub(currentPrice);
        }
        
        // 时间价值（简化计算）
        uint256 timeValue = currentPrice.mul(timeToExpiration).div(365).div(10); // 简化的时间衰减
        
        // 波动率调整（固定10%）
        uint256 volatilityAdjustment = currentPrice.div(10);
        
        uint256 premium = intrinsicValue.add(timeValue).add(volatilityAdjustment);
        
        return premium.mul(_amount).div(1e18);
    }
    
    // ✅ 自动行权检查
    function checkAutoExercise(uint256 _optionId) external {
        Option storage option = options[_optionId];
        
        require(option.status == OptionStatus.Active, "OptionsProtocol: option not active");
        require(block.timestamp >= option.expiration, "OptionsProtocol: not yet expired");
        
        uint256 currentPrice = assetPrices[address(option.underlying)];
        bool shouldExercise = false;
        
        if (option.optionType == OptionType.Call && currentPrice > option.strikePrice) {
            shouldExercise = true;
        } else if (option.optionType == OptionType.Put && currentPrice < option.strikePrice) {
            shouldExercise = true;
        }
        
        if (shouldExercise && option.buyer != address(0)) {
            // 自动行权逻辑
            _autoExercise(_optionId);
        } else {
            // 期权过期，释放抵押品
            option.status = OptionStatus.Expired;
            _releaseCollateral(_optionId);
        }
    }
    
    // ✅ 自动行权
    function _autoExercise(uint256 _optionId) internal {
        Option storage option = options[_optionId];
        uint256 currentPrice = assetPrices[address(option.underlying)];
        
        if (option.optionType == OptionType.Call) {
            uint256 profit = currentPrice.sub(option.strikePrice).mul(option.amount).div(1e18);
            
            // 从流动性池支付差价
            LiquidityPool storage pool = liquidityPools[address(option.strike)];
            if (pool.availableLiquidity >= profit) {
                pool.availableLiquidity = pool.availableLiquidity.sub(profit);
                option.strike.transfer(option.buyer, profit);
            }
        } else {
            uint256 profit = option.strikePrice.sub(currentPrice).mul(option.amount).div(1e18);
            
            // 从流动性池支付差价
            LiquidityPool storage pool = liquidityPools[address(option.strike)];
            if (pool.availableLiquidity >= profit) {
                pool.availableLiquidity = pool.availableLiquidity.sub(profit);
                option.strike.transfer(option.buyer, profit);
            }
        }
        
        option.status = OptionStatus.Exercised;
        emit OptionExercised(_optionId, option.buyer, 0);
    }
    
    // ✅ 释放抵押品
    function _releaseCollateral(uint256 _optionId) internal {
        Option storage option = options[_optionId];
        
        if (option.optionType == OptionType.Call) {
            option.underlying.transfer(option.creator, option.amount);
        } else {
            uint256 collateral = option.amount.mul(option.strikePrice).div(1e18);
            option.strike.transfer(option.creator, collateral);
        }
    }
    
    // ✅ 设置资产价格
    function setAssetPrice(address _asset, uint256 _price) external {
        assetPrices[_asset] = _price;
    }
    
    // ✅ 获取期权信息
    function getOptionInfo(uint256 _optionId) external view returns (
        address creator,
        address buyer,
        uint256 strikePrice,
        uint256 premium,
        uint256 amount,
        uint256 expiration,
        OptionType optionType,
        OptionStatus status
    ) {
        Option storage option = options[_optionId];
        return (
            option.creator,
            option.buyer,
            option.strikePrice,
            option.premium,
            option.amount,
            option.expiration,
            option.optionType,
            option.status
        );
    }
    
    // ✅ 获取用户期权列表
    function getUserOptions(address _user) external view returns (uint256[] memory) {
        return userOptions[_user];
    }
    
    // ✅ 获取流动性池信息
    function getPoolInfo(address _token) external view returns (
        uint256 totalLiquidity,
        uint256 availableLiquidity,
        uint256 lockedLiquidity
    ) {
        LiquidityPool storage pool = liquidityPools[_token];
        return (
            pool.totalLiquidity,
            pool.availableLiquidity,
            pool.lockedLiquidity
        );
    }
}
```

### 核心技能掌握
1. **期权机制**：看涨/看跌期权、美式/欧式期权、期权定价
2. **风险管理**：抵押品管理、自动行权、到期处理
3. **流动性提供**：流动性池、收益分配、风险共担

### 项目记录
- 实现了完整的期权交易协议
- 开发了简化的期权定价模型
- 建立了流动性池和风险管理机制

---

## 学习心得与总结

### 核心技术掌握

通过本课程的学习，我在DeFi协议开发方面取得了全面进展：

1. **AMM与DEX开发**
   - 深入理解恒定乘积公式和滑点计算
   - 掌握流动性管理和激励机制设计
   - 实现了多种交换算法和手续费模型

2. **借贷协议架构**
   - 建立了完整的抵押借贷系统
   - 实现了动态利率模型和风险评估
   - 开发了清算机制和健康因子管理

3. **衍生品协议设计**
   - 掌握期权定价和风险管理原理
   - 实现了多种期权类型和行权机制
   - 建立了流动性池和自动化交易系统

### 技术创新点

1. **智能流动性管理**：动态调整流动性分配和奖励机制
2. **多层风险控制**：健康因子、清算阈值、风险评级系统
3. **自动化期权交易**：智能行权、到期处理、收益优化
4. **跨协议组合**：AMM+借贷+期权的综合DeFi生态

### 实践项目成果

1. **SimpleAMM**：基础自动化做市商协议
2. **LiquidityMining**：流动性挖矿激励系统
3. **LendingProtocol**：去中心化借贷平台
4. **OptionsProtocol**：期权交易和衍生品协议

### 未来发展方向

1. **跨链DeFi**：多链部署和跨链流动性聚合
2. **AI驱动优化**：智能定价、风险评估、收益优化
3. **机构级产品**：大额交易、专业工具、合规框架
4. **创新衍生品**：结构化产品、合成资产、保险协议

### 技术栈总结

- **核心框架**：Solidity、OpenZeppelin、Hardhat
- **数学库**：SafeMath、FixedPoint、PRBMath
- **预言机**：Chainlink、Band Protocol、Uniswap TWAP
- **前端集成**：Web3.js、Ethers.js、Wagmi
- **测试工具**：Foundry、Waffle、Tenderly
- **监控分析**：The Graph、Dune Analytics、DefiPulse

---

**文档更新时间**：2024年12月  
**版本**：v1.0  
**学习状态**：持续进行中