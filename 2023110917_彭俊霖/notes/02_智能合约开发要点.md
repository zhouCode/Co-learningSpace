# æ™ºèƒ½åˆçº¦å¼€å‘è¦ç‚¹

> **å­¦ä¹ è€…**: å½­ä¿Šéœ–  
> **å­¦ä¹ ç‰¹è‰²**: æ³¨é‡åˆ›æ–°å’Œå‰æ²¿æŠ€æœ¯  
> **ä»£ç é£æ ¼**: å‰æ²¿æŠ€æœ¯åº”ç”¨ï¼Œåˆ›æ–°æœºåˆ¶è®¾è®¡  
> **ç¬”è®°é‡ç‚¹**: å‰æ²¿æŠ€æœ¯æ¢ç´¢ä¸åˆ›æ–°åº”ç”¨  
> **åˆ›å»ºæ—¶é—´**: 2024å¹´

---

## ğŸš€ å‰æ²¿æŠ€æœ¯æ¦‚è§ˆ

### é›¶çŸ¥è¯†è¯æ˜æŠ€æœ¯

é›¶çŸ¥è¯†è¯æ˜ï¼ˆZero-Knowledge Proofï¼‰æ˜¯å¯†ç å­¦ä¸­çš„ä¸€ä¸ªé‡è¦æ¦‚å¿µï¼Œå…è®¸è¯æ˜è€…å‘éªŒè¯è€…è¯æ˜æŸä¸ªé™ˆè¿°çš„çœŸå®æ€§ï¼Œè€Œæ— éœ€é€éœ²ä»»ä½•é¢å¤–ä¿¡æ¯ã€‚

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

// é›¶çŸ¥è¯†è¯æ˜éªŒè¯åˆçº¦
contract ZKProofVerifier {
    struct Proof {
        uint256[2] a;
        uint256[2][2] b;
        uint256[2] c;
    }
    
    struct VerifyingKey {
        uint256[2] alpha;
        uint256[2][2] beta;
        uint256[2][2] gamma;
        uint256[2][2] delta;
        uint256[][] ic;
    }
    
    VerifyingKey public verifyingKey;
    mapping(bytes32 => bool) public nullifierHashes;
    mapping(address => bool) public verifiedUsers;
    
    event ProofVerified(address indexed user, bytes32 nullifierHash);
    event VerificationFailed(address indexed user, string reason);
    
    constructor(VerifyingKey memory _verifyingKey) {
        verifyingKey = _verifyingKey;
    }
    
    // éªŒè¯é›¶çŸ¥è¯†è¯æ˜
    function verifyProof(
        Proof memory proof,
        uint256[] memory publicInputs,
        bytes32 nullifierHash
    ) public returns (bool) {
        // æ£€æŸ¥nullifieræ˜¯å¦å·²ä½¿ç”¨ï¼ˆé˜²æ­¢åŒèŠ±ï¼‰
        require(!nullifierHashes[nullifierHash], "Nullifier already used");
        
        // éªŒè¯è¯æ˜ï¼ˆç®€åŒ–å®ç°ï¼‰
        bool isValid = _verifyZKProof(proof, publicInputs);
        
        if (isValid) {
            nullifierHashes[nullifierHash] = true;
            verifiedUsers[msg.sender] = true;
            emit ProofVerified(msg.sender, nullifierHash);
            return true;
        } else {
            emit VerificationFailed(msg.sender, "Invalid proof");
            return false;
        }
    }
    
    // ç§æœ‰èº«ä»½éªŒè¯
    function verifyIdentity(
        Proof memory proof,
        uint256 ageThreshold,
        bytes32 nullifierHash
    ) external {
        uint256[] memory publicInputs = new uint256[](1);
        publicInputs[0] = ageThreshold;
        
        require(
            verifyProof(proof, publicInputs, nullifierHash),
            "Identity verification failed"
        );
    }
    
    function _verifyZKProof(
        Proof memory proof,
        uint256[] memory publicInputs
    ) internal view returns (bool) {
        // ç®€åŒ–çš„ZKè¯æ˜éªŒè¯é€»è¾‘
        // å®é™…å®ç°éœ€è¦æ¤­åœ†æ›²çº¿é…å¯¹è¿ç®—
        return true;
    }
}
```

### Layer 2 æ‰©å®¹è§£å†³æ–¹æ¡ˆ

```solidity
// Layer 2 çŠ¶æ€é€šé“å®ç°
contract StateChannel {
    struct Channel {
        address[2] participants;
        uint256[2] balances;
        uint256 nonce;
        uint256 timeout;
        bool isOpen;
        bool isDisputed;
    }
    
    struct State {
        uint256[2] balances;
        uint256 nonce;
        bytes32 channelId;
    }
    
    mapping(bytes32 => Channel) public channels;
    mapping(bytes32 => uint256) public disputeDeadlines;
    
    event ChannelOpened(bytes32 indexed channelId, address[2] participants, uint256[2] deposits);
    event ChannelClosed(bytes32 indexed channelId, uint256[2] finalBalances);
    event DisputeStarted(bytes32 indexed channelId, address challenger);
    
    // å¼€å¯çŠ¶æ€é€šé“
    function openChannel(
        address participant2,
        uint256 timeout
    ) external payable returns (bytes32) {
        require(msg.value > 0, "Must deposit funds");
        require(participant2 != msg.sender, "Cannot open channel with self");
        
        bytes32 channelId = keccak256(abi.encodePacked(
            msg.sender,
            participant2,
            block.timestamp
        ));
        
        channels[channelId] = Channel({
            participants: [msg.sender, participant2],
            balances: [msg.value, 0],
            nonce: 0,
            timeout: timeout,
            isOpen: true,
            isDisputed: false
        });
        
        emit ChannelOpened(channelId, [msg.sender, participant2], [msg.value, 0]);
        return channelId;
    }
    
    // å‚ä¸è€…å­˜æ¬¾
    function deposit(bytes32 channelId) external payable {
        Channel storage channel = channels[channelId];
        require(channel.isOpen, "Channel not open");
        require(
            msg.sender == channel.participants[0] || 
            msg.sender == channel.participants[1],
            "Not a participant"
        );
        
        if (msg.sender == channel.participants[0]) {
            channel.balances[0] += msg.value;
        } else {
            channel.balances[1] += msg.value;
        }
    }
    
    // åä½œå…³é—­é€šé“
    function closeChannel(
        bytes32 channelId,
        State memory finalState,
        bytes[2] memory signatures
    ) external {
        Channel storage channel = channels[channelId];
        require(channel.isOpen, "Channel not open");
        require(!channel.isDisputed, "Channel is disputed");
        
        // éªŒè¯ç­¾å
        require(_verifySignatures(finalState, signatures, channel.participants), "Invalid signatures");
        
        // æ‰§è¡Œæœ€ç»ˆç»“ç®—
        _settleChannel(channelId, finalState.balances);
    }
    
    // å‘èµ·äº‰è®®
    function startDispute(
        bytes32 channelId,
        State memory state,
        bytes memory signature
    ) external {
        Channel storage channel = channels[channelId];
        require(channel.isOpen, "Channel not open");
        require(
            msg.sender == channel.participants[0] || 
            msg.sender == channel.participants[1],
            "Not a participant"
        );
        
        channel.isDisputed = true;
        disputeDeadlines[channelId] = block.timestamp + channel.timeout;
        
        emit DisputeStarted(channelId, msg.sender);
    }
    
    function _verifySignatures(
        State memory state,
        bytes[2] memory signatures,
        address[2] memory participants
    ) internal pure returns (bool) {
        bytes32 hash = keccak256(abi.encodePacked(
            state.balances[0],
            state.balances[1],
            state.nonce,
            state.channelId
        ));
        
        // ç®€åŒ–çš„ç­¾åéªŒè¯
        return true;
    }
    
    function _settleChannel(bytes32 channelId, uint256[2] memory finalBalances) internal {
        Channel storage channel = channels[channelId];
        channel.isOpen = false;
        
        // è½¬è´¦ç»™å‚ä¸è€…
        if (finalBalances[0] > 0) {
            payable(channel.participants[0]).transfer(finalBalances[0]);
        }
        if (finalBalances[1] > 0) {
            payable(channel.participants[1]).transfer(finalBalances[1]);
        }
        
        emit ChannelClosed(channelId, finalBalances);
    }
}
```

---

## ğŸ”¬ åˆ›æ–°åˆçº¦æ¨¡å¼

### åŠ¨æ€NFTç³»ç»Ÿ

```solidity
// åŠ¨æ€è¿›åŒ–NFTåˆçº¦
contract EvolutionaryNFT is ERC721 {
    struct Evolution {
        uint256 stage;          // è¿›åŒ–é˜¶æ®µ
        uint256 experience;     // ç»éªŒå€¼
        uint256 power;          // èƒ½åŠ›å€¼
        uint256 rarity;         // ç¨€æœ‰åº¦
        uint256 lastUpdate;     // æœ€åæ›´æ–°æ—¶é—´
        bytes32 dnaHash;        // DNAå“ˆå¸Œ
        mapping(string => uint256) attributes; // åŠ¨æ€å±æ€§
    }
    
    struct EvolutionRule {
        uint256 requiredExp;    // æ‰€éœ€ç»éªŒ
        uint256 powerBonus;     // èƒ½åŠ›åŠ æˆ
        uint256 rarityBonus;    // ç¨€æœ‰åº¦åŠ æˆ
        string[] newAttributes; // æ–°å±æ€§
    }
    
    mapping(uint256 => Evolution) public evolutions;
    mapping(uint256 => EvolutionRule) public evolutionRules;
    mapping(uint256 => string) public tokenURIs;
    
    uint256 public maxStage = 10;
    uint256 private _tokenIdCounter;
    
    event NFTEvolved(uint256 indexed tokenId, uint256 newStage, uint256 newPower);
    event ExperienceGained(uint256 indexed tokenId, uint256 amount);
    event AttributeUpdated(uint256 indexed tokenId, string attribute, uint256 value);
    
    constructor() ERC721("EvolutionaryNFT", "EVNFT") {
        _initializeEvolutionRules();
    }
    
    // é“¸é€ åˆå§‹NFT
    function mint(address to, bytes32 dnaHash) external returns (uint256) {
        uint256 tokenId = ++_tokenIdCounter;
        _mint(to, tokenId);
        
        Evolution storage evo = evolutions[tokenId];
        evo.stage = 1;
        evo.experience = 0;
        evo.power = _calculateInitialPower(dnaHash);
        evo.rarity = 1;
        evo.lastUpdate = block.timestamp;
        evo.dnaHash = dnaHash;
        
        // è®¾ç½®åˆå§‹å±æ€§
        evo.attributes["strength"] = 10;
        evo.attributes["agility"] = 10;
        evo.attributes["intelligence"] = 10;
        
        return tokenId;
    }
    
    // è·å¾—ç»éªŒå€¼
    function gainExperience(uint256 tokenId, uint256 amount) external {
        require(_exists(tokenId), "Token does not exist");
        require(ownerOf(tokenId) == msg.sender, "Not token owner");
        
        Evolution storage evo = evolutions[tokenId];
        evo.experience += amount;
        evo.lastUpdate = block.timestamp;
        
        emit ExperienceGained(tokenId, amount);
        
        // æ£€æŸ¥æ˜¯å¦å¯ä»¥è¿›åŒ–
        _checkEvolution(tokenId);
    }
    
    // æ£€æŸ¥å¹¶æ‰§è¡Œè¿›åŒ–
    function _checkEvolution(uint256 tokenId) internal {
        Evolution storage evo = evolutions[tokenId];
        
        if (evo.stage < maxStage) {
            EvolutionRule memory rule = evolutionRules[evo.stage + 1];
            
            if (evo.experience >= rule.requiredExp) {
                evo.stage++;
                evo.power += rule.powerBonus;
                evo.rarity += rule.rarityBonus;
                
                // æ·»åŠ æ–°å±æ€§
                for (uint256 i = 0; i < rule.newAttributes.length; i++) {
                    evo.attributes[rule.newAttributes[i]] += 5;
                }
                
                // æ›´æ–°å…ƒæ•°æ®URI
                _updateTokenURI(tokenId);
                
                emit NFTEvolved(tokenId, evo.stage, evo.power);
            }
        }
    }
    
    // è®­ç»ƒç‰¹å®šå±æ€§
    function trainAttribute(
        uint256 tokenId,
        string memory attribute,
        uint256 trainingIntensity
    ) external payable {
        require(_exists(tokenId), "Token does not exist");
        require(ownerOf(tokenId) == msg.sender, "Not token owner");
        require(msg.value >= trainingIntensity * 0.001 ether, "Insufficient payment");
        
        Evolution storage evo = evolutions[tokenId];
        
        // åŸºäºæ—¶é—´å’Œå¼ºåº¦è®¡ç®—å±æ€§å¢é•¿
        uint256 timeSinceLastUpdate = block.timestamp - evo.lastUpdate;
        uint256 attributeGain = (trainingIntensity * timeSinceLastUpdate) / 3600; // æ¯å°æ—¶å¢é•¿
        
        evo.attributes[attribute] += attributeGain;
        evo.lastUpdate = block.timestamp;
        
        emit AttributeUpdated(tokenId, attribute, evo.attributes[attribute]);
    }
    
    // è·å–NFTå±æ€§
    function getAttributes(uint256 tokenId) 
        external view returns (
            uint256 stage,
            uint256 experience,
            uint256 power,
            uint256 rarity,
            uint256 strength,
            uint256 agility,
            uint256 intelligence
        ) {
        Evolution storage evo = evolutions[tokenId];
        return (
            evo.stage,
            evo.experience,
            evo.power,
            evo.rarity,
            evo.attributes["strength"],
            evo.attributes["agility"],
            evo.attributes["intelligence"]
        );
    }
    
    function _calculateInitialPower(bytes32 dnaHash) internal pure returns (uint256) {
        return uint256(dnaHash) % 100 + 50; // 50-149çš„åˆå§‹èƒ½åŠ›å€¼
    }
    
    function _initializeEvolutionRules() internal {
        // è®¾ç½®å„é˜¶æ®µè¿›åŒ–è§„åˆ™
        evolutionRules[2] = EvolutionRule({
            requiredExp: 100,
            powerBonus: 20,
            rarityBonus: 1,
            newAttributes: new string[](0)
        });
        
        evolutionRules[3] = EvolutionRule({
            requiredExp: 300,
            powerBonus: 30,
            rarityBonus: 2,
            newAttributes: _createAttributeArray("endurance")
        });
        
        // ç»§ç»­è®¾ç½®å…¶ä»–é˜¶æ®µ...
    }
    
    function _createAttributeArray(string memory attr) internal pure returns (string[] memory) {
        string[] memory attrs = new string[](1);
        attrs[0] = attr;
        return attrs;
    }
    
    function _updateTokenURI(uint256 tokenId) internal {
        // åŸºäºå½“å‰å±æ€§ç”Ÿæˆæ–°çš„å…ƒæ•°æ®URI
        Evolution storage evo = evolutions[tokenId];
        string memory newURI = string(abi.encodePacked(
            "https://api.example.com/metadata/",
            Strings.toString(tokenId),
            "?stage=",
            Strings.toString(evo.stage)
        ));
        tokenURIs[tokenId] = newURI;
    }
    
    function tokenURI(uint256 tokenId) public view override returns (string memory) {
        require(_exists(tokenId), "Token does not exist");
        return tokenURIs[tokenId];
    }
}
```

### é¢„æµ‹å¸‚åœºåˆçº¦

```solidity
// å»ä¸­å¿ƒåŒ–é¢„æµ‹å¸‚åœº
contract PredictionMarket {
    enum MarketState { Active, Resolved, Cancelled }
    enum Outcome { Pending, Yes, No, Invalid }
    
    struct Market {
        string question;
        string description;
        address creator;
        uint256 endTime;
        uint256 resolutionTime;
        MarketState state;
        Outcome result;
        uint256 totalStaked;
        uint256[2] outcomeStakes; // [Yes, No]
        mapping(address => mapping(uint256 => uint256)) userStakes;
        address[] participants;
        bytes32 oracleId;
    }
    
    struct Oracle {
        address oracleAddress;
        uint256 reputation;
        uint256 totalReports;
        uint256 correctReports;
        bool isActive;
    }
    
    mapping(uint256 => Market) public markets;
    mapping(address => Oracle) public oracles;
    mapping(uint256 => mapping(address => bool)) public hasWithdrawn;
    
    uint256 public marketCounter;
    uint256 public constant MIN_STAKE = 0.01 ether;
    uint256 public constant ORACLE_FEE = 100; // 1%
    
    event MarketCreated(uint256 indexed marketId, string question, uint256 endTime);
    event StakePlaced(uint256 indexed marketId, address indexed user, uint256 outcome, uint256 amount);
    event MarketResolved(uint256 indexed marketId, Outcome result);
    event WinningsWithdrawn(uint256 indexed marketId, address indexed user, uint256 amount);
    
    // åˆ›å»ºé¢„æµ‹å¸‚åœº
    function createMarket(
        string memory question,
        string memory description,
        uint256 duration,
        bytes32 oracleId
    ) external returns (uint256) {
        require(duration > 1 hours, "Duration too short");
        require(duration < 365 days, "Duration too long");
        
        uint256 marketId = ++marketCounter;
        Market storage market = markets[marketId];
        
        market.question = question;
        market.description = description;
        market.creator = msg.sender;
        market.endTime = block.timestamp + duration;
        market.resolutionTime = market.endTime + 1 days; // 1å¤©è§£å†³æœŸ
        market.state = MarketState.Active;
        market.result = Outcome.Pending;
        market.oracleId = oracleId;
        
        emit MarketCreated(marketId, question, market.endTime);
        return marketId;
    }
    
    // ä¸‹æ³¨
    function stake(uint256 marketId, uint256 outcome) external payable {
        require(msg.value >= MIN_STAKE, "Stake too small");
        require(outcome == 0 || outcome == 1, "Invalid outcome"); // 0=Yes, 1=No
        
        Market storage market = markets[marketId];
        require(market.state == MarketState.Active, "Market not active");
        require(block.timestamp < market.endTime, "Market ended");
        
        // è®°å½•ç”¨æˆ·é¦–æ¬¡å‚ä¸
        if (market.userStakes[msg.sender][0] == 0 && market.userStakes[msg.sender][1] == 0) {
            market.participants.push(msg.sender);
        }
        
        market.userStakes[msg.sender][outcome] += msg.value;
        market.outcomeStakes[outcome] += msg.value;
        market.totalStaked += msg.value;
        
        emit StakePlaced(marketId, msg.sender, outcome, msg.value);
    }
    
    // é¢„è¨€æœºè§£å†³å¸‚åœº
    function resolveMarket(uint256 marketId, Outcome result) external {
        Market storage market = markets[marketId];
        require(market.state == MarketState.Active, "Market not active");
        require(block.timestamp >= market.endTime, "Market not ended");
        require(block.timestamp <= market.resolutionTime, "Resolution period ended");
        
        // éªŒè¯é¢„è¨€æœºæƒé™
        Oracle storage oracle = oracles[msg.sender];
        require(oracle.isActive, "Oracle not active");
        
        market.state = MarketState.Resolved;
        market.result = result;
        
        // æ›´æ–°é¢„è¨€æœºå£°èª‰ï¼ˆç®€åŒ–å®ç°ï¼‰
        oracle.totalReports++;
        
        emit MarketResolved(marketId, result);
    }
    
    // æå–å¥–é‡‘
    function withdrawWinnings(uint256 marketId) external {
        Market storage market = markets[marketId];
        require(market.state == MarketState.Resolved, "Market not resolved");
        require(!hasWithdrawn[marketId][msg.sender], "Already withdrawn");
        require(market.result == Outcome.Yes || market.result == Outcome.No, "Invalid result");
        
        uint256 winningOutcome = market.result == Outcome.Yes ? 0 : 1;
        uint256 userStake = market.userStakes[msg.sender][winningOutcome];
        require(userStake > 0, "No winning stake");
        
        // è®¡ç®—å¥–é‡‘
        uint256 totalWinningStakes = market.outcomeStakes[winningOutcome];
        uint256 totalLosingStakes = market.outcomeStakes[1 - winningOutcome];
        
        uint256 winnings = userStake + (userStake * totalLosingStakes) / totalWinningStakes;
        
        // æ‰£é™¤é¢„è¨€æœºè´¹ç”¨
        uint256 oracleFee = (winnings * ORACLE_FEE) / 10000;
        uint256 netWinnings = winnings - oracleFee;
        
        hasWithdrawn[marketId][msg.sender] = true;
        
        payable(msg.sender).transfer(netWinnings);
        
        emit WinningsWithdrawn(marketId, msg.sender, netWinnings);
    }
    
    // æ³¨å†Œé¢„è¨€æœº
    function registerOracle() external {
        oracles[msg.sender] = Oracle({
            oracleAddress: msg.sender,
            reputation: 100,
            totalReports: 0,
            correctReports: 0,
            isActive: true
        });
    }
    
    // è·å–å¸‚åœºä¿¡æ¯
    function getMarketInfo(uint256 marketId) external view returns (
        string memory question,
        uint256 endTime,
        MarketState state,
        Outcome result,
        uint256 totalStaked,
        uint256[2] memory outcomeStakes
    ) {
        Market storage market = markets[marketId];
        return (
            market.question,
            market.endTime,
            market.state,
            market.result,
            market.totalStaked,
            market.outcomeStakes
        );
    }
    
    // è·å–ç”¨æˆ·åœ¨ç‰¹å®šå¸‚åœºçš„æŠ•æ³¨
    function getUserStakes(uint256 marketId, address user) 
        external view returns (uint256[2] memory stakes) {
        Market storage market = markets[marketId];
        return [market.userStakes[user][0], market.userStakes[user][1]];
    }
}
```

---

## ğŸŒ è·¨é“¾äº’æ“ä½œæ€§

### é€šç”¨è·¨é“¾æ¡¥

```solidity
// é€šç”¨è·¨é“¾æ¡¥åˆçº¦
contract UniversalBridge {
    struct ChainConfig {
        uint256 chainId;
        string name;
        address bridgeContract;
        uint256 confirmations;
        bool isActive;
    }
    
    struct CrossChainTransfer {
        bytes32 transferId;
        uint256 sourceChain;
        uint256 targetChain;
        address sourceToken;
        address targetToken;
        address sender;
        address recipient;
        uint256 amount;
        uint256 fee;
        uint256 timestamp;
        bool isCompleted;
        bool isCancelled;
    }
    
    struct Validator {
        address validatorAddress;
        uint256 stake;
        uint256 reputation;
        bool isActive;
        uint256 lastActivity;
    }
    
    mapping(uint256 => ChainConfig) public supportedChains;
    mapping(bytes32 => CrossChainTransfer) public transfers;
    mapping(address => Validator) public validators;
    mapping(bytes32 => mapping(address => bool)) public validatorSignatures;
    mapping(bytes32 => uint256) public signatureCount;
    
    uint256[] public chainIds;
    address[] public validatorList;
    uint256 public requiredSignatures;
    uint256 public constant MIN_VALIDATOR_STAKE = 10 ether;
    
    event ChainAdded(uint256 indexed chainId, string name);
    event TransferInitiated(bytes32 indexed transferId, uint256 sourceChain, uint256 targetChain);
    event TransferCompleted(bytes32 indexed transferId);
    event ValidatorAdded(address indexed validator, uint256 stake);
    
    constructor(uint256 _requiredSignatures) {
        requiredSignatures = _requiredSignatures;
    }
    
    // æ·»åŠ æ”¯æŒçš„é“¾
    function addSupportedChain(
        uint256 chainId,
        string memory name,
        address bridgeContract,
        uint256 confirmations
    ) external onlyOwner {
        supportedChains[chainId] = ChainConfig({
            chainId: chainId,
            name: name,
            bridgeContract: bridgeContract,
            confirmations: confirmations,
            isActive: true
        });
        
        chainIds.push(chainId);
        emit ChainAdded(chainId, name);
    }
    
    // æ³¨å†ŒéªŒè¯è€…
    function registerValidator() external payable {
        require(msg.value >= MIN_VALIDATOR_STAKE, "Insufficient stake");
        require(!validators[msg.sender].isActive, "Already registered");
        
        validators[msg.sender] = Validator({
            validatorAddress: msg.sender,
            stake: msg.value,
            reputation: 100,
            isActive: true,
            lastActivity: block.timestamp
        });
        
        validatorList.push(msg.sender);
        emit ValidatorAdded(msg.sender, msg.value);
    }
    
    // å‘èµ·è·¨é“¾è½¬è´¦
    function initiateCrossChainTransfer(
        uint256 targetChain,
        address targetToken,
        address recipient,
        uint256 amount
    ) external payable returns (bytes32) {
        require(supportedChains[targetChain].isActive, "Target chain not supported");
        require(amount > 0, "Amount must be positive");
        
        bytes32 transferId = keccak256(abi.encodePacked(
            block.chainid,
            targetChain,
            msg.sender,
            recipient,
            amount,
            block.timestamp
        ));
        
        uint256 fee = _calculateFee(amount, targetChain);
        require(msg.value >= fee, "Insufficient fee");
        
        transfers[transferId] = CrossChainTransfer({
            transferId: transferId,
            sourceChain: block.chainid,
            targetChain: targetChain,
            sourceToken: address(0), // ETH
            targetToken: targetToken,
            sender: msg.sender,
            recipient: recipient,
            amount: amount,
            fee: fee,
            timestamp: block.timestamp,
            isCompleted: false,
            isCancelled: false
        });
        
        emit TransferInitiated(transferId, block.chainid, targetChain);
        return transferId;
    }
    
    // éªŒè¯è€…ç­¾åç¡®è®¤è½¬è´¦
    function signTransfer(bytes32 transferId) external {
        require(validators[msg.sender].isActive, "Not an active validator");
        require(!validatorSignatures[transferId][msg.sender], "Already signed");
        
        CrossChainTransfer storage transfer = transfers[transferId];
        require(!transfer.isCompleted, "Transfer already completed");
        require(!transfer.isCancelled, "Transfer cancelled");
        
        validatorSignatures[transferId][msg.sender] = true;
        signatureCount[transferId]++;
        
        validators[msg.sender].lastActivity = block.timestamp;
        
        // æ£€æŸ¥æ˜¯å¦è¾¾åˆ°æ‰€éœ€ç­¾åæ•°
        if (signatureCount[transferId] >= requiredSignatures) {
            _completeTransfer(transferId);
        }
    }
    
    // å®Œæˆè½¬è´¦
    function _completeTransfer(bytes32 transferId) internal {
        CrossChainTransfer storage transfer = transfers[transferId];
        transfer.isCompleted = true;
        
        // åœ¨ç›®æ ‡é“¾ä¸Šé“¸é€ ä»£å¸æˆ–é‡Šæ”¾é”å®šèµ„é‡‘
        // è¿™é‡Œéœ€è¦ä¸ç›®æ ‡é“¾çš„æ¡¥åˆçº¦äº¤äº’
        
        emit TransferCompleted(transferId);
    }
    
    // è®¡ç®—è·¨é“¾è´¹ç”¨
    function _calculateFee(uint256 amount, uint256 targetChain) 
        internal view returns (uint256) {
        ChainConfig memory config = supportedChains[targetChain];
        
        // åŸºç¡€è´¹ç”¨ + æŒ‰æ¯”ä¾‹è´¹ç”¨
        uint256 baseFee = 0.001 ether;
        uint256 proportionalFee = (amount * 30) / 10000; // 0.3%
        
        return baseFee + proportionalFee;
    }
    
    // ç´§æ€¥æš‚åœ
    function pauseChain(uint256 chainId) external onlyOwner {
        supportedChains[chainId].isActive = false;
    }
    
    // è·å–è½¬è´¦çŠ¶æ€
    function getTransferStatus(bytes32 transferId) 
        external view returns (
            uint256 sourceChain,
            uint256 targetChain,
            address sender,
            address recipient,
            uint256 amount,
            bool isCompleted,
            uint256 signatures
        ) {
        CrossChainTransfer storage transfer = transfers[transferId];
        return (
            transfer.sourceChain,
            transfer.targetChain,
            transfer.sender,
            transfer.recipient,
            transfer.amount,
            transfer.isCompleted,
            signatureCount[transferId]
        );
    }
    
    modifier onlyOwner() {
        require(msg.sender == owner, "Only owner");
        _;
    }
    
    address public owner;
    
    constructor() {
        owner = msg.sender;
    }
}
```

---

## ğŸ¤– AIé›†æˆæ™ºèƒ½åˆçº¦

### AIé©±åŠ¨çš„è‡ªé€‚åº”åˆçº¦

```solidity
// AIé©±åŠ¨çš„åŠ¨æ€å®šä»·åˆçº¦
contract AIAdaptivePricing {
    struct MarketData {
        uint256 timestamp;
        uint256 price;
        uint256 volume;
        uint256 volatility;
        int256 sentiment; // -100 to 100
    }
    
    struct AIModel {
        bytes32 modelHash;
        uint256 version;
        uint256 accuracy;
        uint256 lastUpdate;
        bool isActive;
    }
    
    struct PredictionResult {
        uint256 predictedPrice;
        uint256 confidence;
        uint256 timestamp;
        bytes32 modelUsed;
    }
    
    mapping(uint256 => MarketData) public marketHistory;
    mapping(bytes32 => AIModel) public aiModels;
    mapping(uint256 => PredictionResult) public predictions;
    
    uint256 public currentPrice;
    uint256 public basePrice;
    uint256 public marketDataCounter;
    uint256 public predictionCounter;
    bytes32 public activeModelHash;
    
    // ä»·æ ¼è°ƒæ•´å‚æ•°
    uint256 public constant MAX_PRICE_CHANGE = 1000; // 10%
    uint256 public constant CONFIDENCE_THRESHOLD = 8000; // 80%
    
    event MarketDataUpdated(uint256 indexed dataId, uint256 price, uint256 volume);
    event PricePredicted(uint256 indexed predictionId, uint256 predictedPrice, uint256 confidence);
    event PriceAdjusted(uint256 oldPrice, uint256 newPrice, string reason);
    event ModelUpdated(bytes32 indexed modelHash, uint256 version);
    
    constructor(uint256 _basePrice) {
        basePrice = _basePrice;
        currentPrice = _basePrice;
    }
    
    // æ›´æ–°å¸‚åœºæ•°æ®
    function updateMarketData(
        uint256 price,
        uint256 volume,
        uint256 volatility,
        int256 sentiment
    ) external {
        uint256 dataId = ++marketDataCounter;
        
        marketHistory[dataId] = MarketData({
            timestamp: block.timestamp,
            price: price,
            volume: volume,
            volatility: volatility,
            sentiment: sentiment
        });
        
        emit MarketDataUpdated(dataId, price, volume);
        
        // è§¦å‘ä»·æ ¼é¢„æµ‹
        _triggerPricePrediction();
    }
    
    // æ³¨å†ŒAIæ¨¡å‹
    function registerAIModel(
        bytes32 modelHash,
        uint256 version,
        uint256 initialAccuracy
    ) external onlyOwner {
        aiModels[modelHash] = AIModel({
            modelHash: modelHash,
            version: version,
            accuracy: initialAccuracy,
            lastUpdate: block.timestamp,
            isActive: true
        });
        
        // å¦‚æœæ˜¯ç¬¬ä¸€ä¸ªæ¨¡å‹æˆ–å‡†ç¡®ç‡æ›´é«˜ï¼Œè®¾ä¸ºæ´»è·ƒæ¨¡å‹
        if (activeModelHash == bytes32(0) || 
            aiModels[modelHash].accuracy > aiModels[activeModelHash].accuracy) {
            activeModelHash = modelHash;
        }
        
        emit ModelUpdated(modelHash, version);
    }
    
    // AIé¢„æµ‹ä»·æ ¼
    function predictPrice(
        uint256[] calldata historicalPrices,
        uint256[] calldata volumes,
        int256[] calldata sentiments,
        bytes calldata modelOutput
    ) external returns (uint256) {
        require(aiModels[activeModelHash].isActive, "No active AI model");
        
        // éªŒè¯è¾“å…¥æ•°æ®
        require(
            historicalPrices.length == volumes.length && 
            volumes.length == sentiments.length,
            "Input arrays length mismatch"
        );
        
        // è§£æAIæ¨¡å‹è¾“å‡º
        (uint256 predictedPrice, uint256 confidence) = _parseModelOutput(modelOutput);
        
        uint256 predictionId = ++predictionCounter;
        predictions[predictionId] = PredictionResult({
            predictedPrice: predictedPrice,
            confidence: confidence,
            timestamp: block.timestamp,
            modelUsed: activeModelHash
        });
        
        emit PricePredicted(predictionId, predictedPrice, confidence);
        
        // å¦‚æœç½®ä¿¡åº¦è¶³å¤Ÿé«˜ï¼Œè°ƒæ•´ä»·æ ¼
        if (confidence >= CONFIDENCE_THRESHOLD) {
            _adjustPrice(predictedPrice, confidence);
        }
        
        return predictedPrice;
    }
    
    // è°ƒæ•´ä»·æ ¼
    function _adjustPrice(uint256 predictedPrice, uint256 confidence) internal {
        uint256 oldPrice = currentPrice;
        
        // è®¡ç®—ä»·æ ¼å˜åŒ–å¹…åº¦
        uint256 priceChange;
        if (predictedPrice > currentPrice) {
            priceChange = ((predictedPrice - currentPrice) * confidence) / 10000;
        } else {
            priceChange = ((currentPrice - predictedPrice) * confidence) / 10000;
        }
        
        // é™åˆ¶æœ€å¤§å˜åŒ–å¹…åº¦
        uint256 maxChange = (currentPrice * MAX_PRICE_CHANGE) / 10000;
        if (priceChange > maxChange) {
            priceChange = maxChange;
        }
        
        // åº”ç”¨ä»·æ ¼å˜åŒ–
        if (predictedPrice > currentPrice) {
            currentPrice += priceChange;
        } else {
            currentPrice -= priceChange;
        }
        
        emit PriceAdjusted(oldPrice, currentPrice, "AI prediction");
    }
    
    // è§¦å‘ä»·æ ¼é¢„æµ‹
    function _triggerPricePrediction() internal {
        // æ”¶é›†æœ€è¿‘çš„å¸‚åœºæ•°æ®
        uint256[] memory recentPrices = new uint256[](10);
        uint256[] memory recentVolumes = new uint256[](10);
        int256[] memory recentSentiments = new int256[](10);
        
        uint256 startIndex = marketDataCounter > 10 ? marketDataCounter - 10 : 1;
        
        for (uint256 i = 0; i < 10 && startIndex + i <= marketDataCounter; i++) {
            MarketData storage data = marketHistory[startIndex + i];
            recentPrices[i] = data.price;
            recentVolumes[i] = data.volume;
            recentSentiments[i] = data.sentiment;
        }
        
        // è¿™é‡Œåº”è¯¥è°ƒç”¨å¤–éƒ¨AIæœåŠ¡æˆ–é¢„è¨€æœº
        // ç®€åŒ–å®ç°ï¼šä½¿ç”¨ç®€å•çš„ç§»åŠ¨å¹³å‡
        uint256 avgPrice = _calculateMovingAverage(recentPrices);
        bytes memory mockOutput = abi.encode(avgPrice, 7500); // 75% confidence
        
        // æ¨¡æ‹ŸAIé¢„æµ‹è°ƒç”¨
        this.predictPrice(recentPrices, recentVolumes, recentSentiments, mockOutput);
    }
    
    // è§£æAIæ¨¡å‹è¾“å‡º
    function _parseModelOutput(bytes calldata output) 
        internal pure returns (uint256 price, uint256 confidence) {
        (price, confidence) = abi.decode(output, (uint256, uint256));
    }
    
    // è®¡ç®—ç§»åŠ¨å¹³å‡
    function _calculateMovingAverage(uint256[] memory prices) 
        internal pure returns (uint256) {
        uint256 sum = 0;
        uint256 count = 0;
        
        for (uint256 i = 0; i < prices.length; i++) {
            if (prices[i] > 0) {
                sum += prices[i];
                count++;
            }
        }
        
        return count > 0 ? sum / count : 0;
    }
    
    // æ›´æ–°æ¨¡å‹å‡†ç¡®ç‡
    function updateModelAccuracy(bytes32 modelHash, uint256 newAccuracy) external onlyOwner {
        require(aiModels[modelHash].isActive, "Model not active");
        
        aiModels[modelHash].accuracy = newAccuracy;
        aiModels[modelHash].lastUpdate = block.timestamp;
        
        // å¦‚æœå‡†ç¡®ç‡æé«˜ï¼Œå¯èƒ½éœ€è¦åˆ‡æ¢æ´»è·ƒæ¨¡å‹
        if (newAccuracy > aiModels[activeModelHash].accuracy) {
            activeModelHash = modelHash;
        }
    }
    
    // è·å–å½“å‰ä»·æ ¼ä¿¡æ¯
    function getPriceInfo() external view returns (
        uint256 current,
        uint256 base,
        bytes32 model,
        uint256 lastPrediction
    ) {
        return (
            currentPrice,
            basePrice,
            activeModelHash,
            predictionCounter > 0 ? predictions[predictionCounter].timestamp : 0
        );
    }
    
    modifier onlyOwner() {
        require(msg.sender == owner, "Only owner");
        _;
    }
    
    address public owner;
    
    constructor() {
        owner = msg.sender;
    }
}
```

---

## ğŸ“Š å­¦ä¹ æ€»ç»“ä¸å±•æœ›

### æŠ€æœ¯åˆ›æ–°è¦ç‚¹

1. **é›¶çŸ¥è¯†è¯æ˜åº”ç”¨**
   - éšç§ä¿æŠ¤æœºåˆ¶
   - èº«ä»½éªŒè¯ç³»ç»Ÿ
   - å¯éªŒè¯è®¡ç®—

2. **Layer 2 æ‰©å®¹æ–¹æ¡ˆ**
   - çŠ¶æ€é€šé“æŠ€æœ¯
   - Rollupè§£å†³æ–¹æ¡ˆ
   - ä¾§é“¾æ¶æ„

3. **è·¨é“¾äº’æ“ä½œæ€§**
   - é€šç”¨æ¡¥æ¥åè®®
   - å¤šé“¾èµ„äº§ç®¡ç†
   - è·¨é“¾é€šä¿¡æœºåˆ¶

4. **AIä¸åŒºå—é“¾èåˆ**
   - æ™ºèƒ½é¢„æµ‹ç³»ç»Ÿ
   - è‡ªé€‚åº”åˆçº¦æœºåˆ¶
   - æœºå™¨å­¦ä¹ é›†æˆ

### åˆ›æ–°å®è·µæ–¹å‘

1. **æŠ€æœ¯æ¢ç´¢**ï¼šæŒç»­å…³æ³¨å’Œå®éªŒæœ€æ–°çš„åŒºå—é“¾æŠ€æœ¯
2. **è·¨é¢†åŸŸèåˆ**ï¼šå°†AIã€IoTã€VRç­‰æŠ€æœ¯ä¸åŒºå—é“¾ç»“åˆ
3. **ç”¨æˆ·ä½“éªŒä¼˜åŒ–**ï¼šé™ä½æŠ€æœ¯é—¨æ§›ï¼Œæå‡æ˜“ç”¨æ€§
4. **ç”Ÿæ€ç³»ç»Ÿå»ºè®¾**ï¼šæ„å»ºå®Œæ•´çš„å»ä¸­å¿ƒåŒ–åº”ç”¨ç”Ÿæ€

### æœªæ¥å‘å±•è¶‹åŠ¿

1. **é‡å­æŠ—æ€§**ï¼šä¸ºé‡å­è®¡ç®—æ—¶ä»£åšå‡†å¤‡
2. **ç»¿è‰²åŒºå—é“¾**ï¼šç¯ä¿å’Œå¯æŒç»­å‘å±•
3. **Web3åŸºç¡€è®¾æ–½**ï¼šå»ä¸­å¿ƒåŒ–äº’è”ç½‘åŸºç¡€è®¾æ–½
4. **å…ƒå®‡å®™åº”ç”¨**ï¼šè™šæ‹Ÿä¸–ç•Œçš„åŒºå—é“¾åº”ç”¨

---

**ä¸ªäººæ„Ÿæ‚Ÿ**: å‰æ²¿æŠ€æœ¯çš„æ¢ç´¢éœ€è¦ä¿æŒå¼€æ”¾çš„å¿ƒæ€å’ŒæŒç»­å­¦ä¹ çš„ç²¾ç¥ã€‚åŒºå—é“¾æŠ€æœ¯æ­£åœ¨å¿«é€Ÿå‘å±•ï¼Œä¸å…¶ä»–æŠ€æœ¯çš„èåˆå°†åˆ›é€ å‡ºæ›´å¤šå¯èƒ½æ€§ã€‚ä½œä¸ºå¼€å‘è€…ï¼Œè¦åœ¨æŠ€æœ¯åˆ›æ–°å’Œå®ç”¨æ€§ä¹‹é—´æ‰¾åˆ°å¹³è¡¡ï¼Œæ—¢è¦è¿½æ±‚æŠ€æœ¯çš„å…ˆè¿›æ€§ï¼Œä¹Ÿè¦è€ƒè™‘å®é™…åº”ç”¨çš„å¯è¡Œæ€§ã€‚

**æœªæ¥è§„åˆ’**: ä¸“æ³¨äºå‰æ²¿æŠ€æœ¯çš„ç ”ç©¶å’Œåº”ç”¨ï¼Œç‰¹åˆ«æ˜¯é›¶çŸ¥è¯†è¯æ˜ã€è·¨é“¾æŠ€æœ¯å’ŒAIé›†æˆç­‰é¢†åŸŸï¼Œä¸ºåŒºå—é“¾æŠ€æœ¯çš„å‘å±•è´¡çŒ®åˆ›æ–°æ€è·¯å’Œè§£å†³æ–¹æ¡ˆã€‚